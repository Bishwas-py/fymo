var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
var __publicField = (obj, key2, value) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_IS_CONTROLLED = 1 << 2;
var EACH_IS_ANIMATED = 1 << 3;
var EACH_ITEM_IMMUTABLE = 1 << 4;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_BINDABLE = 1 << 3;
var PROPS_IS_LAZY_INITIAL = 1 << 4;
var TRANSITION_IN = 1;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_FRAGMENT = 1;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var TEMPLATE_USE_SVG = 1 << 2;
var TEMPLATE_USE_MATHML = 1 << 3;
var HYDRATION_START = "[";
var HYDRATION_START_ELSE = "[!";
var HYDRATION_END = "]";
var HYDRATION_ERROR = {};
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var UNINITIALIZED = Symbol();
var FILENAME = Symbol("filename");
var HMR = Symbol("hmr");
var NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
var NAMESPACE_SVG = "http://www.w3.org/2000/svg";
var NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
var ATTACHMENT_KEY = "@attach";

// node_modules/esm-env/true.js
var true_default = true;

// node_modules/esm-env/dev-fallback.js
var node_env = globalThis.process?.env?.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");

// node_modules/svelte/src/internal/shared/utils.js
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
function is_function(thing) {
  return typeof thing === "function";
}
var noop = () => {
};
function is_promise(value) {
  return typeof value?.then === "function";
}
function run(fn) {
  return fn();
}
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function fallback(value, fallback2, lazy = false) {
  return value === void 0 ? lazy ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value;
}
function to_array(value, n) {
  if (Array.isArray(value)) {
    return value;
  }
  if (n === void 0 || !(Symbol.iterator in value)) {
    return Array.from(value);
  }
  const array = [];
  for (const element2 of value) {
    array.push(element2);
    if (array.length === n) break;
  }
  return array;
}

// node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var BOUNDARY_EFFECT = 1 << 7;
var UNOWNED = 1 << 8;
var DISCONNECTED = 1 << 9;
var CLEAN = 1 << 10;
var DIRTY = 1 << 11;
var MAYBE_DIRTY = 1 << 12;
var INERT = 1 << 13;
var DESTROYED = 1 << 14;
var EFFECT_RAN = 1 << 15;
var EFFECT_TRANSPARENT = 1 << 16;
var INSPECT_EFFECT = 1 << 17;
var HEAD_EFFECT = 1 << 18;
var EFFECT_PRESERVED = 1 << 19;
var USER_EFFECT = 1 << 20;
var REACTION_IS_UPDATING = 1 << 21;
var ASYNC = 1 << 22;
var ERROR_VALUE = 1 << 23;
var STATE_SYMBOL = Symbol("$state");
var LEGACY_PROPS = Symbol("legacy props");
var LOADING_ATTR_SYMBOL = Symbol("");
var PROXY_PATH_SYMBOL = Symbol("proxy path");
var STALE_REACTION = new class StaleReactionError extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "StaleReactionError");
    __publicField(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}();
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_FRAGMENT_NODE = 11;

// node_modules/svelte/src/internal/shared/errors.js
function await_outside_boundary() {
  if (dev_fallback_default) {
    const error = new Error(`await_outside_boundary
Cannot await outside a \`<svelte:boundary>\` with a \`pending\` snippet
https://svelte.dev/e/await_outside_boundary`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/await_outside_boundary`);
  }
}
function invalid_default_snippet() {
  if (dev_fallback_default) {
    const error = new Error(`invalid_default_snippet
Cannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead
https://svelte.dev/e/invalid_default_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_default_snippet`);
  }
}
function invalid_snippet_arguments() {
  if (dev_fallback_default) {
    const error = new Error(`invalid_snippet_arguments
A snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`
https://svelte.dev/e/invalid_snippet_arguments`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
  }
}
function snippet_without_render_tag() {
  if (dev_fallback_default) {
    const error = new Error(`snippet_without_render_tag
Attempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.
https://svelte.dev/e/snippet_without_render_tag`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
  }
}
function store_invalid_shape(name) {
  if (dev_fallback_default) {
    const error = new Error(`store_invalid_shape
\`${name}\` is not a store with a \`subscribe\` method
https://svelte.dev/e/store_invalid_shape`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/store_invalid_shape`);
  }
}
function svelte_element_invalid_this_value() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
  }
}

// node_modules/svelte/src/internal/client/errors.js
function async_derived_orphan() {
  if (dev_fallback_default) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function bind_invalid_checkbox_value() {
  if (dev_fallback_default) {
    const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
function component_api_changed(method, component2) {
  if (dev_fallback_default) {
    const error = new Error(`component_api_changed
Calling \`${method}\` on a component instance (of ${component2}) is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_changed`);
  }
}
function component_api_invalid_new(component2, name) {
  if (dev_fallback_default) {
    const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component2} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
  }
}
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function each_key_duplicate(a, b, value) {
  if (dev_fallback_default) {
    const error = new Error(`each_key_duplicate
${value ? `Keyed each block has duplicate key \`${value}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}
https://svelte.dev/e/each_key_duplicate`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/each_key_duplicate`);
  }
}
function effect_in_teardown(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
function effect_in_unowned_derived() {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
function effect_orphan(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
function effect_pending_outside_reaction() {
  if (dev_fallback_default) {
    const error = new Error(`effect_pending_outside_reaction
\`$effect.pending()\` can only be called inside an effect or derived
https://svelte.dev/e/effect_pending_outside_reaction`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function flush_sync_in_effect() {
  if (dev_fallback_default) {
    const error = new Error(`flush_sync_in_effect
Cannot use \`flushSync\` inside an effect
https://svelte.dev/e/flush_sync_in_effect`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/flush_sync_in_effect`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function invalid_snippet() {
  if (dev_fallback_default) {
    const error = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet`);
  }
}
function props_invalid_value(key2) {
  if (dev_fallback_default) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function props_rest_readonly(property) {
  if (dev_fallback_default) {
    const error = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_rest_readonly`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}

// node_modules/svelte/src/internal/client/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function assignment_value_stale(property, location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] assignment_value_stale
%cAssignment to \`${property}\` property (${location}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.
https://svelte.dev/e/assignment_value_stale`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/assignment_value_stale`);
  }
}
function await_reactivity_loss(name) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_reactivity_loss`);
  }
}
function await_waterfall(name, location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
function binding_property_non_reactive(binding, location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] binding_property_non_reactive
%c${location ? `\`${binding}\` (${location}) is binding to a non-reactive property` : `\`${binding}\` is binding to a non-reactive property`}
https://svelte.dev/e/binding_property_non_reactive`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
  }
}
function console_log_state(method) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] console_log_state
%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead
https://svelte.dev/e/console_log_state`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/console_log_state`);
  }
}
function event_handler_invalid(handler, suggestion) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] event_handler_invalid
%c${handler} should be a function. Did you mean to ${suggestion}?
https://svelte.dev/e/event_handler_invalid`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/event_handler_invalid`);
  }
}
function hydration_attribute_changed(attribute, html2, value) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html2}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
function hydration_html_changed(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_html_changed
%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_html_changed`);
  }
}
function hydration_mismatch(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function ownership_invalid_binding(parent, prop2, child2, owner) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] ownership_invalid_binding
%c${parent} passed property \`${prop2}\` to ${child2} with \`bind:\`, but its parent component ${owner} did not declare \`${prop2}\` as a binding. Consider creating a binding between ${owner} and ${parent} (e.g. \`bind:${prop2}={...}\` instead of \`${prop2}={...}\`)
https://svelte.dev/e/ownership_invalid_binding`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
  }
}
function ownership_invalid_mutation(name, location, prop2, parent) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] ownership_invalid_mutation
%cMutating unbound props (\`${name}\`, at ${location}) is strongly discouraged. Consider using \`bind:${prop2}={...}\` in ${parent} (or using a callback) instead
https://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
  }
}
function select_multiple_invalid_value() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function svelte_boundary_reset_noop() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}
function reset(node) {
  if (!hydrating) return;
  if (get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
function hydrate_template(template) {
  if (hydrating) {
    hydrate_node = template.content;
  }
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function remove_nodes() {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function not_equal(a, b) {
  return a !== b;
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag = false;
var legacy_mode_flag = false;
var tracing_mode_flag = false;

// node_modules/svelte/src/internal/shared/warnings.js
var bold2 = "font-weight: bold";
var normal2 = "font-weight: normal";
function dynamic_void_element_content(tag2) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag2}">\` is a void element \u2014 it cannot have content
https://svelte.dev/e/dynamic_void_element_content`, bold2, normal2);
  } else {
    console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
  }
}
function state_snapshot_uncloneable(properties) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` \u2014 the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` \u2014 the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`,
      bold2,
      normal2
    );
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}

// node_modules/svelte/src/internal/shared/clone.js
var empty = [];
function snapshot(value, skip_warning = false, no_tojson = false) {
  if (dev_fallback_default && !skip_warning) {
    const paths = [];
    const copy = clone(value, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
function clone(value, cloned, path, paths, original = null, no_tojson = false) {
  if (typeof value === "object" && value !== null) {
    var unwrapped = cloned.get(value);
    if (unwrapped !== void 0) return unwrapped;
    if (value instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value)
    );
    if (value instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value)
    );
    if (is_array(value)) {
      var copy = (
        /** @type {Snapshot<any>} */
        Array(value.length)
      );
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var i = 0; i < value.length; i += 1) {
        var element2 = value[i];
        if (i in value) {
          copy[i] = clone(element2, cloned, dev_fallback_default ? `${path}[${i}]` : path, paths, null, no_tojson);
        }
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      copy = {};
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var key2 in value) {
        copy[key2] = clone(
          // @ts-expect-error
          value[key2],
          cloned,
          dev_fallback_default ? `${path}.${key2}` : path,
          paths,
          null,
          no_tojson
        );
      }
      return copy;
    }
    if (value instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value.toJSON === "function" && !no_tojson) {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value.toJSON(),
        cloned,
        dev_fallback_default ? `${path}.toJSON()` : path,
        paths,
        // Associate the instance with the toJSON clone
        value
      );
    }
  }
  if (value instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value)
    );
  } catch (e) {
    if (dev_fallback_default) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
}

// node_modules/svelte/src/internal/client/dev/tracing.js
var tracing_expressions = null;
function log_entry(signal, entry) {
  const value = signal.v;
  if (value === UNINITIALIZED) {
    return;
  }
  const type = get_type(signal);
  const current_reaction = (
    /** @type {Reaction} */
    active_reaction
  );
  const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0;
  const style = dirty ? "color: CornflowerBlue; font-weight: bold" : "color: grey; font-weight: normal";
  console.groupCollapsed(
    signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`,
    style,
    dirty ? "font-weight: normal" : style,
    typeof value === "object" && value !== null && STATE_SYMBOL in value ? snapshot(value, true) : value
  );
  if (type === "$derived") {
    const deps = new Set(
      /** @type {Derived} */
      signal.deps
    );
    for (const dep of deps) {
      log_entry(dep);
    }
  }
  if (signal.created) {
    console.log(signal.created);
  }
  if (dirty && signal.updated) {
    for (const updated of signal.updated.values()) {
      console.log(updated.error);
    }
  }
  if (entry) {
    for (var trace2 of entry.traces) {
      console.log(trace2);
    }
  }
  console.groupEnd();
}
function get_type(signal) {
  if ((signal.f & (DERIVED | ASYNC)) !== 0) return "$derived";
  return signal.label?.startsWith("$") ? "store" : "$state";
}
function trace(label, fn) {
  var previously_tracing_expressions = tracing_expressions;
  try {
    tracing_expressions = { entries: /* @__PURE__ */ new Map(), reaction: active_reaction };
    var start = performance.now();
    var value = fn();
    var time = (performance.now() - start).toFixed(2);
    var prefix = untrack(label);
    if (!effect_tracking()) {
      console.log(`${prefix} %cran outside of an effect (${time}ms)`, "color: grey");
    } else if (tracing_expressions.entries.size === 0) {
      console.log(`${prefix} %cno reactive dependencies (${time}ms)`, "color: grey");
    } else {
      console.group(`${prefix} %c(${time}ms)`, "color: grey");
      var entries = tracing_expressions.entries;
      untrack(() => {
        for (const [signal, traces] of entries) {
          log_entry(signal, traces);
        }
      });
      tracing_expressions = null;
      console.groupEnd();
    }
    return value;
  } finally {
    tracing_expressions = previously_tracing_expressions;
  }
}
function get_stack(label) {
  let error = Error();
  const stack2 = error.stack;
  if (!stack2) return null;
  const lines = stack2.split("\n");
  const new_lines = ["\n"];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return null;
    }
    if (line.includes("svelte/src/internal")) {
      continue;
    }
    new_lines.push(line);
  }
  if (new_lines.length === 1) {
    return null;
  }
  define_property(error, "stack", {
    value: new_lines.join("\n")
  });
  define_property(error, "name", {
    // 'Error' suffix is required for stack traces to be rendered properly
    value: `${label}Error`
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function tag(source2, label) {
  source2.label = label;
  tag_proxy(source2.v, label);
  return source2;
}
function tag_proxy(value, label) {
  value?.[PROXY_PATH_SYMBOL]?.(label);
  return value;
}

// node_modules/svelte/src/internal/client/context.js
var component_context = null;
function set_component_context(context) {
  component_context = context;
}
var dev_stack = null;
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
function add_svelte_meta(callback, type, component2, line, column, additional) {
  const parent = dev_stack;
  dev_stack = {
    type,
    file: component2[FILENAME],
    line,
    column,
    parent,
    ...additional
  };
  try {
    return callback();
  } finally {
    dev_stack = parent;
  }
}
var dev_current_component_function = null;
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  component_context = context.p;
  if (dev_fallback_default) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component2 ?? /** @type {T} */
  {};
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}

// node_modules/svelte/src/internal/client/error-handling.js
var adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & EFFECT_RAN) === 0) {
    if ((effect2.f & BOUNDARY_EFFECT) === 0) {
      if (!effect2.parent && error instanceof Error) {
        apply_adjustments(error);
      }
      throw error;
    }
    effect2.b.error(error);
  } else {
    invoke_error_boundary(error, effect2);
  }
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${effect2.fn?.name || "<unknown>"}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${context.function?.[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: error.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}

// node_modules/svelte/src/internal/client/dom/task.js
var request_idle_callback = typeof requestIdleCallback === "undefined" ? (cb) => setTimeout(cb, 1) : requestIdleCallback;
var micro_tasks = [];
var idle_tasks = [];
function run_micro_tasks() {
  var tasks2 = micro_tasks;
  micro_tasks = [];
  run_all(tasks2);
}
function run_idle_tasks() {
  var tasks2 = idle_tasks;
  idle_tasks = [];
  run_all(tasks2);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0) {
    queueMicrotask(run_micro_tasks);
  }
  micro_tasks.push(fn);
}
function queue_idle_task(fn) {
  if (idle_tasks.length === 0) {
    request_idle_callback(run_idle_tasks);
  }
  idle_tasks.push(fn);
}
function flush_tasks() {
  if (micro_tasks.length > 0) {
    run_micro_tasks();
  }
  if (idle_tasks.length > 0) {
    run_idle_tasks();
  }
}

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  if (dev_fallback_default) {
    tag(version, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
var _anchor, _hydrate_open, _props, _children, _effect, _main_effect, _pending_effect, _failed_effect, _offscreen_fragment, _pending_count, _is_creating_fallback, _effect_pending, _effect_pending_update, _effect_pending_subscriber, _Boundary_instances, run_fn, show_pending_snippet_fn, update_pending_count_fn;
var Boundary = class {
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    __privateAdd(this, _Boundary_instances);
    __publicField(this, "pending", false);
    /** @type {Boundary | null} */
    __publicField(this, "parent");
    /** @type {TemplateNode} */
    __privateAdd(this, _anchor);
    /** @type {TemplateNode} */
    __privateAdd(this, _hydrate_open);
    /** @type {BoundaryProps} */
    __privateAdd(this, _props);
    /** @type {((anchor: Node) => void)} */
    __privateAdd(this, _children);
    /** @type {Effect} */
    __privateAdd(this, _effect);
    /** @type {Effect | null} */
    __privateAdd(this, _main_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _pending_effect, null);
    /** @type {Effect | null} */
    __privateAdd(this, _failed_effect, null);
    /** @type {DocumentFragment | null} */
    __privateAdd(this, _offscreen_fragment, null);
    __privateAdd(this, _pending_count, 0);
    __privateAdd(this, _is_creating_fallback, false);
    /**
     * A source containing the number of pending async deriveds/expressions.
     * Only created if `$effect.pending()` is used inside the boundary,
     * otherwise updating the source results in needless `Batch.ensure()`
     * calls followed by no-op flushes
     * @type {Source<number> | null}
     */
    __privateAdd(this, _effect_pending, null);
    __privateAdd(this, _effect_pending_update, () => {
      if (__privateGet(this, _effect_pending)) {
        internal_set(__privateGet(this, _effect_pending), __privateGet(this, _pending_count));
      }
    });
    __privateAdd(this, _effect_pending_subscriber, createSubscriber(() => {
      __privateSet(this, _effect_pending, source(__privateGet(this, _pending_count)));
      if (dev_fallback_default) {
        tag(__privateGet(this, _effect_pending), "$effect.pending()");
      }
      return () => {
        __privateSet(this, _effect_pending, null);
      };
    }));
    __privateSet(this, _anchor, node);
    __privateSet(this, _props, props);
    __privateSet(this, _children, children);
    __privateSet(this, _hydrate_open, hydrate_node);
    this.parent = /** @type {Effect} */
    active_effect.b;
    this.pending = !!__privateGet(this, _props).pending;
    __privateSet(this, _effect, block(() => {
      active_effect.b = this;
      if (hydrating) {
        hydrate_next();
      }
      const pending3 = __privateGet(this, _props).pending;
      if (hydrating && pending3) {
        __privateSet(this, _pending_effect, branch(() => pending3(__privateGet(this, _anchor))));
        Batch.enqueue(() => {
          __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
            Batch.ensure();
            return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
          }));
          if (__privateGet(this, _pending_count) > 0) {
            __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
          } else {
            pause_effect(
              /** @type {Effect} */
              __privateGet(this, _pending_effect),
              () => {
                __privateSet(this, _pending_effect, null);
              }
            );
            this.pending = false;
          }
        });
      } else {
        try {
          __privateSet(this, _main_effect, branch(() => children(__privateGet(this, _anchor))));
        } catch (error) {
          this.error(error);
        }
        if (__privateGet(this, _pending_count) > 0) {
          __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
        } else {
          this.pending = false;
        }
      }
    }, flags));
    if (hydrating) {
      __privateSet(this, _anchor, hydrate_node);
    }
  }
  has_pending_snippet() {
    return !!__privateGet(this, _props).pending;
  }
  /** @param {1 | -1} d */
  update_pending_count(d) {
    var _a;
    if (this.has_pending_snippet()) {
      __privateMethod(this, _Boundary_instances, update_pending_count_fn).call(this, d);
    } else if (this.parent) {
      __privateMethod(_a = this.parent, _Boundary_instances, update_pending_count_fn).call(_a, d);
    }
    effect_pending_updates.add(__privateGet(this, _effect_pending_update));
  }
  get_effect_pending() {
    __privateGet(this, _effect_pending_subscriber).call(this);
    return get(
      /** @type {Source<number>} */
      __privateGet(this, _effect_pending)
    );
  }
  /** @param {unknown} error */
  error(error) {
    var onerror = __privateGet(this, _props).onerror;
    let failed = __privateGet(this, _props).failed;
    if (__privateGet(this, _main_effect)) {
      destroy_effect(__privateGet(this, _main_effect));
      __privateSet(this, _main_effect, null);
    }
    if (__privateGet(this, _pending_effect)) {
      destroy_effect(__privateGet(this, _pending_effect));
      __privateSet(this, _pending_effect, null);
    }
    if (__privateGet(this, _failed_effect)) {
      destroy_effect(__privateGet(this, _failed_effect));
      __privateSet(this, _failed_effect, null);
    }
    if (hydrating) {
      set_hydrate_node(__privateGet(this, _hydrate_open));
      next();
      set_hydrate_node(remove_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset2 = () => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      __privateSet(this, _pending_count, 0);
      if (__privateGet(this, _failed_effect) !== null) {
        pause_effect(__privateGet(this, _failed_effect), () => {
          __privateSet(this, _failed_effect, null);
        });
      }
      this.pending = true;
      __privateSet(this, _main_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
        __privateSet(this, _is_creating_fallback, false);
        return branch(() => __privateGet(this, _children).call(this, __privateGet(this, _anchor)));
      }));
      if (__privateGet(this, _pending_count) > 0) {
        __privateMethod(this, _Boundary_instances, show_pending_snippet_fn).call(this);
      } else {
        this.pending = false;
      }
    };
    if (__privateGet(this, _is_creating_fallback) || !onerror && !failed) {
      throw error;
    }
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror?.(error, reset2);
      calling_on_error = false;
    } catch (error2) {
      invoke_error_boundary(error2, __privateGet(this, _effect) && __privateGet(this, _effect).parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        __privateSet(this, _failed_effect, __privateMethod(this, _Boundary_instances, run_fn).call(this, () => {
          __privateSet(this, _is_creating_fallback, true);
          try {
            return branch(() => {
              failed(
                __privateGet(this, _anchor),
                () => error,
                () => reset2
              );
            });
          } catch (error2) {
            invoke_error_boundary(
              error2,
              /** @type {Effect} */
              __privateGet(this, _effect).parent
            );
            return null;
          } finally {
            __privateSet(this, _is_creating_fallback, false);
          }
        }));
      });
    }
  }
};
_anchor = new WeakMap();
_hydrate_open = new WeakMap();
_props = new WeakMap();
_children = new WeakMap();
_effect = new WeakMap();
_main_effect = new WeakMap();
_pending_effect = new WeakMap();
_failed_effect = new WeakMap();
_offscreen_fragment = new WeakMap();
_pending_count = new WeakMap();
_is_creating_fallback = new WeakMap();
_effect_pending = new WeakMap();
_effect_pending_update = new WeakMap();
_effect_pending_subscriber = new WeakMap();
_Boundary_instances = new WeakSet();
/**
 * @param {() => Effect | null} fn
 */
run_fn = function(fn) {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_ctx = component_context;
  set_active_effect(__privateGet(this, _effect));
  set_active_reaction(__privateGet(this, _effect));
  set_component_context(__privateGet(this, _effect).ctx);
  try {
    return fn();
  } catch (e) {
    handle_error(e);
    return null;
  } finally {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_ctx);
  }
};
show_pending_snippet_fn = function() {
  const pending3 = (
    /** @type {(anchor: Node) => void} */
    __privateGet(this, _props).pending
  );
  if (__privateGet(this, _main_effect) !== null) {
    __privateSet(this, _offscreen_fragment, document.createDocumentFragment());
    move_effect(__privateGet(this, _main_effect), __privateGet(this, _offscreen_fragment));
  }
  if (__privateGet(this, _pending_effect) === null) {
    __privateSet(this, _pending_effect, branch(() => pending3(__privateGet(this, _anchor))));
  }
};
/** @param {1 | -1} d */
update_pending_count_fn = function(d) {
  __privateSet(this, _pending_count, __privateGet(this, _pending_count) + d);
  if (__privateGet(this, _pending_count) === 0) {
    this.pending = false;
    if (__privateGet(this, _pending_effect)) {
      pause_effect(__privateGet(this, _pending_effect), () => {
        __privateSet(this, _pending_effect, null);
      });
    }
    if (__privateGet(this, _offscreen_fragment)) {
      __privateGet(this, _anchor).before(__privateGet(this, _offscreen_fragment));
      __privateSet(this, _offscreen_fragment, null);
    }
  }
};
function move_effect(effect2, fragment) {
  var node = effect2.nodes_start;
  var end = effect2.nodes_end;
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    fragment.append(node);
    node = next2;
  }
}
function get_pending_boundary() {
  var boundary2 = (
    /** @type {Effect} */
    active_effect.b
  );
  while (boundary2 !== null && !boundary2.has_pending_snippet()) {
    boundary2 = boundary2.parent;
  }
  if (boundary2 === null) {
    await_outside_boundary();
  }
  return boundary2;
}
function pending() {
  if (active_effect === null) {
    effect_pending_outside_reaction();
  }
  var boundary2 = active_effect.b;
  if (boundary2 === null) {
    return 0;
  }
  return boundary2.get_effect_pending();
}

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
var current_async_effect = null;
function set_from_async_derived(v) {
  current_async_effect = v;
}
var recent_async_deriveds = /* @__PURE__ */ new Set();
// @__NO_SIDE_EFFECTS__
function derived(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect === null || parent_derived !== null && (parent_derived.f & UNOWNED) !== 0) {
    flags2 |= UNOWNED;
  } else {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = get_stack("CreatedAt");
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function async_derived(fn, location) {
  let parent = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent.b
  );
  var promise = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  var prev = null;
  var should_suspend = !active_reaction;
  async_effect(() => {
    if (dev_fallback_default) current_async_effect = active_effect;
    try {
      var p = fn();
      if (prev) Promise.resolve(p).catch(() => {
      });
    } catch (error) {
      p = Promise.reject(error);
    }
    if (dev_fallback_default) current_async_effect = null;
    var r2 = () => p;
    promise = prev?.then(r2, r2) ?? Promise.resolve(p);
    prev = promise;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var pending3 = boundary2.pending;
    if (should_suspend) {
      boundary2.update_pending_count(1);
      if (!pending3) batch.increment();
    }
    const handler = (value, error = void 0) => {
      prev = null;
      current_async_effect = null;
      if (!pending3) batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
        if (dev_fallback_default && location !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        if (!pending3) batch.decrement();
      }
      unset_context();
    };
    promise.then(handler, (e) => handler(null, e || "unknown"));
    if (batch) {
      return () => {
        queueMicrotask(() => batch.neuter());
      };
    }
  });
  if (dev_fallback_default) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p) {
      function go() {
        if (p === promise) {
          fulfil(signal);
        } else {
          next2(promise);
        }
      }
      p.then(go, go);
    }
    next2(promise);
  });
}
// @__NO_SIDE_EFFECTS__
function user_derived(fn) {
  const d = /* @__PURE__ */ derived(fn);
  push_reaction_value(d);
  return d;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn) {
  const signal = /* @__PURE__ */ derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived2) {
  var effects = derived2.effects;
  if (effects !== null) {
    derived2.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
var stack = [];
function get_derived_parent_effect(derived2) {
  var parent = derived2.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived2) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived2));
  if (dev_fallback_default) {
    let prev_inspect_effects = inspect_effects;
    set_inspect_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived2)) {
        derived_references_self();
      }
      stack.push(derived2);
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
      set_inspect_effects(prev_inspect_effects);
      stack.pop();
    }
  } else {
    try {
      destroy_derived_effects(derived2);
      value = update_reaction(derived2);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived2) {
  var value = execute_derived(derived2);
  if (!derived2.equals(value)) {
    derived2.v = value;
    derived2.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_deriveds !== null) {
    batch_deriveds.set(derived2, derived2.v);
  } else {
    var status = (skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived2, status);
  }
}

// node_modules/svelte/src/internal/client/reactivity/async.js
function flatten(sync, async2, fn) {
  const d = is_runes() ? derived : derived_safe_equal;
  if (async2.length === 0) {
    fn(sync.map(d));
    return;
  }
  var batch = current_batch;
  var parent = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  var boundary2 = get_pending_boundary();
  Promise.all(async2.map((expression) => async_derived(expression))).then((result) => {
    batch?.activate();
    restore();
    try {
      fn([...sync.map(d), ...result]);
    } catch (error) {
      if ((parent.f & DESTROYED) === 0) {
        invoke_error_boundary(error, parent);
      }
    }
    batch?.deactivate();
    unset_context();
  }).catch((error) => {
    boundary2.error(error);
  });
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  return function restore() {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    previous_batch2?.activate();
    if (dev_fallback_default) {
      set_from_async_derived(null);
    }
  };
}
async function save(promise) {
  var restore = capture();
  var value = await promise;
  return () => {
    restore();
    return value;
  };
}
async function track_reactivity_loss(promise) {
  var previous_async_effect = current_async_effect;
  var value = await promise;
  return () => {
    set_from_async_derived(previous_async_effect);
    return value;
  };
}
async function* for_await_track_reactivity_loss(iterable) {
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  if (iterator === void 0) {
    throw new TypeError("value is not async iterable");
  }
  let normal_completion = false;
  try {
    while (true) {
      const { done, value } = (await track_reactivity_loss(iterator.next()))();
      if (done) {
        normal_completion = true;
        break;
      }
      yield value;
    }
  } finally {
    if (normal_completion && iterator.return !== void 0) {
      return (
        /** @type {TReturn} */
        (await track_reactivity_loss(iterator.return()))().value
      );
    }
  }
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (dev_fallback_default) set_from_async_derived(null);
}
async function async_body(fn) {
  var unsuspend = suspend();
  var active = (
    /** @type {Effect} */
    active_effect
  );
  try {
    await fn();
  } catch (error) {
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  } finally {
    unsuspend();
  }
}

// node_modules/svelte/src/internal/client/reactivity/batch.js
var batches = /* @__PURE__ */ new Set();
var current_batch = null;
var previous_batch = null;
var batch_deriveds = null;
var effect_pending_updates = /* @__PURE__ */ new Set();
var tasks = [];
function dequeue() {
  const task = (
    /** @type {() => void} */
    tasks.shift()
  );
  if (tasks.length > 0) {
    queueMicrotask(dequeue);
  }
  task();
}
var queued_root_effects = [];
var last_scheduled_effect = null;
var is_flushing = false;
var is_flushing_sync = false;
var _previous, _callbacks, _pending, _deferred, _neutered, _async_effects, _boundary_async_effects, _render_effects, _effects, _block_effects, _dirty_effects, _maybe_dirty_effects, _Batch_instances, traverse_effect_tree_fn, defer_effects_fn, commit_fn;
var _Batch = class _Batch {
  constructor() {
    __privateAdd(this, _Batch_instances);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    __publicField(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    __privateAdd(this, _previous, /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    __privateAdd(this, _callbacks, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    __privateAdd(this, _pending, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    __privateAdd(this, _deferred, null);
    /**
     * True if an async effect inside this batch resolved and
     * its parent branch was already deleted
     */
    __privateAdd(this, _neutered, false);
    /**
     * Async effects (created inside `async_derived`) encountered during processing.
     * These run after the rest of the batch has updated, since they should
     * always have the latest values
     * @type {Effect[]}
     */
    __privateAdd(this, _async_effects, []);
    /**
     * The same as `#async_effects`, but for effects inside a newly-created
     * `<svelte:boundary>` — these do not prevent the batch from committing
     * @type {Effect[]}
     */
    __privateAdd(this, _boundary_async_effects, []);
    /**
     * Template effects and `$effect.pre` effects, which run when
     * a batch is committed
     * @type {Effect[]}
     */
    __privateAdd(this, _render_effects, []);
    /**
     * The same as `#render_effects`, but for `$effect` (which runs after)
     * @type {Effect[]}
     */
    __privateAdd(this, _effects, []);
    /**
     * Block effects, which may need to re-run on subsequent flushes
     * in order to update internal sources (e.g. each block items)
     * @type {Effect[]}
     */
    __privateAdd(this, _block_effects, []);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _dirty_effects, []);
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Effect[]}
     */
    __privateAdd(this, _maybe_dirty_effects, []);
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed — we skip over these during `process`
     * @type {Set<Effect>}
     */
    __publicField(this, "skipped_effects", /* @__PURE__ */ new Set());
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    queued_root_effects = [];
    previous_batch = null;
    var current_values = null;
    if (async_mode_flag && batches.size > 1) {
      current_values = /* @__PURE__ */ new Map();
      batch_deriveds = /* @__PURE__ */ new Map();
      for (const [source2, current] of this.current) {
        current_values.set(source2, { v: source2.v, wv: source2.wv });
        source2.v = current;
      }
      for (const batch of batches) {
        if (batch === this) continue;
        for (const [source2, previous] of __privateGet(batch, _previous)) {
          if (!current_values.has(source2)) {
            current_values.set(source2, { v: source2.v, wv: source2.wv });
            source2.v = previous;
          }
        }
      }
    }
    for (const root of root_effects) {
      __privateMethod(this, _Batch_instances, traverse_effect_tree_fn).call(this, root);
    }
    if (__privateGet(this, _async_effects).length === 0 && __privateGet(this, _pending) === 0) {
      __privateMethod(this, _Batch_instances, commit_fn).call(this);
      var render_effects = __privateGet(this, _render_effects);
      var effects = __privateGet(this, _effects);
      __privateSet(this, _render_effects, []);
      __privateSet(this, _effects, []);
      __privateSet(this, _block_effects, []);
      previous_batch = current_batch;
      current_batch = null;
      flush_queued_effects(render_effects);
      flush_queued_effects(effects);
      if (current_batch === null) {
        current_batch = this;
      } else {
        batches.delete(this);
      }
      __privateGet(this, _deferred)?.resolve();
    } else {
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _render_effects));
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _effects));
      __privateMethod(this, _Batch_instances, defer_effects_fn).call(this, __privateGet(this, _block_effects));
    }
    if (current_values) {
      for (const [source2, { v, wv }] of current_values) {
        if (source2.wv <= wv) {
          source2.v = v;
        }
      }
      batch_deriveds = null;
    }
    for (const effect2 of __privateGet(this, _async_effects)) {
      update_effect(effect2);
    }
    for (const effect2 of __privateGet(this, _boundary_async_effects)) {
      update_effect(effect2);
    }
    __privateSet(this, _async_effects, []);
    __privateSet(this, _boundary_async_effects, []);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value) {
    if (!__privateGet(this, _previous).has(source2)) {
      __privateGet(this, _previous).set(source2, value);
    }
    this.current.set(source2, source2.v);
  }
  activate() {
    current_batch = this;
  }
  deactivate() {
    current_batch = null;
    previous_batch = null;
    for (const update2 of effect_pending_updates) {
      effect_pending_updates.delete(update2);
      update2();
      if (current_batch !== null) {
        break;
      }
    }
  }
  neuter() {
    __privateSet(this, _neutered, true);
  }
  flush() {
    if (queued_root_effects.length > 0) {
      flush_effects();
    } else {
      __privateMethod(this, _Batch_instances, commit_fn).call(this);
    }
    if (current_batch !== this) {
      return;
    }
    if (__privateGet(this, _pending) === 0) {
      batches.delete(this);
    }
    this.deactivate();
  }
  increment() {
    __privateSet(this, _pending, __privateGet(this, _pending) + 1);
  }
  decrement() {
    __privateSet(this, _pending, __privateGet(this, _pending) - 1);
    if (__privateGet(this, _pending) === 0) {
      for (const e of __privateGet(this, _dirty_effects)) {
        set_signal_status(e, DIRTY);
        schedule_effect(e);
      }
      for (const e of __privateGet(this, _maybe_dirty_effects)) {
        set_signal_status(e, MAYBE_DIRTY);
        schedule_effect(e);
      }
      __privateSet(this, _render_effects, []);
      __privateSet(this, _effects, []);
      this.flush();
    } else {
      this.deactivate();
    }
  }
  /** @param {() => void} fn */
  add_callback(fn) {
    __privateGet(this, _callbacks).add(fn);
  }
  settled() {
    return (__privateGet(this, _deferred) ?? __privateSet(this, _deferred, deferred())).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    if (tasks.length === 0) {
      queueMicrotask(dequeue);
    }
    tasks.unshift(task);
  }
};
_previous = new WeakMap();
_callbacks = new WeakMap();
_pending = new WeakMap();
_deferred = new WeakMap();
_neutered = new WeakMap();
_async_effects = new WeakMap();
_boundary_async_effects = new WeakMap();
_render_effects = new WeakMap();
_effects = new WeakMap();
_block_effects = new WeakMap();
_dirty_effects = new WeakMap();
_maybe_dirty_effects = new WeakMap();
_Batch_instances = new WeakSet();
/**
 * Traverse the effect tree, executing effects or stashing
 * them for later execution as appropriate
 * @param {Effect} root
 */
traverse_effect_tree_fn = function(root) {
  root.f ^= CLEAN;
  var effect2 = root.first;
  while (effect2 !== null) {
    var flags2 = effect2.f;
    var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
    var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
    var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect2);
    if (!skip && effect2.fn !== null) {
      if (is_branch) {
        effect2.f ^= CLEAN;
      } else if ((flags2 & EFFECT) !== 0) {
        __privateGet(this, _effects).push(effect2);
      } else if (async_mode_flag && (flags2 & RENDER_EFFECT) !== 0) {
        __privateGet(this, _render_effects).push(effect2);
      } else if ((flags2 & CLEAN) === 0) {
        if ((flags2 & ASYNC) !== 0) {
          var effects = effect2.b?.pending ? __privateGet(this, _boundary_async_effects) : __privateGet(this, _async_effects);
          effects.push(effect2);
        } else if (is_dirty(effect2)) {
          if ((effect2.f & BLOCK_EFFECT) !== 0) __privateGet(this, _block_effects).push(effect2);
          update_effect(effect2);
        }
      }
      var child2 = effect2.first;
      if (child2 !== null) {
        effect2 = child2;
        continue;
      }
    }
    var parent = effect2.parent;
    effect2 = effect2.next;
    while (effect2 === null && parent !== null) {
      effect2 = parent.next;
      parent = parent.parent;
    }
  }
};
/**
 * @param {Effect[]} effects
 */
defer_effects_fn = function(effects) {
  for (const e of effects) {
    const target = (e.f & DIRTY) !== 0 ? __privateGet(this, _dirty_effects) : __privateGet(this, _maybe_dirty_effects);
    target.push(e);
    set_signal_status(e, CLEAN);
  }
  effects.length = 0;
};
/**
 * Append and remove branches to/from the DOM
 */
commit_fn = function() {
  if (!__privateGet(this, _neutered)) {
    for (const fn of __privateGet(this, _callbacks)) {
      fn();
    }
  }
  __privateGet(this, _callbacks).clear();
};
var Batch = _Batch;
function flushSync(fn) {
  if (async_mode_flag && active_effect !== null) {
    flush_sync_in_effect();
  }
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      flush_effects();
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (dev_fallback_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            console.error(update2.error);
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
var eager_block_effects = null;
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = [];
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
        if (effect2.teardown === null && effect2.ac === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
      if (eager_block_effects?.length > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          update_effect(e);
        }
        eager_block_effects = [];
      }
    }
  }
  eager_block_effects = null;
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
function suspend() {
  var boundary2 = get_pending_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var pending3 = boundary2.pending;
  boundary2.update_pending_count(1);
  if (!pending3) batch.increment();
  return function unsuspend() {
    boundary2.update_pending_count(-1);
    if (!pending3) {
      batch.activate();
      batch.decrement();
    } else {
      batch.deactivate();
    }
    unset_context();
  };
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
var inspect_effects = /* @__PURE__ */ new Set();
var old_values = /* @__PURE__ */ new Map();
function set_inspect_effects(v) {
  inspect_effects = v;
}
var inspect_effects_deferred = false;
function set_inspect_effects_deferred() {
  inspect_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_stack("CreatedAt");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  var _a;
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    ((_a = component_context.l).s ?? (_a.s = [])).push(s);
  }
  return s;
}
function mutate(source2, value) {
  set(
    source2,
    untrack(() => get(source2))
  );
  return value;
}
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || active_effect !== null) {
        const error = get_stack("UpdatedAt");
        if (error !== null) {
          source2.updated ?? (source2.updated = /* @__PURE__ */ new Map());
          let entry = source2.updated.get(error.stack);
          if (!entry) {
            entry = { error, count: 0 };
            source2.updated.set(error.stack, entry);
          }
          entry.count++;
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (dev_fallback_default && inspect_effects.size > 0 && !inspect_effects_deferred) {
      flush_inspect_effects();
    }
  }
  return value;
}
function flush_inspect_effects() {
  inspect_effects_deferred = false;
  const inspects = Array.from(inspect_effects);
  for (const effect2 of inspects) {
    if ((effect2.f & CLEAN) !== 0) {
      set_signal_status(effect2, MAYBE_DIRTY);
    }
    if (is_dirty(effect2)) {
      update_effect(effect2);
    }
  }
  inspect_effects.clear();
}
function update(source2, d = 1) {
  var value = get(source2);
  var result = d === 1 ? value++ : value--;
  set(source2, value);
  return result;
}
function update_pre(source2, d = 1) {
  var value = get(source2);
  return set(source2, d === 1 ? ++value : --value);
}
function increment(source2) {
  set(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (dev_fallback_default && (flags2 & INSPECT_EFFECT) !== 0) {
      inspect_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      mark_reactions(
        /** @type {Derived} */
        reaction,
        MAYBE_DIRTY
      );
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0) {
        if (eager_block_effects !== null) {
          eager_block_effects.push(
            /** @type {Effect} */
            reaction
          );
        }
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}

// node_modules/svelte/src/internal/client/proxy.js
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = state(0);
  var stack2 = dev_fallback_default && tracing_mode_flag ? get_stack("CreatedAt") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(
      /** @type {any[]} */
      value.length,
      stack2
    ));
    if (dev_fallback_default) {
      value = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path = new_path;
    tag(version, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          s = with_parent(() => {
            var s2 = state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (dev_fallback_default && typeof prop2 === "string") {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
        } else {
          set(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version);
            if (dev_fallback_default) {
              tag(s2, get_label(path, prop2));
            }
          }
        } else {
          set(s, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (dev_fallback_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = state(p, stack2);
            if (dev_fallback_default) {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = state(p, stack2);
              if (dev_fallback_default) {
                tag(s2, get_label(path, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value2 = get(s);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value2, receiver) {
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (dev_fallback_default) {
                tag(other_s, get_label(path, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => state(void 0, stack2));
            if (dev_fallback_default) {
              tag(s, get_label(path, prop2));
            }
            set(s, proxy(value2));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set(ls, n + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get(version);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_label(path, prop2) {
  if (typeof prop2 === "symbol") return `${path}[Symbol(${prop2.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {
  }
  return value;
}
function is(a, b) {
  return Object.is(get_proxied_value(a), get_proxied_value(b));
}
var ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
  "copyWithin",
  "fill",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value;
      }
      return function(...args) {
        set_inspect_effects_deferred();
        var result = value.apply(this, args);
        flush_inspect_effects();
        return result;
      };
    }
  });
}

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}
function strict_equals(a, b, equal = true) {
  try {
    if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
      state_proxy_equality_mismatch(equal ? "===" : "!==");
    }
  } catch {
  }
  return a === b === equal;
}
function equals2(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
  }
  return a == b === equal;
}

// node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = (
    /** @type {TemplateNode} */
    /* @__PURE__ */ get_first_child(hydrate_node)
  );
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(child2);
  return child2;
}
function first_child(fragment, is_text) {
  if (!hydrating) {
    var first = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ get_first_child(
        /** @type {Node} */
        fragment
      )
    );
    if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
  if (is_text && hydrate_node?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    hydrate_node?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  return hydrate_node;
}
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text && next_sibling?.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    if (next_sibling === null) {
      last_sibling?.after(text2);
    } else {
      next_sibling.before(text2);
    }
    set_hydrate_node(text2);
    return text2;
  }
  set_hydrate_node(next_sibling);
  return (
    /** @type {TemplateNode} */
    next_sibling
  );
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  if (!async_mode_flag) return false;
  if (eager_block_effects !== null) return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & EFFECT_RAN) !== 0;
}
function create_element(tag2, namespace, is2) {
  let options = is2 ? { is: is2 } : void 0;
  if (namespace) {
    return document.createElementNS(namespace, tag2, options);
  }
  return document.createElement(tag2, options);
}
function create_fragment() {
  return document.createDocumentFragment();
}
function create_comment(data = "") {
  return document.createComment(data);
}
function set_attribute(element2, key2, value = "") {
  if (key2.startsWith("xlink:")) {
    element2.setAttributeNS("http://www.w3.org/1999/xlink", key2, value);
    return;
  }
  return element2.setAttribute(key2, value);
}

// node_modules/svelte/src/internal/client/dom/elements/misc.js
function autofocus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
function remove_textarea_child(dom) {
  if (hydrating && get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
var listening_to_form_reset = false;
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              e.__on_r?.();
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
      { capture: true }
    );
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function listen(target, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (var name of events) {
    target.addEventListener(name, handler);
  }
  teardown(() => {
    for (var name2 of events) {
      target.removeEventListener(name2, handler);
    }
  });
}
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element2.__on_r;
  if (prev) {
    element2.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element2.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}

// node_modules/svelte/src/internal/client/reactivity/effects.js
function validate_effect(rune) {
  if (active_effect === null && active_reaction === null) {
    effect_orphan(rune);
  }
  if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync, push2 = true) {
  var parent = active_effect;
  if (dev_fallback_default) {
    while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (dev_fallback_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  if (push2) {
    var e = effect2;
    if (sync && e.deps === null && e.teardown === null && e.nodes_start === null && e.first === e.last && // either `null`, or a singular child
    (e.f & EFFECT_PRESERVED) === 0) {
      e = e.first;
    }
    if (e !== null) {
      e.parent = parent;
      if (parent !== null) {
        push_effect(e, parent);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
        var derived2 = (
          /** @type {Derived} */
          active_reaction
        );
        (derived2.effects ?? (derived2.effects = [])).push(e);
      }
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
function user_effect(fn) {
  validate_effect("$effect");
  if (dev_fallback_default) {
    define_property(fn, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & EFFECT_RAN) === 0;
  if (defer) {
    var context = (
      /** @type {ComponentContext} */
      component_context
    );
    (context.e ?? (context.e = [])).push(fn);
  } else {
    return create_user_effect(fn);
  }
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function user_pre_effect(fn) {
  validate_effect("$effect.pre");
  if (dev_fallback_default) {
    define_property(fn, "name", {
      value: "$effect.pre"
    });
  }
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
}
function inspect_effect(fn) {
  return create_effect(INSPECT_EFFECT, fn, true);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function legacy_pre_effect(deps, fn) {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  var token = { effect: null, ran: false, deps };
  context.l.$.push(token);
  token.effect = render_effect(() => {
    deps();
    if (token.ran) return;
    token.ran = true;
    untrack(fn);
  });
}
function legacy_pre_effect_reset() {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  render_effect(() => {
    for (var token of context.l.$) {
      token.deps();
      var effect2 = token.effect;
      if ((effect2.f & CLEAN) !== 0) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
      token.ran = false;
    }
  });
}
function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function template_effect(fn, sync = [], async2 = []) {
  flatten(sync, async2, (values) => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
  });
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn, push2 = true) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push2);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null && effect2.nodes_end !== null) {
    remove_effect_dom(
      effect2.nodes_start,
      /** @type {TemplateNode} */
      effect2.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (dev_fallback_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = effect2.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect2);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}
function aborted(effect2 = (
  /** @type {Effect} */
  active_effect
)) {
  return (effect2.f & DESTROYED) !== 0;
}

// node_modules/svelte/src/internal/client/legacy.js
var captured_signals = null;
function capture_signals(fn) {
  var previous_captured_signals = captured_signals;
  try {
    captured_signals = /* @__PURE__ */ new Set();
    untrack(fn);
    if (previous_captured_signals !== null) {
      for (var signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    return captured_signals;
  } finally {
    captured_signals = previous_captured_signals;
  }
}
function invalidate_inner_signals(fn) {
  for (var signal of capture_signals(fn)) {
    internal_set(signal, signal.v);
  }
}

// node_modules/svelte/src/internal/client/runtime.js
var is_updating_effect = false;
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
var active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
var current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
var write_version = 1;
var read_version = 0;
var update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
var skip_reaction = false;
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags2 & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i;
      var dependency;
      var is_disconnected = (flags2 & DISCONNECTED) !== 0;
      var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
      var length = dependencies.length;
      if ((is_disconnected || is_unowned_connected) && (active_effect === null || (active_effect.f & DESTROYED) === 0)) {
        var derived2 = (
          /** @type {Derived} */
          reaction
        );
        var parent = derived2.parent;
        for (i = 0; i < length; i++) {
          dependency = dependencies[i];
          if (is_disconnected || !dependency?.reactions?.includes(derived2)) {
            (dependency.reactions ?? (dependency.reactions = [])).push(derived2);
          }
        }
        if (is_disconnected) {
          derived2.f ^= DISCONNECTED;
        }
        if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
          derived2.f ^= UNOWNED;
        }
      }
      for (i = 0; i < length; i++) {
        dependency = dependencies[i];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if (!is_unowned || active_effect !== null && !skip_reaction) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources?.includes(signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var _a;
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  skip_reaction = (flags2 & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      (flags2 & DERIVED) !== 0 && /** @type {import('#client').Derived} */
      reaction.reactions !== null) {
        for (i = skipped_deps; i < deps.length; i++) {
          ((_a = deps[i]).reactions ?? (_a.reactions = [])).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (dev_fallback_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (dev_fallback_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
async function tick() {
  if (async_mode_flag) {
    return new Promise((f) => requestAnimationFrame(() => f()));
  }
  await Promise.resolve();
  flushSync();
}
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!skip_reaction || !new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ?? (active_reaction.deps = [])).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null && /** @type {Derived} */
  signal.effects === null) {
    var derived2 = (
      /** @type {Derived} */
      signal
    );
    var parent = derived2.parent;
    if (parent !== null && (parent.f & UNOWNED) === 0) {
      derived2.f ^= UNOWNED;
    }
  }
  if (dev_fallback_default) {
    if (current_async_effect) {
      var tracking = (current_async_effect.f & REACTION_IS_UPDATING) !== 0;
      var was_read = current_async_effect.deps?.includes(signal);
      if (!tracking && !untracking && !was_read) {
        await_reactivity_loss(
          /** @type {string} */
          signal.label
        );
        var trace2 = get_stack("TracedAt");
        if (trace2) console.warn(trace2);
      }
    }
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        trace2 = get_stack("TracedAt");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      derived2 = /** @type {Derived} */
      signal;
      var value = derived2.v;
      if ((derived2.f & CLEAN) === 0 && derived2.reactions !== null || depends_on_old_values(derived2)) {
        value = execute_derived(derived2);
      }
      old_values.set(derived2, value);
      return value;
    }
  } else if (is_derived) {
    derived2 = /** @type {Derived} */
    signal;
    if (batch_deriveds?.has(derived2)) {
      return batch_deriveds.get(derived2);
    }
    if (is_dirty(derived2)) {
      update_derived(derived2);
    }
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function depends_on_old_values(derived2) {
  if (derived2.v === UNINITIALIZED) return true;
  if (derived2.deps === null) return false;
  for (const dep of derived2.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function safe_get(signal) {
  return signal && get(signal);
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function exclude_from_object(obj, keys) {
  var result = {};
  for (var key2 in obj) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key2 in value) {
      const prop2 = value[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    if (value instanceof Date) {
      value.getTime();
    }
    for (let key2 in value) {
      try {
        deep_read(value[key2], visited);
      } catch (e) {
      }
    }
    const proto = get_prototype_of(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get3 = descriptors[key2].get;
        if (get3) {
          try {
            get3.call(value);
          } catch (e) {
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/internal/client/dom/elements/events.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function replay_events(dom) {
  if (!hydrating) return;
  dom.removeAttribute("onload");
  dom.removeAttribute("onerror");
  const event2 = dom.__e;
  if (event2 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event2);
      }
    });
  }
}
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler?.call(this, event2);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function event(event_name, dom, handler, capture2, passive2) {
  var options = { capture: capture2, passive: passive2 };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
var last_propagated_event = null;
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = event2.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event2, ...data]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function apply(thunk, element2, args, component2, loc, has_side_effects = false, remove_parens = false) {
  let handler;
  let error;
  try {
    handler = thunk();
  } catch (e) {
    error = e;
  }
  if (typeof handler !== "function" && (has_side_effects || handler != null || error)) {
    const filename = component2?.[FILENAME];
    const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
    const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
    const event_name = args[0]?.type + phase;
    const description = `\`${event_name}\` handler${location}`;
    const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
    event_handler_invalid(description, suggestion);
    if (error) {
      throw error;
    }
  }
  handler?.apply(element2, args);
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
var head_anchor;
function reset_head_anchor() {
  head_anchor = void 0;
}
function head(render_fn) {
  let previous_hydrate_node = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_node = hydrate_node;
    if (head_anchor === void 0) {
      head_anchor = /** @type {TemplateNode} */
      get_first_child(document.head);
    }
    while (head_anchor !== null && (head_anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    head_anchor.data !== HYDRATION_START)) {
      head_anchor = /** @type {TemplateNode} */
      get_next_sibling(head_anchor);
    }
    if (head_anchor === null) {
      set_hydrating(false);
    } else {
      head_anchor = set_hydrate_node(
        /** @type {TemplateNode} */
        get_next_sibling(head_anchor)
      );
    }
  }
  if (!hydrating) {
    anchor = document.head.appendChild(create_text());
  }
  try {
    block(() => render_fn(anchor), HEAD_EFFECT);
  } finally {
    if (was_hydrating) {
      set_hydrating(true);
      head_anchor = hydrate_node;
      set_hydrate_node(
        /** @type {TemplateNode} */
        previous_hydrate_node
      );
    }
  }
}

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2.replaceAll("<!>", "<!---->");
  return elem.content;
}

// node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start;
    effect2.nodes_end = end;
  }
}
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content);
      if (!is_fragment) node = /** @type {Node} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags2, ns = "svg") {
  var has_start = !content.startsWith("<!>");
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped)
      );
      var root = (
        /** @type {Element} */
        get_first_child(fragment)
      );
      if (is_fragment) {
        node = document.createDocumentFragment();
        while (get_first_child(root)) {
          node.appendChild(
            /** @type {Node} */
            get_first_child(root)
          );
        }
      } else {
        node = /** @type {Element} */
        get_first_child(root);
      }
    }
    var clone2 = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "svg");
}
// @__NO_SIDE_EFFECTS__
function from_mathml(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "math");
}
function fragment_from_tree(structure, ns) {
  var fragment = create_fragment();
  for (var item of structure) {
    if (typeof item === "string") {
      fragment.append(create_text(item));
      continue;
    }
    if (item === void 0 || item[0][0] === "/") {
      fragment.append(create_comment(item ? item[0].slice(3) : ""));
      continue;
    }
    const [name, attributes, ...children] = item;
    const namespace = name === "svg" ? NAMESPACE_SVG : name === "math" ? NAMESPACE_MATHML : ns;
    var element2 = create_element(name, namespace, attributes?.is);
    for (var key2 in attributes) {
      set_attribute(element2, key2, attributes[key2]);
    }
    if (children.length > 0) {
      var target = element2.tagName === "TEMPLATE" ? (
        /** @type {HTMLTemplateElement} */
        element2.content
      ) : element2;
      target.append(
        fragment_from_tree(children, element2.tagName === "foreignObject" ? void 0 : namespace)
      );
    }
    fragment.append(element2);
  }
  return fragment;
}
// @__NO_SIDE_EFFECTS__
function from_tree(structure, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      const ns = (flags2 & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags2 & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : void 0;
      node = fragment_from_tree(structure, ns);
      if (!is_fragment) node = /** @type {Node} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
function with_script(fn) {
  return () => run_scripts(fn());
}
function run_scripts(node) {
  if (hydrating) return node;
  const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;
  const scripts = (
    /** @type {HTMLElement} */
    node.tagName === "SCRIPT" ? [
      /** @type {HTMLScriptElement} */
      node
    ] : node.querySelectorAll("script")
  );
  const effect2 = (
    /** @type {Effect} */
    active_effect
  );
  for (const script of scripts) {
    const clone2 = document.createElement("script");
    for (var attribute of script.attributes) {
      clone2.setAttribute(attribute.name, attribute.value);
    }
    clone2.textContent = script.textContent;
    if (is_fragment ? node.firstChild === script : node === script) {
      effect2.nodes_start = clone2;
    }
    if (is_fragment ? node.lastChild === script : node === script) {
      effect2.nodes_end = clone2;
    }
    script.replaceWith(clone2);
  }
  return node;
}
function text(value = "") {
  if (!hydrating) {
    var t = create_text(value + "");
    assign_nodes(t, t);
    return t;
  }
  var node = hydrate_node;
  if (node.nodeType !== TEXT_NODE) {
    node.before(node = create_text());
    set_hydrate_node(node);
  }
  assign_nodes(node, node);
  return node;
}
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start = document.createComment("");
  var anchor = create_text();
  frag.append(start, anchor);
  assign_nodes(start, anchor);
  return frag;
}
function append(anchor, dom) {
  if (hydrating) {
    active_effect.nodes_end = hydrate_node;
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
function props_id() {
  var _a;
  if (hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`#`)) {
    const id = hydrate_node.textContent.substring(1);
    hydrate_next();
    return id;
  }
  (_a = window.__svelte ?? (window.__svelte = {})).uid ?? (_a.uid = 1);
  return `c${window.__svelte.uid++}`;
}

// node_modules/svelte/src/utils.js
var regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}
var VOID_ELEMENT_NAMES = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
var DELEGATED_EVENTS = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function is_delegated(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
var DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
var ATTRIBUTE_ALIASES = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
var DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
var STATE_CREATION_RUNES = (
  /** @type {const} */
  [
    "$state",
    "$state.raw",
    "$derived",
    "$derived.by"
  ]
);
var RUNES = (
  /** @type {const} */
  [
    ...STATE_CREATION_RUNES,
    "$state.snapshot",
    "$props",
    "$props.id",
    "$bindable",
    "$effect",
    "$effect.pre",
    "$effect.tracking",
    "$effect.root",
    "$effect.pending",
    "$inspect",
    "$inspect().with",
    "$inspect.trace",
    "$host"
  ]
);
var RAW_TEXT_ELEMENTS = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}
function sanitize_location(location) {
  return (
    /** @type {T} */
    location?.replace(/\//g, "/\u200B")
  );
}

// node_modules/svelte/src/internal/client/render.js
var should_intro = true;
function set_should_intro(value) {
  should_intro = value;
}
function set_text(text2, value) {
  var str = value == null ? "" : typeof value === "object" ? value + "" : value;
  if (str !== (text2.__t ?? (text2.__t = text2.nodeValue))) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  init_operations();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    hydrate_next();
    const instance = _mount(component2, { ...options, anchor });
    if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
    hydrate_node.data !== HYDRATION_END) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
    reset_head_anchor();
  }
}
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i = 0; i < events2.length; i++) {
      var event_name = events2[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n = document_listeners.get(event_name);
      if (n === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    branch(() => {
      if (context) {
        push({});
        var ctx = (
          /** @type {ComponentContext} */
          component_context
        );
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      if (hydrating) {
        assign_nodes(
          /** @type {TemplateNode} */
          anchor_node,
          null
        );
      }
      should_intro = intro;
      component2 = Component(anchor_node, props) || {};
      should_intro = true;
      if (hydrating) {
        active_effect.nodes_end = hydrate_node;
      }
      if (context) {
        pop();
      }
    });
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) {
    lifecycle_double_unmount();
  }
  return Promise.resolve();
}

// node_modules/svelte/src/internal/shared/validate.js
function validate_void_dynamic_element(tag_fn) {
  const tag2 = tag_fn();
  if (tag2 && is_void(tag2)) {
    dynamic_void_element_content(tag2);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag2 = tag_fn();
  const is_string = typeof tag2 === "string";
  if (tag2 && !is_string) {
    svelte_element_invalid_this_value();
  }
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    store_invalid_shape(name);
  }
}
function prevent_snippet_stringification(fn) {
  fn.toString = () => {
    snippet_without_render_tag();
    return "";
  };
  return fn;
}

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
function snippet(node, get_snippet, ...args) {
  var anchor = node;
  var snippet2 = noop;
  var snippet_effect;
  block(() => {
    if (snippet2 === (snippet2 = get_snippet())) return;
    if (snippet_effect) {
      destroy_effect(snippet_effect);
      snippet_effect = null;
    }
    if (dev_fallback_default && snippet2 == null) {
      invalid_snippet();
    }
    snippet_effect = branch(() => (
      /** @type {SnippetFn} */
      snippet2(anchor, ...args)
    ));
  }, EFFECT_TRANSPARENT);
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function wrap_snippet(component2, fn) {
  const snippet2 = (node, ...args) => {
    var previous_component_function = dev_current_component_function;
    set_dev_current_component_function(component2);
    try {
      return fn(node, ...args);
    } finally {
      set_dev_current_component_function(previous_component_function);
    }
  };
  prevent_snippet_stringification(snippet2);
  return snippet2;
}

// node_modules/svelte/src/index-client.js
if (dev_fallback_default) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: () => {
          if (value !== void 0) {
            return value;
          }
          rune_outside_svelte(rune);
        },
        set: (v) => {
          value = v;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}

// node_modules/svelte/src/attachments/index.js
function createAttachmentKey() {
  return Symbol(ATTACHMENT_KEY);
}

// node_modules/svelte/src/internal/client/dev/assign.js
function compare(a, b, property, location) {
  if (a !== b) {
    assignment_value_stale(
      property,
      /** @type {string} */
      sanitize_location(location)
    );
  }
  return a;
}
function assign(object, property, value, location) {
  return compare(
    object[property] = value,
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_and(object, property, value, location) {
  return compare(
    object[property] && (object[property] = value),
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_or(object, property, value, location) {
  return compare(
    object[property] || (object[property] = value),
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_nullish(object, property, value, location) {
  return compare(
    object[property] ?? (object[property] = value),
    untrack(() => object[property]),
    property,
    location
  );
}

// node_modules/svelte/src/internal/client/dev/css.js
var all_styles = /* @__PURE__ */ new Map();
function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}
function cleanup_styles(hash2) {
  var styles = all_styles.get(hash2);
  if (!styles) return;
  for (const style of styles) {
    style.remove();
  }
  all_styles.delete(hash2);
}

// node_modules/svelte/src/internal/client/dev/elements.js
function add_locations(fn, filename, locations) {
  return (...args) => {
    const dom = fn(...args);
    var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
    assign_locations(node, filename, locations);
    return dom;
  };
}
function assign_location(element2, filename, location) {
  element2.__svelte_meta = {
    parent: dev_stack,
    loc: { file: filename, line: location[0], column: location[1] }
  };
  if (location[2]) {
    assign_locations(element2.firstChild, filename, location[2]);
  }
}
function assign_locations(node, filename, locations) {
  var i = 0;
  var depth = 0;
  while (node && i < locations.length) {
    if (hydrating && node.nodeType === COMMENT_NODE) {
      var comment2 = (
        /** @type {Comment} */
        node
      );
      if (comment2.data === HYDRATION_START || comment2.data === HYDRATION_START_ELSE) depth += 1;
      else if (comment2.data[0] === HYDRATION_END) depth -= 1;
    }
    if (depth === 0 && node.nodeType === ELEMENT_NODE) {
      assign_location(
        /** @type {Element} */
        node,
        filename,
        locations[i++]
      );
    }
    node = node.nextSibling;
  }
}

// node_modules/svelte/src/internal/client/dev/hmr.js
function hmr(original, get_source) {
  function wrapper(anchor, props) {
    let instance = {};
    let effect2;
    let ran = false;
    block(() => {
      const source2 = get_source();
      const component2 = get(source2);
      if (effect2) {
        for (var k in instance) delete instance[k];
        destroy_effect(effect2);
      }
      effect2 = branch(() => {
        if (ran) set_should_intro(false);
        Object.defineProperties(
          instance,
          Object.getOwnPropertyDescriptors(
            // @ts-expect-error
            new.target ? new component2(anchor, props) : component2(anchor, props)
          )
        );
        if (ran) set_should_intro(true);
      });
    }, EFFECT_TRANSPARENT);
    ran = true;
    if (hydrating) {
      anchor = hydrate_node;
    }
    return instance;
  }
  wrapper[FILENAME] = original[FILENAME];
  wrapper[HMR] = {
    // When we accept an update, we set the original source to the new component
    original,
    // The `get_source` parameter reads `wrapper[HMR].source`, but in the `accept`
    // function we always replace it with `previous[HMR].source`, which in practice
    // means we only ever update the original
    source: source(original)
  };
  return wrapper;
}

// node_modules/svelte/src/internal/client/dev/ownership.js
function create_ownership_validator(props) {
  const component2 = component_context?.function;
  const parent = component_context?.p?.function;
  return {
    /**
     * @param {string} prop
     * @param {any[]} path
     * @param {any} result
     * @param {number} line
     * @param {number} column
     */
    mutation: (prop2, path, result, line, column) => {
      const name = path[0];
      if (is_bound_or_unset(props, name) || !parent) {
        return result;
      }
      let value = props;
      for (let i = 0; i < path.length - 1; i++) {
        value = value[path[i]];
        if (!value?.[STATE_SYMBOL]) {
          return result;
        }
      }
      const location = sanitize_location(`${component2[FILENAME]}:${line}:${column}`);
      ownership_invalid_mutation(name, location, prop2, parent[FILENAME]);
      return result;
    },
    /**
     * @param {any} key
     * @param {any} child_component
     * @param {() => any} value
     */
    binding: (key2, child_component, value) => {
      if (!is_bound_or_unset(props, key2) && parent && value()?.[STATE_SYMBOL]) {
        ownership_invalid_binding(
          component2[FILENAME],
          key2,
          child_component[FILENAME],
          parent[FILENAME]
        );
      }
    }
  };
}
function is_bound_or_unset(props, prop_name) {
  const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
  return !!get_descriptor(props, prop_name)?.set || is_entry_props && prop_name in props || !(prop_name in props);
}

// node_modules/svelte/src/internal/client/dev/legacy.js
function check_target(target) {
  if (target) {
    component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
  }
}
function legacy_api() {
  const component2 = component_context?.function;
  function error(method) {
    component_api_changed(method, component2[FILENAME]);
  }
  return {
    $destroy: () => error("$destroy()"),
    $on: () => error("$on(...)"),
    $set: () => error("$set(...)")
  };
}

// node_modules/svelte/src/internal/client/dev/inspect.js
function inspect(get_value, inspector = console.log) {
  validate_effect("$inspect");
  let initial = true;
  let error = (
    /** @type {any} */
    UNINITIALIZED
  );
  inspect_effect(() => {
    try {
      var value = get_value();
    } catch (e) {
      error = e;
      return;
    }
    var snap = snapshot(value, true, true);
    untrack(() => {
      inspector(initial ? "init" : "update", ...snap);
    });
    initial = false;
  });
  render_effect(() => {
    try {
      get_value();
    } catch {
    }
    if (error !== UNINITIALIZED) {
      console.error(error);
      error = UNINITIALIZED;
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/async.js
function async(node, expressions, fn) {
  var boundary2 = get_pending_boundary();
  boundary2.update_pending_count(1);
  flatten([], expressions, (values) => {
    try {
      for (const d of values) get(d);
      fn(node, ...values);
    } finally {
      boundary2.update_pending_count(-1);
    }
  });
}

// node_modules/svelte/src/internal/client/dev/validation.js
function validate_snippet_args(anchor, ...args) {
  if (typeof anchor !== "object" || !(anchor instanceof Node)) {
    invalid_snippet_arguments();
  }
  for (let arg of args) {
    if (typeof arg !== "function") {
      invalid_snippet_arguments();
    }
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/await.js
var PENDING = 0;
var THEN = 1;
var CATCH = 2;
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var anchor = node;
  var runes = is_runes();
  var active_component_context = component_context;
  var component_function = dev_fallback_default ? component_context?.function : null;
  var dev_original_stack = dev_fallback_default ? dev_stack : null;
  var input = UNINITIALIZED;
  var pending_effect;
  var then_effect;
  var catch_effect;
  var input_source = runes ? source(
    /** @type {V} */
    void 0
  ) : mutable_source(
    /** @type {V} */
    void 0,
    false,
    false
  );
  var error_source = runes ? source(void 0) : mutable_source(void 0, false, false);
  var resolved = false;
  function update2(state2, restore) {
    resolved = true;
    if (restore) {
      set_active_effect(effect2);
      set_active_reaction(effect2);
      set_component_context(active_component_context);
      if (dev_fallback_default) {
        set_dev_current_component_function(component_function);
        set_dev_stack(dev_original_stack);
      }
    }
    try {
      if (state2 === PENDING && pending_fn) {
        if (pending_effect) resume_effect(pending_effect);
        else pending_effect = branch(() => pending_fn(anchor));
      }
      if (state2 === THEN && then_fn) {
        if (then_effect) resume_effect(then_effect);
        else then_effect = branch(() => then_fn(anchor, input_source));
      }
      if (state2 === CATCH && catch_fn) {
        if (catch_effect) resume_effect(catch_effect);
        else catch_effect = branch(() => catch_fn(anchor, error_source));
      }
      if (state2 !== PENDING && pending_effect) {
        pause_effect(pending_effect, () => pending_effect = null);
      }
      if (state2 !== THEN && then_effect) {
        pause_effect(then_effect, () => then_effect = null);
      }
      if (state2 !== CATCH && catch_effect) {
        pause_effect(catch_effect, () => catch_effect = null);
      }
    } finally {
      if (restore) {
        if (dev_fallback_default) {
          set_dev_current_component_function(null);
          set_dev_stack(null);
        }
        set_component_context(null);
        set_active_reaction(null);
        set_active_effect(null);
        flushSync();
      }
    }
  }
  var effect2 = block(() => {
    if (input === (input = get_input())) return;
    let mismatch = hydrating && is_promise(input) === (anchor.data === HYDRATION_START_ELSE);
    if (mismatch) {
      anchor = remove_nodes();
      set_hydrate_node(anchor);
      set_hydrating(false);
      mismatch = true;
    }
    if (is_promise(input)) {
      var promise = input;
      resolved = false;
      promise.then(
        (value) => {
          if (promise !== input) return;
          internal_set(input_source, value);
          update2(THEN, true);
        },
        (error) => {
          if (promise !== input) return;
          internal_set(error_source, error);
          update2(CATCH, true);
          if (!catch_fn) {
            throw error_source.v;
          }
        }
      );
      if (hydrating) {
        if (pending_fn) {
          pending_effect = branch(() => pending_fn(anchor));
        }
      } else {
        queue_micro_task(() => {
          if (!resolved) update2(PENDING, true);
        });
      }
    } else {
      internal_set(input_source, input);
      update2(THEN, false);
    }
    if (mismatch) {
      set_hydrating(true);
    }
    return () => input = UNINITIALIZED;
  });
  if (hydrating) {
    anchor = hydrate_node;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(node, fn, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var anchor = node;
  var consequent_effect = null;
  var alternate_effect = null;
  var condition = UNINITIALIZED;
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  var has_branch = false;
  const set_branch = (fn2, flag = true) => {
    has_branch = true;
    update_branch(flag, fn2);
  };
  var offscreen_fragment = null;
  function commit() {
    if (offscreen_fragment !== null) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    var active = condition ? consequent_effect : alternate_effect;
    var inactive = condition ? alternate_effect : consequent_effect;
    if (active) {
      resume_effect(active);
    }
    if (inactive) {
      pause_effect(inactive, () => {
        if (condition) {
          alternate_effect = null;
        } else {
          consequent_effect = null;
        }
      });
    }
  }
  const update_branch = (new_condition, fn2) => {
    if (condition === (condition = new_condition)) return;
    let mismatch = false;
    if (hydrating) {
      const is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (!!condition === is_else) {
        anchor = remove_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var defer = should_defer_append();
    var target = anchor;
    if (defer) {
      offscreen_fragment = document.createDocumentFragment();
      offscreen_fragment.append(target = create_text());
    }
    if (condition) {
      consequent_effect ?? (consequent_effect = fn2 && branch(() => fn2(target)));
    } else {
      alternate_effect ?? (alternate_effect = fn2 && branch(() => fn2(target)));
    }
    if (defer) {
      var batch = (
        /** @type {Batch} */
        current_batch
      );
      var active = condition ? consequent_effect : alternate_effect;
      var inactive = condition ? alternate_effect : consequent_effect;
      if (active) batch.skipped_effects.delete(active);
      if (inactive) batch.skipped_effects.add(inactive);
      batch.add_callback(commit);
    } else {
      commit();
    }
    if (mismatch) {
      set_hydrating(true);
    }
  };
  block(() => {
    has_branch = false;
    fn(set_branch);
    if (!has_branch) {
      update_branch(null, null);
    }
  }, flags2);
  if (hydrating) {
    anchor = hydrate_node;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/key.js
function key(node, get_key, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var anchor = node;
  var key2 = UNINITIALIZED;
  var effect2;
  var pending_effect;
  var offscreen_fragment = null;
  var changed = is_runes() ? not_equal : safe_not_equal;
  function commit() {
    if (effect2) {
      pause_effect(effect2);
    }
    if (offscreen_fragment !== null) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    effect2 = pending_effect;
  }
  block(() => {
    if (changed(key2, key2 = get_key())) {
      var target = anchor;
      var defer = should_defer_append();
      if (defer) {
        offscreen_fragment = document.createDocumentFragment();
        offscreen_fragment.append(target = create_text());
      }
      pending_effect = branch(() => render_fn(target));
      if (defer) {
        current_batch.add_callback(commit);
      } else {
        commit();
      }
    }
  });
  if (hydrating) {
    anchor = hydrate_node;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
function css_props(element2, get_styles) {
  if (hydrating) {
    set_hydrate_node(
      /** @type {TemplateNode} */
      get_first_child(element2)
    );
  }
  render_effect(() => {
    var styles = get_styles();
    for (var key2 in styles) {
      var value = styles[key2];
      if (value) {
        element2.style.setProperty(key2, value);
      } else {
        element2.style.removeProperty(key2);
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/each.js
var current_each_item = null;
function set_current_each_item(item) {
  current_each_item = item;
}
function index(_, i) {
  return i;
}
function pause_effects(state2, items, controlled_anchor) {
  var items_map = state2.items;
  var transitions = [];
  var length = items.length;
  for (var i = 0; i < length; i++) {
    pause_children(items[i].e, transitions, true);
  }
  var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      /** @type {Element} */
      controlled_anchor.parentNode
    );
    clear_text_content(parent_node);
    parent_node.append(
      /** @type {Element} */
      controlled_anchor
    );
    items_map.clear();
    link(state2, items[0].prev, items[length - 1].next);
  }
  run_out_transitions(transitions, () => {
    for (var i2 = 0; i2 < length; i2++) {
      var item = items[i2];
      if (!is_controlled) {
        items_map.delete(item.k);
        link(state2, item.prev, item.next);
      }
      destroy_effect(item.e, !is_controlled);
    }
  });
}
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var state2 = { flags: flags2, items: /* @__PURE__ */ new Map(), first: null };
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(
      /** @type {Comment | Text} */
      get_first_child(parent_node)
    ) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback2 = null;
  var was_empty = false;
  var offscreen_items = /* @__PURE__ */ new Map();
  var each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array;
  var each_effect;
  function commit() {
    reconcile(
      each_effect,
      array,
      state2,
      offscreen_items,
      anchor,
      render_fn,
      flags2,
      get_key,
      get_collection
    );
    if (fallback_fn !== null) {
      if (array.length === 0) {
        if (fallback2) {
          resume_effect(fallback2);
        } else {
          fallback2 = branch(() => fallback_fn(anchor));
        }
      } else if (fallback2 !== null) {
        pause_effect(fallback2, () => {
          fallback2 = null;
        });
      }
    }
  }
  block(() => {
    each_effect ?? (each_effect = /** @type {Effect} */
    active_effect);
    array = /** @type {V[]} */
    get(each_array);
    var length = array.length;
    if (was_empty && length === 0) {
      return;
    }
    was_empty = length === 0;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length === 0)) {
        anchor = remove_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    if (hydrating) {
      var prev = null;
      var item;
      for (var i = 0; i < length; i++) {
        if (hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
        hydrate_node.data === HYDRATION_END) {
          anchor = /** @type {Comment} */
          hydrate_node;
          mismatch = true;
          set_hydrating(false);
          break;
        }
        var value = array[i];
        var key2 = get_key(value, i);
        item = create_item(
          hydrate_node,
          state2,
          prev,
          null,
          value,
          key2,
          i,
          render_fn,
          flags2,
          get_collection
        );
        state2.items.set(key2, item);
        prev = item;
      }
      if (length > 0) {
        set_hydrate_node(remove_nodes());
      }
    }
    if (hydrating) {
      if (length === 0 && fallback_fn) {
        fallback2 = branch(() => fallback_fn(anchor));
      }
    } else {
      if (should_defer_append()) {
        var keys = /* @__PURE__ */ new Set();
        var batch = (
          /** @type {Batch} */
          current_batch
        );
        for (i = 0; i < length; i += 1) {
          value = array[i];
          key2 = get_key(value, i);
          var existing = state2.items.get(key2) ?? offscreen_items.get(key2);
          if (existing) {
            if ((flags2 & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {
              update_item(existing, value, i, flags2);
            }
          } else {
            item = create_item(
              null,
              state2,
              null,
              null,
              value,
              key2,
              i,
              render_fn,
              flags2,
              get_collection,
              true
            );
            offscreen_items.set(key2, item);
          }
          keys.add(key2);
        }
        for (const [key3, item2] of state2.items) {
          if (!keys.has(key3)) {
            batch.skipped_effects.add(item2.e);
          }
        }
        batch.add_callback(commit);
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get(each_array);
  });
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function reconcile(each_effect, array, state2, offscreen_items, anchor, render_fn, flags2, get_key, get_collection) {
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var should_update = (flags2 & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
  var length = array.length;
  var items = state2.items;
  var first = state2.first;
  var current = first;
  var seen;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key2;
  var item;
  var i;
  if (is_animated) {
    for (i = 0; i < length; i += 1) {
      value = array[i];
      key2 = get_key(value, i);
      item = items.get(key2);
      if (item !== void 0) {
        item.a?.measure();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).add(item);
      }
    }
  }
  for (i = 0; i < length; i += 1) {
    value = array[i];
    key2 = get_key(value, i);
    item = items.get(key2);
    if (item === void 0) {
      var pending3 = offscreen_items.get(key2);
      if (pending3 !== void 0) {
        offscreen_items.delete(key2);
        items.set(key2, pending3);
        var next2 = prev ? prev.next : current;
        link(state2, prev, pending3);
        link(state2, pending3, next2);
        move(pending3, next2, anchor);
        prev = pending3;
      } else {
        var child_anchor = current ? (
          /** @type {TemplateNode} */
          current.e.nodes_start
        ) : anchor;
        prev = create_item(
          child_anchor,
          state2,
          prev,
          prev === null ? state2.first : prev.next,
          value,
          key2,
          i,
          render_fn,
          flags2,
          get_collection
        );
      }
      items.set(key2, prev);
      matched = [];
      stashed = [];
      current = prev.next;
      continue;
    }
    if (should_update) {
      update_item(item, value, i, flags2);
    }
    if ((item.e.f & INERT) !== 0) {
      resume_effect(item.e);
      if (is_animated) {
        item.a?.unfix();
        (to_animate ?? (to_animate = /* @__PURE__ */ new Set())).delete(item);
      }
    }
    if (item !== current) {
      if (seen !== void 0 && seen.has(item)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen.delete(stashed[j]);
          }
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(item);
          move(item, current, anchor);
          link(state2, item.prev, item.next);
          link(state2, item, prev === null ? state2.first : prev.next);
          link(state2, prev, item);
          prev = item;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current.k !== key2) {
        if ((current.e.f & INERT) === 0) {
          (seen ?? (seen = /* @__PURE__ */ new Set())).add(current);
        }
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
      item = current;
    }
    matched.push(item);
    prev = item;
    current = item.next;
  }
  if (current !== null || seen !== void 0) {
    var to_destroy = seen === void 0 ? [] : array_from(seen);
    while (current !== null) {
      if ((current.e.f & INERT) === 0) {
        to_destroy.push(current);
      }
      current = current.next;
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].a?.measure();
        }
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].a?.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      if (to_animate === void 0) return;
      for (item of to_animate) {
        item.a?.apply();
      }
    });
  }
  each_effect.first = state2.first && state2.first.e;
  each_effect.last = prev && prev.e;
  for (var unused of offscreen_items.values()) {
    destroy_effect(unused.e);
  }
  offscreen_items.clear();
}
function update_item(item, value, index2, type) {
  if ((type & EACH_ITEM_REACTIVE) !== 0) {
    internal_set(item.v, value);
  }
  if ((type & EACH_INDEX_REACTIVE) !== 0) {
    internal_set(
      /** @type {Value<number>} */
      item.i,
      index2
    );
  } else {
    item.i = index2;
  }
}
function create_item(anchor, state2, prev, next2, value, key2, index2, render_fn, flags2, get_collection, deferred2) {
  var previous_each_item = current_each_item;
  var reactive = (flags2 & EACH_ITEM_REACTIVE) !== 0;
  var mutable = (flags2 & EACH_ITEM_IMMUTABLE) === 0;
  var v = reactive ? mutable ? mutable_source(value, false, false) : source(value) : value;
  var i = (flags2 & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
  if (dev_fallback_default && reactive) {
    v.trace = () => {
      var collection_index = typeof i === "number" ? index2 : i.v;
      get_collection()[collection_index];
    };
  }
  var item = {
    i,
    v,
    k: key2,
    a: null,
    // @ts-expect-error
    e: null,
    prev,
    next: next2
  };
  current_each_item = item;
  try {
    if (anchor === null) {
      var fragment = document.createDocumentFragment();
      fragment.append(anchor = create_text());
    }
    item.e = branch(() => render_fn(
      /** @type {Node} */
      anchor,
      v,
      i,
      get_collection
    ), hydrating);
    item.e.prev = prev && prev.e;
    item.e.next = next2 && next2.e;
    if (prev === null) {
      if (!deferred2) {
        state2.first = item;
      }
    } else {
      prev.next = item;
      prev.e.next = item.e;
    }
    if (next2 !== null) {
      next2.prev = item;
      next2.e.prev = item.e;
    }
    return item;
  } finally {
    current_each_item = previous_each_item;
  }
}
function move(item, next2, anchor) {
  var end = item.next ? (
    /** @type {TemplateNode} */
    item.next.e.nodes_start
  ) : anchor;
  var dest = next2 ? (
    /** @type {TemplateNode} */
    next2.e.nodes_start
  ) : anchor;
  var node = (
    /** @type {TemplateNode} */
    item.e.nodes_start
  );
  while (node !== null && node !== end) {
    var next_node = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    dest.before(node);
    node = next_node;
  }
}
function link(state2, prev, next2) {
  if (prev === null) {
    state2.first = next2;
  } else {
    prev.next = next2;
    prev.e.next = next2 && next2.e;
  }
  if (next2 !== null) {
    next2.prev = prev;
    next2.e.prev = prev && prev.e;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/html.js
function check_hash(element2, server_hash, value) {
  if (!server_hash || server_hash === hash(String(value ?? ""))) return;
  let location;
  const loc = element2.__svelte_meta?.loc;
  if (loc) {
    location = `near ${loc.file}:${loc.line}:${loc.column}`;
  } else if (dev_current_component_function?.[FILENAME]) {
    location = `in ${dev_current_component_function[FILENAME]}`;
  }
  hydration_html_changed(sanitize_location(location));
}
function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node;
  var value = "";
  template_effect(() => {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (value === (value = get_value() ?? "")) {
      if (hydrating) hydrate_next();
      return;
    }
    if (effect2.nodes_start !== null) {
      remove_effect_dom(
        effect2.nodes_start,
        /** @type {TemplateNode} */
        effect2.nodes_end
      );
      effect2.nodes_start = effect2.nodes_end = null;
    }
    if (value === "") return;
    if (hydrating) {
      var hash2 = (
        /** @type {Comment} */
        hydrate_node.data
      );
      var next2 = hydrate_next();
      var last = next2;
      while (next2 !== null && (next2.nodeType !== COMMENT_NODE || /** @type {Comment} */
      next2.data !== "")) {
        last = next2;
        next2 = /** @type {TemplateNode} */
        get_next_sibling(next2);
      }
      if (next2 === null) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      if (dev_fallback_default && !skip_warning) {
        check_hash(
          /** @type {Element} */
          next2.parentNode,
          hash2,
          value
        );
      }
      assign_nodes(hydrate_node, last);
      anchor = set_hydrate_node(next2);
      return;
    }
    var html2 = value + "";
    if (svg) html2 = `<svg>${html2}</svg>`;
    else if (mathml) html2 = `<math>${html2}</math>`;
    var node2 = create_fragment_from_html(html2);
    if (svg || mathml) {
      node2 = /** @type {Element} */
      get_first_child(node2);
    }
    assign_nodes(
      /** @type {TemplateNode} */
      get_first_child(node2),
      /** @type {TemplateNode} */
      node2.lastChild
    );
    if (svg || mathml) {
      while (get_first_child(node2)) {
        anchor.before(
          /** @type {Node} */
          get_first_child(node2)
        );
      }
    } else {
      anchor.before(node2);
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/slot.js
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var slot_fn = $$props.$$slots?.[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
    is_interop = true;
  }
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}
function sanitize_slots(props) {
  const sanitized = {};
  if (props.children) sanitized.default = true;
  for (const key2 in props.$$slots) {
    sanitized[key2] = true;
  }
  return sanitized;
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
function component(node, get_component, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var anchor = node;
  var component2;
  var effect2;
  var offscreen_fragment = null;
  var pending_effect = null;
  function commit() {
    if (effect2) {
      pause_effect(effect2);
      effect2 = null;
    }
    if (offscreen_fragment) {
      offscreen_fragment.lastChild.remove();
      anchor.before(offscreen_fragment);
      offscreen_fragment = null;
    }
    effect2 = pending_effect;
    pending_effect = null;
  }
  block(() => {
    if (component2 === (component2 = get_component())) return;
    var defer = should_defer_append();
    if (component2) {
      var target = anchor;
      if (defer) {
        offscreen_fragment = document.createDocumentFragment();
        offscreen_fragment.append(target = create_text());
        if (effect2) {
          current_batch.skipped_effects.add(effect2);
        }
      }
      pending_effect = branch(() => render_fn(target, component2));
    }
    if (defer) {
      current_batch.add_callback(commit);
    } else {
      commit();
    }
  }, EFFECT_TRANSPARENT);
  if (hydrating) {
    anchor = hydrate_node;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
function element(node, get_tag, is_svg, render_fn, get_namespace, location) {
  let was_hydrating = hydrating;
  if (hydrating) {
    hydrate_next();
  }
  var filename = dev_fallback_default && location && component_context?.function[FILENAME];
  var tag2;
  var current_tag;
  var element2 = null;
  if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
    element2 = /** @type {Element} */
    hydrate_node;
    hydrate_next();
  }
  var anchor = (
    /** @type {TemplateNode} */
    hydrating ? hydrate_node : node
  );
  var effect2;
  var each_item_block = current_each_item;
  block(() => {
    const next_tag = get_tag() || null;
    var ns = get_namespace ? get_namespace() : is_svg || next_tag === "svg" ? NAMESPACE_SVG : null;
    if (next_tag === tag2) return;
    var previous_each_item = current_each_item;
    set_current_each_item(each_item_block);
    if (effect2) {
      if (next_tag === null) {
        pause_effect(effect2, () => {
          effect2 = null;
          current_tag = null;
        });
      } else if (next_tag === current_tag) {
        resume_effect(effect2);
      } else {
        destroy_effect(effect2);
        set_should_intro(false);
      }
    }
    if (next_tag && next_tag !== current_tag) {
      effect2 = branch(() => {
        element2 = hydrating ? (
          /** @type {Element} */
          element2
        ) : ns ? document.createElementNS(ns, next_tag) : document.createElement(next_tag);
        if (dev_fallback_default && location) {
          element2.__svelte_meta = {
            parent: dev_stack,
            loc: {
              file: filename,
              line: location[0],
              column: location[1]
            }
          };
        }
        assign_nodes(element2, element2);
        if (render_fn) {
          if (hydrating && is_raw_text_element(next_tag)) {
            element2.append(document.createComment(""));
          }
          var child_anchor = (
            /** @type {TemplateNode} */
            hydrating ? get_first_child(element2) : element2.appendChild(create_text())
          );
          if (hydrating) {
            if (child_anchor === null) {
              set_hydrating(false);
            } else {
              set_hydrate_node(child_anchor);
            }
          }
          render_fn(element2, child_anchor);
        }
        active_effect.nodes_end = element2;
        anchor.before(element2);
      });
    }
    tag2 = next_tag;
    if (tag2) current_tag = tag2;
    set_should_intro(true);
    set_current_each_item(previous_each_item);
  }, EFFECT_TRANSPARENT);
  if (was_hydrating) {
    set_hydrating(true);
    set_hydrate_node(anchor);
  }
}

// node_modules/svelte/src/internal/client/dom/css.js
function append_styles(anchor, css) {
  effect(() => {
    var root = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root.host ? (
        /** @type {ShadowRoot} */
        root
      ) : (
        /** @type {Document} */
        root.head ?? /** @type {Document} */
        root.ownerDocument.head
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = document.createElement("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (dev_fallback_default) {
        register_style(css.hash, style);
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/actions.js
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value?.()) || {});
    if (get_value && payload?.update) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited && safe_not_equal(prev, value)) {
          prev = value;
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload?.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/attachments.js
function attach(node, get_fn) {
  var fn = void 0;
  var e;
  block(() => {
    if (fn !== (fn = get_fn())) {
      if (e) {
        destroy_effect(e);
        e = null;
      }
      if (fn) {
        e = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn(node)
          ));
        });
      }
    }
  });
}

// node_modules/svelte/src/escaping.js
var ATTR_REGEX = /[&"<]/g;
var CONTENT_REGEX = /[&<]/g;
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped = "";
  let last = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped + str.substring(last);
}

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}

// node_modules/svelte/src/internal/shared/attributes.js
var replacements = {
  translate: /* @__PURE__ */ new Map([
    [true, "yes"],
    [false, "no"]
  ])
};
function attr(name, value, is_boolean = false) {
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
function clsx2(value) {
  if (typeof value === "object") {
    return clsx(value);
  } else {
    return value ?? "";
  }
}
var whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles2(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c = value[i];
        if (in_comment) {
          if (c === "/" && value[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c) {
            in_str = false;
          }
        } else if (c === "/" && value[i + 1] === "*") {
          in_comment = true;
        } else if (c === '"' || c === "'") {
          in_str = c;
        } else if (c === "(") {
          in_apo++;
        } else if (c === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c === ":" && name_index === -1) {
            name_index = i;
          } else if (c === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c !== ";") {
                  i++;
                }
                var property = value.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles2(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles2(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}

// node_modules/svelte/src/internal/client/dom/elements/class.js
function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value || prev === void 0) {
    var next_class_name = to_class(value, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}

// node_modules/svelte/src/internal/client/dom/elements/style.js
function update_styles(dom, prev = {}, next2, priority) {
  for (var key2 in next2) {
    var value = next2[key2];
    if (prev[key2] !== value) {
      if (next2[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value, priority);
      }
    }
  }
}
function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles?.[0], next_styles[0]);
      update_styles(dom, prev_styles?.[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
function bind_select_value(select, get3, set2 = get3) {
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", (is_reset) => {
    var query = is_reset ? "[selected]" : ":checked";
    var value;
    if (select.multiple) {
      value = [].map.call(select.querySelectorAll(query), get_option_value);
    } else {
      var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
      select.querySelector("option:not([disabled])");
      value = selected_option && get_option_value(selected_option);
    }
    set2(value);
  });
  effect(() => {
    var value = get3();
    select_option(select, value, mounting);
    if (mounting && value === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value = get_option_value(selected_option);
        set2(value);
      }
    }
    select.__value = value;
    mounting = false;
  });
  init_select(select);
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
var CLASS = Symbol("class");
var STYLE = Symbol("style");
var IS_CUSTOM_ELEMENT = Symbol("is custom element");
var IS_HTML = Symbol("is html");
function remove_input_defaults(input) {
  if (!hydrating) return;
  var already_removed = false;
  var remove_defaults = () => {
    if (already_removed) return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value = input.value;
      set_attribute2(input, "value", null);
      input.value = value;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute2(input, "checked", null);
      input.checked = checked;
    }
  };
  input.__on_r = remove_defaults;
  queue_idle_task(remove_defaults);
  add_form_reset_listener();
}
function set_value(element2, value) {
  var attributes = get_attributes(element2);
  if (attributes.value === (attributes.value = // treat null and undefined the same for the initial value
  value ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  element2.value === value && (value !== 0 || element2.nodeName !== "PROGRESS")) {
    return;
  }
  element2.value = value ?? "";
}
function set_checked(element2, checked) {
  var attributes = get_attributes(element2);
  if (attributes.checked === (attributes.checked = // treat null and undefined the same for the initial value
  checked ?? void 0)) {
    return;
  }
  element2.checked = checked;
}
function set_selected(element2, selected) {
  if (selected) {
    if (!element2.hasAttribute("selected")) {
      element2.setAttribute("selected", "");
    }
  } else {
    element2.removeAttribute("selected");
  }
}
function set_default_checked(element2, checked) {
  const existing_value = element2.checked;
  element2.defaultChecked = checked;
  element2.checked = existing_value;
}
function set_default_value(element2, value) {
  const existing_value = element2.value;
  element2.defaultValue = value;
  element2.value = existing_value;
}
function set_attribute2(element2, attribute, value, skip_warning) {
  var attributes = get_attributes(element2);
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === "LINK") {
      if (!skip_warning) {
        check_src_in_dev_hydration(element2, attribute, value ?? "");
      }
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value)) return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element2.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
    element2[attribute] = value;
  } else {
    element2.setAttribute(attribute, value);
  }
}
function set_xlink_attribute(dom, attribute, value) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
}
function set_custom_element_data(node, prop2, value) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  let was_hydrating = hydrating;
  if (hydrating) {
    set_hydrating(false);
  }
  set_active_reaction(null);
  set_active_effect(null);
  try {
    if (
      // `style` should use `set_attribute` rather than the setter
      prop2 !== "style" && // Don't compute setters for custom elements while they aren't registered yet,
      // because during their upgrade/instantiation they might add more setters.
      // Instead, fall back to a simple "an object, then set as property" heuristic.
      (setters_cache.has(node.getAttribute("is") || node.nodeName) || // customElements may not be available in browser extension contexts
      !customElements || customElements.get(node.getAttribute("is") || node.tagName.toLowerCase()) ? get_setters(node).includes(prop2) : value && typeof value === "object")
    ) {
      node[prop2] = value;
    } else {
      set_attribute2(node, prop2, value == null ? value : String(value));
    }
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
    if (was_hydrating) {
      set_hydrating(true);
    }
  }
}
function set_attributes(element2, prev, next2, css_hash, skip_warning = false) {
  var attributes = get_attributes(element2);
  var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes[IS_HTML];
  let is_hydrating_custom_element = hydrating && is_custom_element;
  if (is_hydrating_custom_element) {
    set_hydrating(false);
  }
  var current = prev || {};
  var is_option_element = element2.tagName === "OPTION";
  for (var key2 in prev) {
    if (!(key2 in next2)) {
      next2[key2] = null;
    }
  }
  if (next2.class) {
    next2.class = clsx2(next2.class);
  } else if (css_hash || next2[CLASS]) {
    next2.class = null;
  }
  if (next2[STYLE]) {
    next2.style ?? (next2.style = null);
  }
  var setters = get_setters(element2);
  for (const key3 in next2) {
    let value = next2[key3];
    if (is_option_element && key3 === "value" && value == null) {
      element2.value = element2.__value = "";
      current[key3] = value;
      continue;
    }
    if (key3 === "class") {
      var is_html = element2.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element2, is_html, value, css_hash, prev?.[CLASS], next2[CLASS]);
      current[key3] = value;
      current[CLASS] = next2[CLASS];
      continue;
    }
    if (key3 === "style") {
      set_style(element2, value, prev?.[STYLE], next2[STYLE]);
      current[key3] = value;
      current[STYLE] = next2[STYLE];
      continue;
    }
    var prev_value = current[key3];
    if (value === prev_value && !(value === void 0 && element2.hasAttribute(key3))) {
      continue;
    }
    current[key3] = value;
    var prefix = key3[0] + key3[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key3;
      let event_name = key3.slice(2);
      var delegated = is_delegated(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!delegated && prev_value) {
        if (value != null) continue;
        element2.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (value != null) {
        if (!delegated) {
          let handle = function(evt) {
            current[key3].call(this, evt);
          };
          current[event_handle_key] = create_event(event_name, element2, handle, opts);
        } else {
          element2[`__${event_name}`] = value;
          delegate([event_name]);
        }
      } else if (delegated) {
        element2[`__${event_name}`] = void 0;
      }
    } else if (key3 === "style") {
      set_attribute2(element2, key3, value);
    } else if (key3 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element2,
        Boolean(value)
      );
    } else if (!is_custom_element && (key3 === "__value" || key3 === "value" && value != null)) {
      element2.value = element2.__value = value;
    } else if (key3 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element2,
        value
      );
    } else {
      var name = key3;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value == null && !is_custom_element && !is_default) {
        attributes[key3] = null;
        if (name === "value" || name === "checked") {
          let input = (
            /** @type {HTMLInputElement} */
            element2
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input.defaultValue;
            input.removeAttribute(name);
            input.defaultValue = previous;
            input.value = input.__value = use_default ? previous : null;
          } else {
            let previous = input.defaultChecked;
            input.removeAttribute(name);
            input.defaultChecked = previous;
            input.checked = use_default ? previous : false;
          }
        } else {
          element2.removeAttribute(key3);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value !== "string")) {
        element2[name] = value;
        if (name in attributes) attributes[name] = UNINITIALIZED;
      } else if (typeof value !== "function") {
        set_attribute2(element2, name, value, skip_warning);
      }
    }
  }
  if (is_hydrating_custom_element) {
    set_hydrating(true);
  }
  return current;
}
function attribute_effect(element2, fn, sync = [], async2 = [], css_hash, skip_warning = false) {
  flatten(sync, async2, (values) => {
    var prev = void 0;
    var effects = {};
    var is_select = element2.nodeName === "SELECT";
    var inited = false;
    block(() => {
      var next2 = fn(...values.map(get));
      var current = set_attributes(element2, prev, next2, css_hash, skip_warning);
      if (inited && is_select && "value" in next2) {
        select_option(
          /** @type {HTMLSelectElement} */
          element2,
          next2.value
        );
      }
      for (let symbol of Object.getOwnPropertySymbols(effects)) {
        if (!next2[symbol]) destroy_effect(effects[symbol]);
      }
      for (let symbol of Object.getOwnPropertySymbols(next2)) {
        var n = next2[symbol];
        if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
          if (effects[symbol]) destroy_effect(effects[symbol]);
          effects[symbol] = branch(() => attach(element2, () => n));
        }
        current[symbol] = n;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element2
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select(select);
      });
    }
    inited = true;
  });
}
function get_attributes(element2) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    element2.__attributes ?? (element2.__attributes = {
      [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
      [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
    })
  );
}
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  var cache_key = element2.getAttribute("is") || element2.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element2;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element2, attribute, value) {
  if (!dev_fallback_default) return;
  if (attribute === "srcset" && srcset_url_equal(element2, value)) return;
  if (src_url_equal(element2.getAttribute(attribute) ?? "", value)) return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url) return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}

// node_modules/svelte/src/internal/client/timing.js
var now = true_default ? () => performance.now() : () => Date.now();
var raf = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (_) => (true_default ? requestAnimationFrame : noop)(_)
  ),
  now: () => now(),
  tasks: /* @__PURE__ */ new Set()
};

// node_modules/svelte/src/internal/client/loop.js
function run_tasks() {
  const now2 = raf.now();
  raf.tasks.forEach((task) => {
    if (!task.c(now2)) {
      raf.tasks.delete(task);
      task.f();
    }
  });
  if (raf.tasks.size !== 0) {
    raf.tick(run_tasks);
  }
}
function loop(callback) {
  let task;
  if (raf.tasks.size === 0) {
    raf.tick(run_tasks);
  }
  return {
    promise: new Promise((fulfill) => {
      raf.tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      raf.tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
function dispatch_event(element2, type) {
  without_reactive_context(() => {
    element2.dispatchEvent(new CustomEvent(type));
  });
}
function css_property_to_camelcase(style) {
  if (style === "float") return "cssFloat";
  if (style === "offset") return "cssOffset";
  if (style.startsWith("--")) return style;
  const parts = style.split("-");
  if (parts.length === 1) return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0) break;
    const formatted_property = css_property_to_camelcase(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
var linear = (t) => t;
function animation(element2, get_fn, get_params) {
  var item = (
    /** @type {EachItem} */
    current_each_item
  );
  var from;
  var to;
  var animation2;
  var original_styles = null;
  item.a ?? (item.a = {
    element: element2,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation2?.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options = get_fn()(this.element, { from, to }, get_params?.());
        animation2 = animate(this.element, options, void 0, 1, () => {
          animation2?.abort();
          animation2 = void 0;
        });
      }
    },
    fix() {
      if (element2.getAnimations().length) return;
      var { position, width, height } = getComputedStyle(element2);
      if (position !== "absolute" && position !== "fixed") {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        original_styles = {
          position: style.position,
          width: style.width,
          height: style.height,
          transform: style.transform
        };
        style.position = "absolute";
        style.width = width;
        style.height = height;
        var to2 = element2.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style.transform = style.transform ? `${style.transform} ${transform}` : transform;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        style.position = original_styles.position;
        style.width = original_styles.width;
        style.height = original_styles.height;
        style.transform = original_styles.transform;
      }
    }
  });
  item.a.element = element2;
}
function transition(flags2, element2, get_fn, get_params) {
  var is_intro = (flags2 & TRANSITION_IN) !== 0;
  var is_outro = (flags2 & TRANSITION_OUT) !== 0;
  var is_both = is_intro && is_outro;
  var is_global = (flags2 & TRANSITION_GLOBAL) !== 0;
  var direction = is_both ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element2.inert;
  var overflow = element2.style.overflow;
  var intro;
  var outro;
  function get_options() {
    return without_reactive_context(() => {
      return current_options ?? (current_options = get_fn()(element2, get_params?.() ?? /** @type {P} */
      {}, {
        direction
      }));
    });
  }
  var transition2 = {
    is_global,
    in() {
      element2.inert = inert;
      if (!is_intro) {
        outro?.abort();
        outro?.reset?.();
        return;
      }
      if (!is_outro) {
        intro?.abort();
      }
      dispatch_event(element2, "introstart");
      intro = animate(element2, get_options(), outro, 1, () => {
        dispatch_event(element2, "introend");
        intro?.abort();
        intro = current_options = void 0;
        element2.style.overflow = overflow;
      });
    },
    out(fn) {
      if (!is_outro) {
        fn?.();
        current_options = void 0;
        return;
      }
      element2.inert = true;
      dispatch_event(element2, "outrostart");
      outro = animate(element2, get_options(), intro, 0, () => {
        dispatch_event(element2, "outroend");
        fn?.();
      });
    },
    stop: () => {
      intro?.abort();
      outro?.abort();
    }
  };
  var e = (
    /** @type {Effect} */
    active_effect
  );
  (e.transitions ?? (e.transitions = [])).push(transition2);
  if (is_intro && should_intro) {
    var run2 = is_global;
    if (!run2) {
      var block2 = (
        /** @type {Effect | null} */
        e.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0) break;
        }
      }
      run2 = !block2 || (block2.f & EFFECT_RAN) !== 0;
    }
    if (run2) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
function animate(element2, options, counterpart, t2, on_finish) {
  var is_intro = t2 === 1;
  if (is_function(options)) {
    var a;
    var aborted2 = false;
    queue_micro_task(() => {
      if (aborted2) return;
      var o = options({ direction: is_intro ? "in" : "out" });
      a = animate(element2, o, counterpart, t2, on_finish);
    });
    return {
      abort: () => {
        aborted2 = true;
        a?.abort();
      },
      deactivate: () => a.deactivate(),
      reset: () => a.reset(),
      t: () => a.t()
    };
  }
  counterpart?.deactivate();
  if (!options?.duration) {
    on_finish();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: () => t2
    };
  }
  const { delay = 0, css, tick: tick2, easing = linear } = options;
  var keyframes = [];
  if (is_intro && counterpart === void 0) {
    if (tick2) {
      tick2(0, 1);
    }
    if (css) {
      var styles = css_to_keyframe(css(0, 1));
      keyframes.push(styles, styles);
    }
  }
  var get_t = () => 1 - t2;
  var animation2 = element2.animate(keyframes, { duration: delay, fill: "forwards" });
  animation2.onfinish = () => {
    animation2.cancel();
    var t1 = counterpart?.t() ?? 1 - t2;
    counterpart?.abort();
    var delta = t2 - t1;
    var duration = (
      /** @type {number} */
      options.duration * Math.abs(delta)
    );
    var keyframes2 = [];
    if (duration > 0) {
      var needs_overflow_hidden = false;
      if (css) {
        var n = Math.ceil(duration / (1e3 / 60));
        for (var i = 0; i <= n; i += 1) {
          var t = t1 + delta * easing(i / n);
          var styles2 = css_to_keyframe(css(t, 1 - t));
          keyframes2.push(styles2);
          needs_overflow_hidden || (needs_overflow_hidden = styles2.overflow === "hidden");
        }
      }
      if (needs_overflow_hidden) {
        element2.style.overflow = "hidden";
      }
      get_t = () => {
        var time = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          animation2.currentTime
        );
        return t1 + delta * easing(time / duration);
      };
      if (tick2) {
        loop(() => {
          if (animation2.playState !== "running") return false;
          var t3 = get_t();
          tick2(t3, 1 - t3);
          return true;
        });
      }
    }
    animation2 = element2.animate(keyframes2, { duration, fill: "forwards" });
    animation2.onfinish = () => {
      get_t = () => t2;
      tick2?.(t2, 1 - t2);
      on_finish();
    };
  };
  return {
    abort: () => {
      if (animation2) {
        animation2.cancel();
        animation2.effect = null;
        animation2.onfinish = noop;
      }
    },
    deactivate: () => {
      on_finish = noop;
    },
    reset: () => {
      if (t2 === 0) {
        tick2?.(1, 0);
      }
    },
    t: () => get_t()
  };
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/document.js
function bind_active_element(update2) {
  listen(document, ["focusin", "focusout"], (event2) => {
    if (event2 && event2.type === "focusout" && /** @type {FocusEvent} */
    event2.relatedTarget) {
      return;
    }
    update2(document.activeElement);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
function bind_value(input, get3, set2 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = is_reset ? input.defaultValue : input.value;
    value = is_numberlike_input(input) ? to_number(value) : value;
    set2(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value !== (value = get3())) {
      var start = input.selectionStart;
      var end = input.selectionEnd;
      input.value = value ?? "";
      if (end !== null) {
        input.selectionStart = start;
        input.selectionEnd = Math.min(end, input.value.length);
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get3) == null && input.value
  ) {
    set2(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = get3();
    if (input === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value && !input.value) {
      return;
    }
    if (value !== input.value) {
      input.value = value ?? "";
    }
  });
}
var pending2 = /* @__PURE__ */ new Set();
function bind_group(inputs, group_index, input, get3, set2 = get3) {
  var is_checkbox = input.getAttribute("type") === "checkbox";
  var binding_group = inputs;
  let hydration_mismatch2 = false;
  if (group_index !== null) {
    for (var index2 of group_index) {
      binding_group = binding_group[index2] ?? (binding_group[index2] = []);
    }
  }
  binding_group.push(input);
  listen_to_event_and_reset_event(
    input,
    "change",
    () => {
      var value = input.__value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      }
      set2(value);
    },
    // TODO better default value handling
    () => set2(is_checkbox ? [] : null)
  );
  render_effect(() => {
    var value = get3();
    if (hydrating && input.defaultChecked !== input.checked) {
      hydration_mismatch2 = true;
      return;
    }
    if (is_checkbox) {
      value = value || [];
      input.checked = value.includes(input.__value);
    } else {
      input.checked = is(input.__value, value);
    }
  });
  teardown(() => {
    var index3 = binding_group.indexOf(input);
    if (index3 !== -1) {
      binding_group.splice(index3, 1);
    }
  });
  if (!pending2.has(binding_group)) {
    pending2.add(binding_group);
    queue_micro_task(() => {
      binding_group.sort((a, b) => a.compareDocumentPosition(b) === 4 ? -1 : 1);
      pending2.delete(binding_group);
    });
  }
  queue_micro_task(() => {
    if (hydration_mismatch2) {
      var value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      } else {
        var hydration_input = binding_group.find((input2) => input2.checked);
        value = hydration_input?.__value;
      }
      set2(value);
    }
  });
}
function bind_checked(input, get3, set2 = get3) {
  listen_to_event_and_reset_event(input, "change", (is_reset) => {
    var value = is_reset ? input.defaultChecked : input.checked;
    set2(value);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the update value from the input instead.
    hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
    untrack(get3) == null
  ) {
    set2(input.checked);
  }
  render_effect(() => {
    var value = get3();
    input.checked = Boolean(value);
  });
}
function get_binding_group_value(group, __value, checked) {
  var value = /* @__PURE__ */ new Set();
  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value.add(group[i].__value);
    }
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}
function bind_files(input, get3, set2 = get3) {
  listen_to_event_and_reset_event(input, "change", () => {
    set2(input.files);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.files
  ) {
    set2(input.files);
  }
  render_effect(() => {
    input.files = get3();
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/media.js
function time_ranges_to_array(ranges) {
  var array = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array;
}
function bind_current_time(media, get3, set2 = get3) {
  var raf_id;
  var value;
  var callback = () => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    var next_value = media.currentTime;
    if (value !== next_value) {
      set2(value = next_value);
    }
  };
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    var next_value = Number(get3());
    if (value !== next_value && !isNaN(
      /** @type {any} */
      next_value
    )) {
      media.currentTime = value = next_value;
    }
  });
  teardown(() => {
    cancelAnimationFrame(raf_id);
    media.removeEventListener("timeupdate", callback);
  });
}
function bind_buffered(media, set2) {
  var current;
  listen(media, ["loadedmetadata", "progress", "timeupdate", "seeking"], () => {
    var ranges = media.buffered;
    if (!current || current.length !== ranges.length || current.some((range, i) => ranges.start(i) !== range.start || ranges.end(i) !== range.end)) {
      current = time_ranges_to_array(ranges);
      set2(current);
    }
  });
}
function bind_seekable(media, set2) {
  listen(media, ["loadedmetadata"], () => set2(time_ranges_to_array(media.seekable)));
}
function bind_played(media, set2) {
  listen(media, ["timeupdate"], () => set2(time_ranges_to_array(media.played)));
}
function bind_seeking(media, set2) {
  listen(media, ["seeking", "seeked"], () => set2(media.seeking));
}
function bind_ended(media, set2) {
  listen(media, ["timeupdate", "ended"], () => set2(media.ended));
}
function bind_ready_state(media, set2) {
  listen(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    () => set2(media.readyState)
  );
}
function bind_playback_rate(media, get3, set2 = get3) {
  effect(() => {
    var value = Number(get3());
    if (value !== media.playbackRate && !isNaN(value)) {
      media.playbackRate = value;
    }
  });
  effect(() => {
    listen(media, ["ratechange"], () => {
      set2(media.playbackRate);
    });
  });
}
function bind_paused(media, get3, set2 = get3) {
  var paused = get3();
  var update2 = () => {
    if (paused !== media.paused) {
      set2(paused = media.paused);
    }
  };
  listen(media, ["play", "pause", "canplay"], update2, paused == null);
  effect(() => {
    if ((paused = !!get3()) !== media.paused) {
      if (paused) {
        media.pause();
      } else {
        media.play().catch(() => {
          set2(paused = true);
        });
      }
    }
  });
}
function bind_volume(media, get3, set2 = get3) {
  var callback = () => {
    set2(media.volume);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = Number(get3());
    if (value !== media.volume && !isNaN(value)) {
      media.volume = value;
    }
  });
}
function bind_muted(media, get3, set2 = get3) {
  var callback = () => {
    set2(media.muted);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = !!get3();
    if (media.muted !== value) media.muted = value;
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js
function bind_online(update2) {
  listen(window, ["online", "offline"], () => {
    update2(navigator.onLine);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/props.js
function bind_prop(props, prop2, value) {
  var desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value;
    teardown(() => {
      props[prop2] = null;
    });
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
var _listeners, _observer, _options, _ResizeObserverSingleton_instances, getObserver_fn;
var _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _ResizeObserverSingleton_instances);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    var listeners = __privateGet(this, _listeners).get(element2) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element2, listeners);
    __privateMethod(this, _ResizeObserverSingleton_instances, getObserver_fn).call(this).observe(element2, __privateGet(this, _options));
    return () => {
      var listeners2 = __privateGet(this, _listeners).get(element2);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element2);
        __privateGet(this, _observer).unobserve(element2);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_ResizeObserverSingleton_instances = new WeakSet();
getObserver_fn = function() {
  return __privateGet(this, _observer) ?? __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries) => {
      for (var entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
};
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
var ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function bind_resize_observer(element2, type, set2) {
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  var unsub = observer.observe(
    element2,
    /** @param {any} entry */
    (entry) => set2(entry[type])
  );
  teardown(unsub);
}
function bind_element_size(element2, type, set2) {
  var unsub = resize_observer_border_box.observe(element2, () => set2(element2[type]));
  effect(() => {
    untrack(() => set2(element2[type]));
    return unsub;
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
}
function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = get_parts?.() || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js
function bind_content_editable(property, element2, get3, set2 = get3) {
  element2.addEventListener("input", () => {
    set2(element2[property]);
  });
  render_effect(() => {
    var value = get3();
    if (element2[property] !== value) {
      if (value == null) {
        var non_null_value = element2[property];
        set2(non_null_value);
      } else {
        element2[property] = value + "";
      }
    }
  });
}
function bind_property(property, event_name, element2, set2, get3) {
  var handler = () => {
    set2(element2[property]);
  };
  element2.addEventListener(event_name, handler);
  if (get3) {
    render_effect(() => {
      element2[property] = get3();
    });
  } else {
    handler();
  }
  if (element2 === document.body || element2 === window || element2 === document) {
    teardown(() => {
      element2.removeEventListener(event_name, handler);
    });
  }
}
function bind_focused(element2, set2) {
  listen(element2, ["focus", "blur"], () => {
    set2(element2 === document.activeElement);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/window.js
function bind_window_scroll(type, get3, set2 = get3) {
  var is_scrolling_x = type === "x";
  var target_handler = () => without_reactive_context(() => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear, 100);
    set2(window[is_scrolling_x ? "scrollX" : "scrollY"]);
  });
  addEventListener("scroll", target_handler, {
    passive: true
  });
  var scrolling = false;
  var timeout;
  var clear = () => {
    scrolling = false;
  };
  var first = true;
  render_effect(() => {
    var latest_value = get3();
    if (first) {
      first = false;
    } else if (!scrolling && latest_value != null) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear, 100);
    }
  });
  effect(target_handler);
  teardown(() => {
    removeEventListener("scroll", target_handler);
  });
}
function bind_window_size(type, set2) {
  listen(window, ["resize"], () => without_reactive_context(() => set2(window[type])));
}

// node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
function trusted(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.isTrusted) {
      fn?.apply(this, args);
    }
  };
}
function self(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.target === this) {
      fn?.apply(this, args);
    }
  };
}
function stopPropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopPropagation();
    return fn?.apply(this, args);
  };
}
function once(fn) {
  var ran = false;
  return function(...args) {
    if (ran) return;
    ran = true;
    return fn?.apply(this, args);
  };
}
function stopImmediatePropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopImmediatePropagation();
    return fn?.apply(this, args);
  };
}
function preventDefault(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.preventDefault();
    return fn?.apply(this, args);
  };
}

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
function init(immutable = false) {
  const context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context.l.u;
  if (!callbacks) return;
  let props = () => deep_read_state(context.s);
  if (immutable) {
    let version = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d = derived(() => {
      let changed = false;
      const props2 = context.s;
      for (const key2 in props2) {
        if (props2[key2] !== prev[key2]) {
          prev[key2] = props2[key2];
          changed = true;
        }
      }
      if (changed) version++;
      return version;
    });
    props = () => get(d);
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context, props);
      run_all(callbacks.a);
    });
  }
}
function observe_all(context, props) {
  if (context.l.s) {
    for (const signal of context.l.s) get(signal);
  }
  props();
}

// node_modules/svelte/src/internal/client/dom/legacy/misc.js
function reactive_import(fn) {
  var s = source(0);
  return function() {
    if (arguments.length === 1) {
      set(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function bubble_event($$props, event2) {
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    $$props.$$events?.[event2.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event2);
  }
}
function add_legacy_event_listener($$props, event_name, event_callback) {
  var _a;
  $$props.$$events || ($$props.$$events = {});
  (_a = $$props.$$events)[event_name] || (_a[event_name] = []);
  $$props.$$events[event_name].push(event_callback);
}
function update_legacy_props($$new_props) {
  for (var key2 in $$new_props) {
    if (key2 in this) {
      this[key2] = $$new_props[key2];
    }
  }
}

// node_modules/svelte/src/store/utils.js
function subscribe_to_store(store, run2, invalidate) {
  if (store == null) {
    run2(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run2,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

// node_modules/svelte/src/store/shared/index.js
function get2(store) {
  let value;
  subscribe_to_store(store, (_) => value = _)();
  return value;
}

// node_modules/svelte/src/internal/client/reactivity/store.js
var is_store_binding = false;
var IS_UNMOUNTED = Symbol();
function store_get(store, store_name, stores) {
  const entry = stores[store_name] ?? (stores[store_name] = {
    store: null,
    source: mutable_source(void 0),
    unsubscribe: noop
  });
  if (dev_fallback_default) {
    entry.source.label = store_name;
  }
  if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store ?? null;
    if (store == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store, (v) => {
        if (is_synchronous_callback) {
          entry.source.v = v;
        } else {
          set(entry.source, v);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store && IS_UNMOUNTED in stores) {
    return get2(store);
  }
  return get(entry.source);
}
function store_unsub(store, store_name, stores) {
  let entry = stores[store_name];
  if (entry && entry.store !== store) {
    entry.unsubscribe();
    entry.unsubscribe = noop;
  }
  return store;
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function invalidate_store(stores, store_name) {
  var entry = stores[store_name];
  if (entry.store !== null) {
    store_set(entry.store, entry.source.v);
  }
}
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  return [stores, cleanup];
}
function store_mutate(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function update_store(store, store_value, d = 1) {
  store.set(store_value + d);
  return store_value;
}
function update_pre_store(store, store_value, d = 1) {
  const value = store_value + d;
  store.set(value);
  return value;
}
function mark_store_binding() {
  is_store_binding = true;
}
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}

// node_modules/svelte/src/internal/client/reactivity/props.js
function update_prop(fn, d = 1) {
  const value = fn();
  fn(value + d);
  return value;
}
function update_pre_prop(fn, d = 1) {
  const value = fn() + d;
  fn(value);
  return value;
}
var rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    return target.props[key2];
  },
  set(target, key2) {
    if (dev_fallback_default) {
      props_rest_readonly(`${target.name}.${String(key2)}`);
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude, name) {
  return new Proxy(
    dev_fallback_default ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
var legacy_rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    get(target.version);
    return key2 in target.special ? target.special[key2]() : target.props[key2];
  },
  set(target, key2, value) {
    if (!(key2 in target.special)) {
      var previous_effect = active_effect;
      try {
        set_active_effect(target.parent_effect);
        target.special[key2] = prop(
          {
            get [key2]() {
              return target.props[key2];
            }
          },
          /** @type {string} */
          key2,
          PROPS_IS_UPDATED
        );
      } finally {
        set_active_effect(previous_effect);
      }
    }
    target.special[key2](value);
    update(target.version);
    return true;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  deleteProperty(target, key2) {
    if (target.exclude.includes(key2)) return true;
    target.exclude.push(key2);
    update(target.version);
    return true;
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
function legacy_rest_props(props, exclude) {
  return new Proxy(
    {
      props,
      exclude,
      special: {},
      version: source(0),
      // TODO this is only necessary because we need to track component
      // destruction inside `prop`, because of `bind:this`, but it
      // seems likely that we can simplify `bind:this` instead
      parent_effect: (
        /** @type {Effect} */
        active_effect
      )
    },
    legacy_rest_props_handler
  );
}
var spread_props_handler = {
  get(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key2 in p) return p[key2];
    }
  },
  set(target, key2, value) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      const desc = get_descriptor(p, key2);
      if (desc && desc.set) {
        desc.set(value);
        return true;
      }
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key2 in p) {
        const descriptor = get_descriptor(p, key2);
        if (descriptor && !descriptor.configurable) {
          descriptor.configurable = true;
        }
        return descriptor;
      }
    }
  },
  has(target, key2) {
    if (key2 === STATE_SYMBOL || key2 === LEGACY_PROPS) return false;
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (p != null && key2 in p) return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (!p) continue;
      for (const key2 in p) {
        if (!keys.includes(key2)) keys.push(key2);
      }
      for (const key2 of Object.getOwnPropertySymbols(p)) {
        if (!keys.includes(key2)) keys.push(key2);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key2, flags2, fallback2) {
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback2
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(
        /** @type {() => V} */
        fallback2
      ) : (
        /** @type {V} */
        fallback2
      );
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = get_descriptor(props, key2)?.set ?? (is_entry_props && key2 in props ? (v) => props[key2] = v : void 0);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback2 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key2);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value === void 0) return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value === void 0 ? fallback_value : value;
    };
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      (function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        }
        return getter();
      })
    );
  }
  var overridden = false;
  var d = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (dev_fallback_default) {
    d.label = key2;
  }
  if (bindable) get(d);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    (function(value, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;
        set(d, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d.v;
      }
      return get(d);
    })
  );
}

// node_modules/svelte/src/internal/client/validate.js
function validate_each_keys(collection, key_fn) {
  render_effect(() => {
    const keys = /* @__PURE__ */ new Map();
    const maybe_array = collection();
    const array = is_array(maybe_array) ? maybe_array : maybe_array == null ? [] : Array.from(maybe_array);
    const length = array.length;
    for (let i = 0; i < length; i++) {
      const key2 = key_fn(array[i], i);
      if (keys.has(key2)) {
        const a = String(keys.get(key2));
        const b = String(i);
        let k = String(key2);
        if (k.startsWith("[object ")) k = null;
        each_key_duplicate(a, b, k);
      }
      keys.set(key2, i);
    }
  });
}
function validate_binding(binding, get_object, get_property, line, column) {
  var warned = false;
  var filename = dev_current_component_function?.[FILENAME];
  render_effect(() => {
    if (warned) return;
    var [object, is_store_sub] = capture_store_binding(get_object);
    if (is_store_sub) return;
    var property = get_property();
    var ran = false;
    var effect2 = render_effect(() => {
      if (ran) return;
      object[property];
    });
    ran = true;
    if (effect2.deps === null) {
      var location = `${filename}:${line}:${column}`;
      binding_property_non_reactive(binding, location);
      warned = true;
    }
  });
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance);
    var sources = /* @__PURE__ */ new Map();
    var add_source = (key2, value) => {
      var s = mutable_source(value, false, false);
      sources.set(key2, s);
      return s;
    };
    const props = new Proxy(
      { ...options.props || {}, $$events: {} },
      {
        get(target, prop2) {
          return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
        },
        has(target, prop2) {
          if (prop2 === LEGACY_PROPS) return true;
          get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
          return Reflect.has(target, prop2);
        },
        set(target, prop2, value) {
          set(sources.get(prop2) ?? add_source(prop2, value), value);
          return Reflect.set(target, prop2, value);
        }
      }
    );
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: options.intro ?? false,
      recover: options.recover
    }));
    if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
      flushSync();
    }
    __privateSet(this, _events, props.$$events);
    for (const key2 of Object.keys(__privateGet(this, _instance))) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return __privateGet(this, _instance)[key2];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key2] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default") slot2.name = name;
            append(anchor, slot2);
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key2 in this.$$p_d) {
          if (!(key2 in this.$$d) && this[key2] !== void 0) {
            this.$$d[key2] = this[key2];
            delete this[key2];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            this.$$r = true;
            for (const key2 of object_keys(this.$$c)) {
              if (!this.$$p_d[key2]?.reflect) continue;
              this.$$d[key2] = this.$$c[key2];
              const attribute_value = get_custom_element_value(
                key2,
                this.$$d[key2],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key2].attribute || key2);
              } else {
                this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type = props_definition[prop2]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
function create_custom_element(Component, props_definition, slots, exports, use_shadow_dom, extend) {
  let Class = class extends SvelteElement {
    constructor() {
      super(Component, slots, use_shadow_dom);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return object_keys(props_definition).map(
        (key2) => (props_definition[key2].attribute || key2).toLowerCase()
      );
    }
  };
  object_keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value) {
        value = get_custom_element_value(prop2, value, props_definition);
        this.$$d[prop2] = value;
        var component2 = this.$$c;
        if (component2) {
          var setter = get_descriptor(component2, prop2)?.get;
          if (setter) {
            component2[prop2] = value;
          } else {
            component2.$set({ [prop2]: value });
          }
        }
      }
    });
  });
  exports.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        return this.$$c?.[property];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}

// node_modules/svelte/src/internal/client/dev/console-log.js
function log_if_contains_state(method, ...objects) {
  untrack(() => {
    try {
      let has_state = false;
      const transformed = [];
      for (const obj of objects) {
        if (obj && typeof obj === "object" && STATE_SYMBOL in obj) {
          transformed.push(snapshot(obj, true));
          has_state = true;
        } else {
          transformed.push(obj);
        }
      }
      if (has_state) {
        console_log_state(method);
        console.log("%c[snapshot]", "color: grey", ...transformed);
      }
    } catch {
    }
  });
  return objects;
}

// <stdin>
console.log("\u2705 Svelte 5 runtime loaded");
export {
  CLASS,
  FILENAME,
  HMR,
  NAMESPACE_SVG,
  STYLE,
  aborted,
  action,
  active_effect,
  add_legacy_event_listener,
  add_locations,
  add_svelte_meta,
  animation,
  append,
  append_styles,
  apply,
  assign,
  assign_and,
  assign_nullish,
  assign_or,
  async,
  async_body,
  async_derived,
  attach,
  createAttachmentKey as attachment,
  attr,
  attribute_effect,
  autofocus,
  await_block as await,
  bind_active_element,
  bind_buffered,
  bind_checked,
  bind_content_editable,
  bind_current_time,
  bind_element_size,
  bind_ended,
  bind_files,
  bind_focused,
  bind_group,
  bind_muted,
  bind_online,
  bind_paused,
  bind_playback_rate,
  bind_played,
  bind_prop,
  bind_property,
  bind_ready_state,
  bind_resize_observer,
  bind_seekable,
  bind_seeking,
  bind_select_value,
  bind_this,
  bind_value,
  bind_volume,
  bind_window_scroll,
  bind_window_size,
  boundary,
  bubble_event,
  check_target,
  child,
  cleanup_styles,
  clsx2 as clsx,
  comment,
  component,
  create_custom_element,
  create_ownership_validator,
  css_props,
  deep_read,
  deep_read_state,
  delegate,
  user_derived as derived,
  derived_safe_equal,
  $document as document,
  each,
  effect,
  effect_root,
  effect_tracking,
  element,
  equals2 as equals,
  event,
  exclude_from_object,
  fallback,
  first_child,
  flushSync as flush,
  for_await_track_reactivity_loss,
  from_html,
  from_mathml,
  from_svg,
  from_tree,
  get,
  head,
  hmr,
  html,
  hydrate,
  hydrate_template,
  if_block as if,
  index,
  init,
  init_select,
  inspect,
  invalid_default_snippet,
  invalidate_inner_signals,
  invalidate_store,
  invoke_error_boundary,
  key,
  legacy_api,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  legacy_rest_props,
  log_if_contains_state,
  mark_store_binding,
  mount,
  mutable_source,
  mutate,
  next,
  noop,
  once,
  pending,
  pop,
  preventDefault,
  prevent_snippet_stringification,
  prop,
  props_id,
  proxy,
  push,
  raf,
  reactive_import,
  remove_input_defaults,
  remove_textarea_child,
  render_effect,
  replay_events,
  reset,
  rest_props,
  safe_get,
  sanitize_slots,
  save,
  select_option,
  self,
  set,
  set_attribute2 as set_attribute,
  set_attributes,
  set_checked,
  set_class,
  set_custom_element_data,
  set_default_checked,
  set_default_value,
  set_selected,
  set_style,
  set_text,
  set_value,
  set_xlink_attribute,
  setup_stores,
  sibling,
  slot,
  snapshot,
  snippet,
  spread_props,
  state,
  stopImmediatePropagation,
  stopPropagation,
  store_get,
  store_mutate,
  store_set,
  store_unsub,
  strict_equals,
  suspend,
  tag,
  tag_proxy,
  template_effect,
  text,
  tick,
  to_array,
  trace,
  track_reactivity_loss,
  transition,
  trusted,
  untrack,
  update,
  update_legacy_props,
  update_pre,
  update_pre_prop,
  update_pre_store,
  update_prop,
  update_store,
  user_effect,
  user_pre_effect,
  validate_binding,
  validate_dynamic_element_tag,
  validate_each_keys,
  validate_snippet_args,
  validate_store,
  validate_void_dynamic_element,
  $window as window,
  with_script,
  wrap_snippet
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvY29uc3RhbnRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9lc20tZW52L3RydWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2VzbS1lbnYvZGV2LWZhbGxiYWNrLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvY29uc3RhbnRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9lcnJvcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Vycm9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvd2FybmluZ3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9oeWRyYXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZXF1YWxpdHkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvc2hhcmVkL3dhcm5pbmdzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9jbG9uZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L3RyYWNpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2NvbnRleHQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Vycm9yLWhhbmRsaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vdGFzay5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9yZWFjdGl2aXR5L2NyZWF0ZS1zdWJzY3JpYmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2JvdW5kYXJ5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2FzeW5jLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2JhdGNoLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3NvdXJjZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3Byb3h5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvZXF1YWxpdHkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9vcGVyYXRpb25zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvbWlzYy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NoYXJlZC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lZmZlY3RzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9sZWdhY3kuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9ldmVudHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc3ZlbHRlLWhlYWQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9yZWNvbmNpbGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vdGVtcGxhdGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvdXRpbHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9zaGFyZWQvdmFsaWRhdGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc25pcHBldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbmRleC1jbGllbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvYXR0YWNobWVudHMvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9hc3NpZ24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9jc3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi9lbGVtZW50cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2htci5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L293bmVyc2hpcC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2xlZ2FjeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZGV2L2luc3BlY3QuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvYXN5bmMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2Rldi92YWxpZGF0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2F3YWl0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2lmLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL2tleS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9jc3MtcHJvcHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3MvZWFjaC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9odG1sLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3Nsb3QuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9ibG9ja3Mvc3ZlbHRlLWNvbXBvbmVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Jsb2Nrcy9zdmVsdGUtZWxlbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2Nzcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2FjdGlvbnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9hdHRhY2htZW50cy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9lc2NhcGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL3NoYXJlZC9hdHRyaWJ1dGVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvY2xhc3MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9zdHlsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NlbGVjdC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2F0dHJpYnV0ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L3RpbWluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvbG9vcC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL3RyYW5zaXRpb25zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvZG9jdW1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9pbnB1dC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL21lZGlhLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvbmF2aWdhdG9yLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvcHJvcHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaXplLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vZWxlbWVudHMvYmluZGluZ3MvdGhpcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3VuaXZlcnNhbC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3dpbmRvdy5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2xlZ2FjeS9ldmVudC1tb2RpZmllcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvaW50ZXJuYWwvY2xpZW50L2RvbS9sZWdhY3kvbGlmZWN5Y2xlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kb20vbGVnYWN5L21pc2MuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvdXRpbHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9zcmMvc3RvcmUvc2hhcmVkL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3N0b3JlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3Byb3BzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC92YWxpZGF0ZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9sZWdhY3kvbGVnYWN5LWNsaWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3ZlbHRlL3NyYy9pbnRlcm5hbC9jbGllbnQvZG9tL2VsZW1lbnRzL2N1c3RvbS1lbGVtZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zdmVsdGUvc3JjL2ludGVybmFsL2NsaWVudC9kZXYvY29uc29sZS1sb2cuanMiLCAiPHN0ZGluPiJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiZXhwb3J0IGNvbnN0IEVBQ0hfSVRFTV9SRUFDVElWRSA9IDE7XG5leHBvcnQgY29uc3QgRUFDSF9JTkRFWF9SRUFDVElWRSA9IDEgPDwgMTtcbi8qKiBTZWUgRWFjaEJsb2NrIGludGVyZmFjZSBtZXRhZGF0YS5pc19jb250cm9sbGVkIGZvciBhbiBleHBsYW5hdGlvbiB3aGF0IHRoaXMgaXMgKi9cbmV4cG9ydCBjb25zdCBFQUNIX0lTX0NPTlRST0xMRUQgPSAxIDw8IDI7XG5leHBvcnQgY29uc3QgRUFDSF9JU19BTklNQVRFRCA9IDEgPDwgMztcbmV4cG9ydCBjb25zdCBFQUNIX0lURU1fSU1NVVRBQkxFID0gMSA8PCA0O1xuXG5leHBvcnQgY29uc3QgUFJPUFNfSVNfSU1NVVRBQkxFID0gMTtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19SVU5FUyA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBQUk9QU19JU19VUERBVEVEID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0JJTkRBQkxFID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IFBST1BTX0lTX0xBWllfSU5JVElBTCA9IDEgPDwgNDtcblxuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fSU4gPSAxO1xuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fT1VUID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IFRSQU5TSVRJT05fR0xPQkFMID0gMSA8PCAyO1xuXG5leHBvcnQgY29uc3QgVEVNUExBVEVfRlJBR01FTlQgPSAxO1xuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSA9IDEgPDwgMTtcbmV4cG9ydCBjb25zdCBURU1QTEFURV9VU0VfU1ZHID0gMSA8PCAyO1xuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1VTRV9NQVRITUwgPSAxIDw8IDM7XG5cbmV4cG9ydCBjb25zdCBIWURSQVRJT05fU1RBUlQgPSAnWyc7XG4vKiogdXNlZCB0byBpbmRpY2F0ZSB0aGF0IGFuIGB7OmVsc2V9Li4uYCBibG9jayB3YXMgcmVuZGVyZWQgKi9cbmV4cG9ydCBjb25zdCBIWURSQVRJT05fU1RBUlRfRUxTRSA9ICdbISc7XG5leHBvcnQgY29uc3QgSFlEUkFUSU9OX0VORCA9ICddJztcbmV4cG9ydCBjb25zdCBIWURSQVRJT05fRVJST1IgPSB7fTtcblxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfSVNfTkFNRVNQQUNFRCA9IDE7XG5leHBvcnQgY29uc3QgRUxFTUVOVF9QUkVTRVJWRV9BVFRSSUJVVEVfQ0FTRSA9IDEgPDwgMTtcblxuZXhwb3J0IGNvbnN0IFVOSU5JVElBTElaRUQgPSBTeW1ib2woKTtcblxuLy8gRGV2LXRpbWUgY29tcG9uZW50IHByb3BlcnRpZXNcbmV4cG9ydCBjb25zdCBGSUxFTkFNRSA9IFN5bWJvbCgnZmlsZW5hbWUnKTtcbmV4cG9ydCBjb25zdCBITVIgPSBTeW1ib2woJ2htcicpO1xuXG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX0hUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX1NWRyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5leHBvcnQgY29uc3QgTkFNRVNQQUNFX01BVEhNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcblxuLy8gd2UgdXNlIGEgbGlzdCBvZiBpZ25vcmFibGUgcnVudGltZSB3YXJuaW5ncyBiZWNhdXNlIG5vdCBldmVyeSBydW50aW1lIHdhcm5pbmdcbi8vIGNhbiBiZSBpZ25vcmVkIGFuZCB3ZSB3YW50IHRvIGtlZXAgdGhlIHZhbGlkYXRpb24gZm9yIHN2ZWx0ZS1pZ25vcmUgaW4gcGxhY2VcbmV4cG9ydCBjb25zdCBJR05PUkFCTEVfUlVOVElNRV9XQVJOSU5HUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCdhd2FpdF93YXRlcmZhbGwnLFxuXHQnYXdhaXRfcmVhY3Rpdml0eV9sb3NzJyxcblx0J3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlJyxcblx0J2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlJyxcblx0J2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZCcsXG5cdCdoeWRyYXRpb25faHRtbF9jaGFuZ2VkJyxcblx0J293bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmcnLFxuXHQnb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb24nXG5dKTtcblxuLyoqXG4gKiBXaGl0ZXNwYWNlIGluc2lkZSBvbmUgb2YgdGhlc2UgZWxlbWVudHMgd2lsbCBub3QgcmVzdWx0IGluXG4gKiBhIHdoaXRlc3BhY2Ugbm9kZSBiZWluZyBjcmVhdGVkIGluIGFueSBjaXJjdW1zdGFuY2VzLiAoVGhpc1xuICogbGlzdCBpcyBhbG1vc3QgY2VydGFpbmx5IHZlcnkgaW5jb21wbGV0ZSlcbiAqIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgdW51c2VkXG4gKi9cbmV4cG9ydCBjb25zdCBFTEVNRU5UU19XSVRIT1VUX1RFWFQgPSBbJ2F1ZGlvJywgJ2RhdGFsaXN0JywgJ2RsJywgJ29wdGdyb3VwJywgJ3NlbGVjdCcsICd2aWRlbyddO1xuXG5leHBvcnQgY29uc3QgQVRUQUNITUVOVF9LRVkgPSAnQGF0dGFjaCc7XG4iLCAiZXhwb3J0IGRlZmF1bHQgdHJ1ZTtcbiIsICJjb25zdCBub2RlX2VudiA9IGdsb2JhbFRoaXMucHJvY2Vzcz8uZW52Py5OT0RFX0VOVjtcbmV4cG9ydCBkZWZhdWx0IG5vZGVfZW52ICYmICFub2RlX2Vudi50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3Byb2QnKTtcbiIsICIvLyBTdG9yZSB0aGUgcmVmZXJlbmNlcyB0byBnbG9iYWxzIGluIGNhc2Ugc29tZW9uZSB0cmllcyB0byBtb25rZXkgcGF0Y2ggdGhlc2UsIGNhdXNpbmcgdGhlIGJlbG93XG4vLyB0byBkZS1vcHQgKHRoaXMgb2NjdXJzIG9mdGVuIHdoZW4gdXNpbmcgcG9wdWxhciBleHRlbnNpb25zKS5cbmV4cG9ydCB2YXIgaXNfYXJyYXkgPSBBcnJheS5pc0FycmF5O1xuZXhwb3J0IHZhciBpbmRleF9vZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuZXhwb3J0IHZhciBhcnJheV9mcm9tID0gQXJyYXkuZnJvbTtcbmV4cG9ydCB2YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cztcbmV4cG9ydCB2YXIgZGVmaW5lX3Byb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuZXhwb3J0IHZhciBnZXRfZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5leHBvcnQgdmFyIGdldF9kZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xuZXhwb3J0IHZhciBvYmplY3RfcHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmV4cG9ydCB2YXIgYXJyYXlfcHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuZXhwb3J0IHZhciBnZXRfcHJvdG90eXBlX29mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuZXhwb3J0IHZhciBpc19leHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdGhpbmdcbiAqIEByZXR1cm5zIHt0aGluZyBpcyBGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG5cdHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBjb25zdCBub29wID0gKCkgPT4ge307XG5cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuLyoqXG4gKiBAdGVtcGxhdGUgW1Q9YW55XVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7dmFsdWUgaXMgUHJvbWlzZUxpa2U8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19wcm9taXNlKHZhbHVlKSB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWU/LnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bihmbikge1xuXHRyZXR1cm4gZm4oKTtcbn1cblxuLyoqIEBwYXJhbSB7QXJyYXk8KCkgPT4gdm9pZD59IGFyciAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9hbGwoYXJyKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJyW2ldKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUT0RPIHJlcGxhY2Ugd2l0aCBQcm9taXNlLndpdGhSZXNvbHZlcnMgb25jZSBzdXBwb3J0ZWQgd2lkZWx5IGVub3VnaFxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmVycmVkKCkge1xuXHQvKiogQHR5cGUgeyh2YWx1ZTogVCkgPT4gdm9pZH0gKi9cblx0dmFyIHJlc29sdmU7XG5cblx0LyoqIEB0eXBlIHsocmVhc29uOiBhbnkpID0+IHZvaWR9ICovXG5cdHZhciByZWplY3Q7XG5cblx0LyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqL1xuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXHRcdHJlc29sdmUgPSByZXM7XG5cdFx0cmVqZWN0ID0gcmVqO1xuXHR9KTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHJldHVybiB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9O1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge1YgfCAoKCkgPT4gVil9IGZhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsYXp5XVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYWxsYmFjayh2YWx1ZSwgZmFsbGJhY2ssIGxhenkgPSBmYWxzZSkge1xuXHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuXHRcdD8gbGF6eVxuXHRcdFx0PyAvKiogQHR5cGUgeygpID0+IFZ9ICovIChmYWxsYmFjaykoKVxuXHRcdFx0OiAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjaylcblx0XHQ6IHZhbHVlO1xufVxuXG4vKipcbiAqIFdoZW4gZW5jb3VudGVyaW5nIGEgc2l0dWF0aW9uIGxpa2UgYGxldCBbYSwgYiwgY10gPSAkZGVyaXZlZChibGFoKCkpYCxcbiAqIHdlIG5lZWQgdG8gc3Rhc2ggYW4gaW50ZXJtZWRpYXRlIHZhbHVlIHRoYXQgYGFgLCBgYmAsIGFuZCBgY2AgZGVyaXZlXG4gKiBmcm9tLCBpbiBjYXNlIGl0J3MgYW4gaXRlcmFibGVcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPiB8IEl0ZXJhYmxlPFQ+fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IFtuXVxuICogQHJldHVybnMge0FycmF5PFQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fYXJyYXkodmFsdWUsIG4pIHtcblx0Ly8gcmV0dXJuIGFycmF5cyB1bmNoYW5nZWRcblx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0Ly8gaWYgdmFsdWUgaXMgbm90IGl0ZXJhYmxlLCBvciBgbmAgaXMgdW5zcGVjaWZpZWQgKGluZGljYXRlcyBhIHJlc3Rcblx0Ly8gZWxlbWVudCwgd2hpY2ggbWVhbnMgd2UncmUgbm90IGNvbmNlcm5lZCBhYm91dCB1bmJvdW5kZWQgaXRlcmFibGVzKVxuXHQvLyBjb252ZXJ0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb21gXG5cdGlmIChuID09PSB1bmRlZmluZWQgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpKSB7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xuXHR9XG5cblx0Ly8gb3RoZXJ3aXNlLCBwb3B1bGF0ZSBhbiBhcnJheSB3aXRoIGBuYCB2YWx1ZXNcblxuXHQvKiogQHR5cGUge1RbXX0gKi9cblx0Y29uc3QgYXJyYXkgPSBbXTtcblxuXHRmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWUpIHtcblx0XHRhcnJheS5wdXNoKGVsZW1lbnQpO1xuXHRcdGlmIChhcnJheS5sZW5ndGggPT09IG4pIGJyZWFrO1xuXHR9XG5cblx0cmV0dXJuIGFycmF5O1xufVxuIiwgImV4cG9ydCBjb25zdCBERVJJVkVEID0gMSA8PCAxO1xuZXhwb3J0IGNvbnN0IEVGRkVDVCA9IDEgPDwgMjtcbmV4cG9ydCBjb25zdCBSRU5ERVJfRUZGRUNUID0gMSA8PCAzO1xuZXhwb3J0IGNvbnN0IEJMT0NLX0VGRkVDVCA9IDEgPDwgNDtcbmV4cG9ydCBjb25zdCBCUkFOQ0hfRUZGRUNUID0gMSA8PCA1O1xuZXhwb3J0IGNvbnN0IFJPT1RfRUZGRUNUID0gMSA8PCA2O1xuZXhwb3J0IGNvbnN0IEJPVU5EQVJZX0VGRkVDVCA9IDEgPDwgNztcbmV4cG9ydCBjb25zdCBVTk9XTkVEID0gMSA8PCA4O1xuZXhwb3J0IGNvbnN0IERJU0NPTk5FQ1RFRCA9IDEgPDwgOTtcbmV4cG9ydCBjb25zdCBDTEVBTiA9IDEgPDwgMTA7XG5leHBvcnQgY29uc3QgRElSVFkgPSAxIDw8IDExO1xuZXhwb3J0IGNvbnN0IE1BWUJFX0RJUlRZID0gMSA8PCAxMjtcbmV4cG9ydCBjb25zdCBJTkVSVCA9IDEgPDwgMTM7XG5leHBvcnQgY29uc3QgREVTVFJPWUVEID0gMSA8PCAxNDtcbmV4cG9ydCBjb25zdCBFRkZFQ1RfUkFOID0gMSA8PCAxNTtcbi8qKiAnVHJhbnNwYXJlbnQnIGVmZmVjdHMgZG8gbm90IGNyZWF0ZSBhIHRyYW5zaXRpb24gYm91bmRhcnkgKi9cbmV4cG9ydCBjb25zdCBFRkZFQ1RfVFJBTlNQQVJFTlQgPSAxIDw8IDE2O1xuZXhwb3J0IGNvbnN0IElOU1BFQ1RfRUZGRUNUID0gMSA8PCAxNztcbmV4cG9ydCBjb25zdCBIRUFEX0VGRkVDVCA9IDEgPDwgMTg7XG5leHBvcnQgY29uc3QgRUZGRUNUX1BSRVNFUlZFRCA9IDEgPDwgMTk7XG5leHBvcnQgY29uc3QgVVNFUl9FRkZFQ1QgPSAxIDw8IDIwO1xuXG4vLyBGbGFncyB1c2VkIGZvciBhc3luY1xuZXhwb3J0IGNvbnN0IFJFQUNUSU9OX0lTX1VQREFUSU5HID0gMSA8PCAyMTtcbmV4cG9ydCBjb25zdCBBU1lOQyA9IDEgPDwgMjI7XG5cbmV4cG9ydCBjb25zdCBFUlJPUl9WQUxVRSA9IDEgPDwgMjM7XG5cbmV4cG9ydCBjb25zdCBTVEFURV9TWU1CT0wgPSBTeW1ib2woJyRzdGF0ZScpO1xuZXhwb3J0IGNvbnN0IExFR0FDWV9QUk9QUyA9IFN5bWJvbCgnbGVnYWN5IHByb3BzJyk7XG5leHBvcnQgY29uc3QgTE9BRElOR19BVFRSX1NZTUJPTCA9IFN5bWJvbCgnJyk7XG5leHBvcnQgY29uc3QgUFJPWFlfUEFUSF9TWU1CT0wgPSBTeW1ib2woJ3Byb3h5IHBhdGgnKTtcblxuLyoqIGFsbG93IHVzZXJzIHRvIGlnbm9yZSBhYm9ydGVkIHNpZ25hbCBlcnJvcnMgaWYgYHJlYXNvbi5uYW1lID09PSAnU3RhbGVSZWFjdGlvbkVycm9yYCAqL1xuZXhwb3J0IGNvbnN0IFNUQUxFX1JFQUNUSU9OID0gbmV3IChjbGFzcyBTdGFsZVJlYWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG5cdG5hbWUgPSAnU3RhbGVSZWFjdGlvbkVycm9yJztcblx0bWVzc2FnZSA9ICdUaGUgcmVhY3Rpb24gdGhhdCBjYWxsZWQgYGdldEFib3J0U2lnbmFsKClgIHdhcyByZS1ydW4gb3IgZGVzdHJveWVkJztcbn0pKCk7XG5cbmV4cG9ydCBjb25zdCBFTEVNRU5UX05PREUgPSAxO1xuZXhwb3J0IGNvbnN0IFRFWFRfTk9ERSA9IDM7XG5leHBvcnQgY29uc3QgQ09NTUVOVF9OT0RFID0gODtcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG4iLCAiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuLyoqXG4gKiBDYW5ub3QgYXdhaXQgb3V0c2lkZSBhIGA8c3ZlbHRlOmJvdW5kYXJ5PmAgd2l0aCBhIGBwZW5kaW5nYCBzbmlwcGV0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhd2FpdF9vdXRzaWRlX2JvdW5kYXJ5KCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGF3YWl0X291dHNpZGVfYm91bmRhcnlcXG5DYW5ub3QgYXdhaXQgb3V0c2lkZSBhIFxcYDxzdmVsdGU6Ym91bmRhcnk+XFxgIHdpdGggYSBcXGBwZW5kaW5nXFxgIHNuaXBwZXRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hd2FpdF9vdXRzaWRlX2JvdW5kYXJ5YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2F3YWl0X291dHNpZGVfYm91bmRhcnlgKTtcblx0fVxufVxuXG4vKipcbiAqIENhbm5vdCB1c2UgYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9YCBpZiB0aGUgcGFyZW50IGNvbXBvbmVudCB1c2VzIGBsZXQ6YCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9kZWZhdWx0X3NuaXBwZXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9kZWZhdWx0X3NuaXBwZXRcXG5DYW5ub3QgdXNlIFxcYHtAcmVuZGVyIGNoaWxkcmVuKC4uLil9XFxgIGlmIHRoZSBwYXJlbnQgY29tcG9uZW50IHVzZXMgXFxgbGV0OlxcYCBkaXJlY3RpdmVzLiBDb25zaWRlciB1c2luZyBhIG5hbWVkIHNuaXBwZXQgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfZGVmYXVsdF9zbmlwcGV0YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfZGVmYXVsdF9zbmlwcGV0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIHNuaXBwZXQgZnVuY3Rpb24gd2FzIHBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cy4gU25pcHBldHMgc2hvdWxkIG9ubHkgYmUgaW5zdGFudGlhdGVkIHZpYSBge0ByZW5kZXIgLi4ufWBcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRfc25pcHBldF9hcmd1bWVudHMoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50c1xcbkEgc25pcHBldCBmdW5jdGlvbiB3YXMgcGFzc2VkIGludmFsaWQgYXJndW1lbnRzLiBTbmlwcGV0cyBzaG91bGQgb25seSBiZSBpbnN0YW50aWF0ZWQgdmlhIFxcYHtAcmVuZGVyIC4uLn1cXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3NuaXBwZXRfYXJndW1lbnRzYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2ludmFsaWRfc25pcHBldF9hcmd1bWVudHNgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlbmFtZSUoLi4uKWAgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBsaWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnRcXG5cXGAke25hbWV9KC4uLilcXGAgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudGApO1xuXHR9XG59XG5cbi8qKlxuICogQXR0ZW1wdGVkIHRvIHJlbmRlciBhIHNuaXBwZXQgd2l0aG91dCBhIGB7QHJlbmRlcn1gIGJsb2NrLiBUaGlzIHdvdWxkIGNhdXNlIHRoZSBzbmlwcGV0IGNvZGUgdG8gYmUgc3RyaW5naWZpZWQgaW5zdGVhZCBvZiBpdHMgY29udGVudCBiZWluZyByZW5kZXJlZCB0byB0aGUgRE9NLiBUbyBmaXggdGhpcywgY2hhbmdlIGB7c25pcHBldH1gIHRvIGB7QHJlbmRlciBzbmlwcGV0KCl9YC5cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnXFxuQXR0ZW1wdGVkIHRvIHJlbmRlciBhIHNuaXBwZXQgd2l0aG91dCBhIFxcYHtAcmVuZGVyfVxcYCBibG9jay4gVGhpcyB3b3VsZCBjYXVzZSB0aGUgc25pcHBldCBjb2RlIHRvIGJlIHN0cmluZ2lmaWVkIGluc3RlYWQgb2YgaXRzIGNvbnRlbnQgYmVpbmcgcmVuZGVyZWQgdG8gdGhlIERPTS4gVG8gZml4IHRoaXMsIGNoYW5nZSBcXGB7c25pcHBldH1cXGAgdG8gXFxge0ByZW5kZXIgc25pcHBldCgpfVxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZ2ApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zbmlwcGV0X3dpdGhvdXRfcmVuZGVyX3RhZ2ApO1xuXHR9XG59XG5cbi8qKlxuICogYCVuYW1lJWAgaXMgbm90IGEgc3RvcmUgd2l0aCBhIGBzdWJzY3JpYmVgIG1ldGhvZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0b3JlX2ludmFsaWRfc2hhcGVcXG5cXGAke25hbWV9XFxgIGlzIG5vdCBhIHN0b3JlIHdpdGggYSBcXGBzdWJzY3JpYmVcXGAgbWV0aG9kXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RvcmVfaW52YWxpZF9zaGFwZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdG9yZV9pbnZhbGlkX3NoYXBlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHRoaXNgIHByb3Agb24gYDxzdmVsdGU6ZWxlbWVudD5gIG11c3QgYmUgYSBzdHJpbmcsIGlmIGRlZmluZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVcXG5UaGUgXFxgdGhpc1xcYCBwcm9wIG9uIFxcYDxzdmVsdGU6ZWxlbWVudD5cXGAgbXVzdCBiZSBhIHN0cmluZywgaWYgZGVmaW5lZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9lbGVtZW50X2ludmFsaWRfdGhpc192YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWVgKTtcblx0fVxufSIsICIvKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHNjcmlwdHMvcHJvY2Vzcy1tZXNzYWdlcy9pbmRleC5qcy4gRG8gbm90IGVkaXQhICovXG5cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG5leHBvcnQgKiAgZnJvbSAnLi4vc2hhcmVkL2Vycm9ycy5qcyc7XG5cbi8qKlxuICogQ2Fubm90IGNyZWF0ZSBhIGAkZGVyaXZlZCguLi4pYCB3aXRoIGFuIGBhd2FpdGAgZXhwcmVzc2lvbiBvdXRzaWRlIG9mIGFuIGVmZmVjdCB0cmVlXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3luY19kZXJpdmVkX29ycGhhbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBhc3luY19kZXJpdmVkX29ycGhhblxcbkNhbm5vdCBjcmVhdGUgYSBcXGAkZGVyaXZlZCguLi4pXFxgIHdpdGggYW4gXFxgYXdhaXRcXGAgZXhwcmVzc2lvbiBvdXRzaWRlIG9mIGFuIGVmZmVjdCB0cmVlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXN5bmNfZGVyaXZlZF9vcnBoYW5gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXN5bmNfZGVyaXZlZF9vcnBoYW5gKTtcblx0fVxufVxuXG4vKipcbiAqIFVzaW5nIGBiaW5kOnZhbHVlYCB0b2dldGhlciB3aXRoIGEgY2hlY2tib3ggaW5wdXQgaXMgbm90IGFsbG93ZWQuIFVzZSBgYmluZDpjaGVja2VkYCBpbnN0ZWFkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWUoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlXFxuVXNpbmcgXFxgYmluZDp2YWx1ZVxcYCB0b2dldGhlciB3aXRoIGEgY2hlY2tib3ggaW5wdXQgaXMgbm90IGFsbG93ZWQuIFVzZSBcXGBiaW5kOmNoZWNrZWRcXGAgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfaW52YWxpZF9jaGVja2JveF92YWx1ZWApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfY2hlY2tib3hfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIENvbXBvbmVudCAlY29tcG9uZW50JSBoYXMgYW4gZXhwb3J0IG5hbWVkIGAla2V5JWAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIGBiaW5kOiVrZXklYCwgd2hpY2ggaXMgZGlzYWxsb3dlZC4gSW5zdGVhZCwgdXNlIGBiaW5kOnRoaXNgIChlLmcuIGA8JW5hbWUlIGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPmApIGFuZCB0aGVuIGFjY2VzcyB0aGUgcHJvcGVydHkgb24gdGhlIGJvdW5kIGNvbXBvbmVudCBpbnN0YW5jZSAoZS5nLiBgY29tcG9uZW50LiVrZXklYClcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2ludmFsaWRfZXhwb3J0KGNvbXBvbmVudCwga2V5LCBuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgYmluZF9pbnZhbGlkX2V4cG9ydFxcbkNvbXBvbmVudCAke2NvbXBvbmVudH0gaGFzIGFuIGV4cG9ydCBuYW1lZCBcXGAke2tleX1cXGAgdGhhdCBhIGNvbnN1bWVyIGNvbXBvbmVudCBpcyB0cnlpbmcgdG8gYWNjZXNzIHVzaW5nIFxcYGJpbmQ6JHtrZXl9XFxgLCB3aGljaCBpcyBkaXNhbGxvd2VkLiBJbnN0ZWFkLCB1c2UgXFxgYmluZDp0aGlzXFxgIChlLmcuIFxcYDwke25hbWV9IGJpbmQ6dGhpcz17Y29tcG9uZW50fSAvPlxcYCkgYW5kIHRoZW4gYWNjZXNzIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYm91bmQgY29tcG9uZW50IGluc3RhbmNlIChlLmcuIFxcYGNvbXBvbmVudC4ke2tleX1cXGApXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZF9pbnZhbGlkX2V4cG9ydGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9iaW5kX2ludmFsaWRfZXhwb3J0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBBIGNvbXBvbmVudCBpcyBhdHRlbXB0aW5nIHRvIGJpbmQgdG8gYSBub24tYmluZGFibGUgcHJvcGVydHkgYCVrZXklYCBiZWxvbmdpbmcgdG8gJWNvbXBvbmVudCUgKGkuZS4gYDwlbmFtZSUgYmluZDola2V5JT17Li4ufT5gKS4gVG8gbWFyayBhIHByb3BlcnR5IGFzIGJpbmRhYmxlOiBgbGV0IHsgJWtleSUgPSAkYmluZGFibGUoKSB9ID0gJHByb3BzKClgXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9ub3RfYmluZGFibGUoa2V5LCBjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBiaW5kX25vdF9iaW5kYWJsZVxcbkEgY29tcG9uZW50IGlzIGF0dGVtcHRpbmcgdG8gYmluZCB0byBhIG5vbi1iaW5kYWJsZSBwcm9wZXJ0eSBcXGAke2tleX1cXGAgYmVsb25naW5nIHRvICR7Y29tcG9uZW50fSAoaS5lLiBcXGA8JHtuYW1lfSBiaW5kOiR7a2V5fT17Li4ufT5cXGApLiBUbyBtYXJrIGEgcHJvcGVydHkgYXMgYmluZGFibGU6IFxcYGxldCB7ICR7a2V5fSA9ICRiaW5kYWJsZSgpIH0gPSAkcHJvcHMoKVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfbm90X2JpbmRhYmxlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRfbm90X2JpbmRhYmxlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYWxsaW5nIGAlbWV0aG9kJWAgb24gYSBjb21wb25lbnQgaW5zdGFuY2UgKG9mICVjb21wb25lbnQlKSBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9hcGlfY2hhbmdlZChtZXRob2QsIGNvbXBvbmVudCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGNvbXBvbmVudF9hcGlfY2hhbmdlZFxcbkNhbGxpbmcgXFxgJHttZXRob2R9XFxgIG9uIGEgY29tcG9uZW50IGluc3RhbmNlIChvZiAke2NvbXBvbmVudH0pIGlzIG5vIGxvbmdlciB2YWxpZCBpbiBTdmVsdGUgNVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfY2hhbmdlZGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9jb21wb25lbnRfYXBpX2NoYW5nZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIEF0dGVtcHRlZCB0byBpbnN0YW50aWF0ZSAlY29tcG9uZW50JSB3aXRoIGBuZXcgJW5hbWUlYCwgd2hpY2ggaXMgbm8gbG9uZ2VyIHZhbGlkIGluIFN2ZWx0ZSA1LiBJZiB0aGlzIGNvbXBvbmVudCBpcyBub3QgdW5kZXIgeW91ciBjb250cm9sLCBzZXQgdGhlIGBjb21wYXRpYmlsaXR5LmNvbXBvbmVudEFwaWAgY29tcGlsZXIgb3B0aW9uIHRvIGA0YCB0byBrZWVwIGl0IHdvcmtpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50X2FwaV9pbnZhbGlkX25ldyhjb21wb25lbnQsIG5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBjb21wb25lbnRfYXBpX2ludmFsaWRfbmV3XFxuQXR0ZW1wdGVkIHRvIGluc3RhbnRpYXRlICR7Y29tcG9uZW50fSB3aXRoIFxcYG5ldyAke25hbWV9XFxgLCB3aGljaCBpcyBubyBsb25nZXIgdmFsaWQgaW4gU3ZlbHRlIDUuIElmIHRoaXMgY29tcG9uZW50IGlzIG5vdCB1bmRlciB5b3VyIGNvbnRyb2wsIHNldCB0aGUgXFxgY29tcGF0aWJpbGl0eS5jb21wb25lbnRBcGlcXGAgY29tcGlsZXIgb3B0aW9uIHRvIFxcYDRcXGAgdG8ga2VlcCBpdCB3b3JraW5nLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbXBvbmVudF9hcGlfaW52YWxpZF9uZXdgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvY29tcG9uZW50X2FwaV9pbnZhbGlkX25ld2ApO1xuXHR9XG59XG5cbi8qKlxuICogQSBkZXJpdmVkIHZhbHVlIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmIHJlY3Vyc2l2ZWx5XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBkZXJpdmVkX3JlZmVyZW5jZXNfc2VsZlxcbkEgZGVyaXZlZCB2YWx1ZSBjYW5ub3QgcmVmZXJlbmNlIGl0c2VsZiByZWN1cnNpdmVseVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2Rlcml2ZWRfcmVmZXJlbmNlc19zZWxmYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IGAldmFsdWUlYCBhdCBpbmRleGVzICVhJSBhbmQgJWIlXG4gKiBAcGFyYW0ge3N0cmluZ30gYVxuICogQHBhcmFtIHtzdHJpbmd9IGJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW3ZhbHVlXVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaF9rZXlfZHVwbGljYXRlKGEsIGIsIHZhbHVlKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWFjaF9rZXlfZHVwbGljYXRlXFxuJHt2YWx1ZVxuXHRcdFx0PyBgS2V5ZWQgZWFjaCBibG9jayBoYXMgZHVwbGljYXRlIGtleSBcXGAke3ZhbHVlfVxcYCBhdCBpbmRleGVzICR7YX0gYW5kICR7Yn1gXG5cdFx0XHQ6IGBLZXllZCBlYWNoIGJsb2NrIGhhcyBkdXBsaWNhdGUga2V5IGF0IGluZGV4ZXMgJHthfSBhbmQgJHtifWB9XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWFjaF9rZXlfZHVwbGljYXRlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VhY2hfa2V5X2R1cGxpY2F0ZWApO1xuXHR9XG59XG5cbi8qKlxuICogYCVydW5lJWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCBjbGVhbnVwIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X2luX3RlYXJkb3duKHJ1bmUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBlZmZlY3RfaW5fdGVhcmRvd25cXG5cXGAke3J1bmV9XFxgIGNhbm5vdCBiZSB1c2VkIGluc2lkZSBhbiBlZmZlY3QgY2xlYW51cCBmdW5jdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl90ZWFyZG93bmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdGVhcmRvd25gKTtcblx0fVxufVxuXG4vKipcbiAqIEVmZmVjdCBjYW5ub3QgYmUgY3JlYXRlZCBpbnNpZGUgYSBgJGRlcml2ZWRgIHZhbHVlIHRoYXQgd2FzIG5vdCBpdHNlbGYgY3JlYXRlZCBpbnNpZGUgYW4gZWZmZWN0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWRcXG5FZmZlY3QgY2Fubm90IGJlIGNyZWF0ZWQgaW5zaWRlIGEgXFxgJGRlcml2ZWRcXGAgdmFsdWUgdGhhdCB3YXMgbm90IGl0c2VsZiBjcmVhdGVkIGluc2lkZSBhbiBlZmZlY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfaW5fdW5vd25lZF9kZXJpdmVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9pbl91bm93bmVkX2Rlcml2ZWRgKTtcblx0fVxufVxuXG4vKipcbiAqIGAlcnVuZSVgIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCAoZS5nLiBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uKVxuICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF9vcnBoYW4ocnVuZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9vcnBoYW5cXG5cXGAke3J1bmV9XFxgIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIGVmZmVjdCAoZS5nLiBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uKVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF9vcnBoYW5gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X29ycGhhbmApO1xuXHR9XG59XG5cbi8qKlxuICogYCRlZmZlY3QucGVuZGluZygpYCBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCBvciBkZXJpdmVkXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGVmZmVjdF9wZW5kaW5nX291dHNpZGVfcmVhY3Rpb25cXG5cXGAkZWZmZWN0LnBlbmRpbmcoKVxcYCBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGFuIGVmZmVjdCBvciBkZXJpdmVkXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3BlbmRpbmdfb3V0c2lkZV9yZWFjdGlvbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9lZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyB0eXBpY2FsbHkgaW5kaWNhdGVzIHRoYXQgYW4gZWZmZWN0IHJlYWRzIGFuZCB3cml0ZXMgdGhlIHNhbWUgcGllY2Ugb2Ygc3RhdGVcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZFxcbk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIHR5cGljYWxseSBpbmRpY2F0ZXMgdGhhdCBhbiBlZmZlY3QgcmVhZHMgYW5kIHdyaXRlcyB0aGUgc2FtZSBwaWVjZSBvZiBzdGF0ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2VmZmVjdF91cGRhdGVfZGVwdGhfZXhjZWVkZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZWZmZWN0X3VwZGF0ZV9kZXB0aF9leGNlZWRlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IHVzZSBgZmx1c2hTeW5jYCBpbnNpZGUgYW4gZWZmZWN0XG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF9zeW5jX2luX2VmZmVjdCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBmbHVzaF9zeW5jX2luX2VmZmVjdFxcbkNhbm5vdCB1c2UgXFxgZmx1c2hTeW5jXFxgIGluc2lkZSBhbiBlZmZlY3RcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9mbHVzaF9zeW5jX2luX2VmZmVjdGApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9mbHVzaF9zeW5jX2luX2VmZmVjdGApO1xuXHR9XG59XG5cbi8qKlxuICogYGdldEFib3J0U2lnbmFsKClgIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYW4gZWZmZWN0IG9yIGRlcml2ZWRcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBnZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb25cXG5cXGBnZXRBYm9ydFNpZ25hbCgpXFxgIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgYW4gZWZmZWN0IG9yIGRlcml2ZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9nZXRfYWJvcnRfc2lnbmFsX291dHNpZGVfcmVhY3Rpb25gKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZ2V0X2Fib3J0X3NpZ25hbF9vdXRzaWRlX3JlYWN0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBGYWlsZWQgdG8gaHlkcmF0ZSB0aGUgYXBwbGljYXRpb25cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGlvbl9mYWlsZWQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgaHlkcmF0aW9uX2ZhaWxlZFxcbkZhaWxlZCB0byBoeWRyYXRlIHRoZSBhcHBsaWNhdGlvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9mYWlsZWRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2ZhaWxlZGApO1xuXHR9XG59XG5cbi8qKlxuICogQ291bGQgbm90IGB7QHJlbmRlcn1gIHNuaXBwZXQgZHVlIHRvIHRoZSBleHByZXNzaW9uIGJlaW5nIGBudWxsYCBvciBgdW5kZWZpbmVkYC4gQ29uc2lkZXIgdXNpbmcgb3B0aW9uYWwgY2hhaW5pbmcgYHtAcmVuZGVyIHNuaXBwZXQ/LigpfWBcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRfc25pcHBldCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBpbnZhbGlkX3NuaXBwZXRcXG5Db3VsZCBub3QgXFxge0ByZW5kZXJ9XFxgIHNuaXBwZXQgZHVlIHRvIHRoZSBleHByZXNzaW9uIGJlaW5nIFxcYG51bGxcXGAgb3IgXFxgdW5kZWZpbmVkXFxgLiBDb25zaWRlciB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBcXGB7QHJlbmRlciBzbmlwcGV0Py4oKX1cXGBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9pbnZhbGlkX3NuaXBwZXRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9zbmlwcGV0YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJW5hbWUlKC4uLilgIGNhbm5vdCBiZSB1c2VkIGluIHJ1bmVzIG1vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmV2ZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaWZlY3ljbGVfbGVnYWN5X29ubHkobmFtZSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYGxpZmVjeWNsZV9sZWdhY3lfb25seVxcblxcYCR7bmFtZX0oLi4uKVxcYCBjYW5ub3QgYmUgdXNlZCBpbiBydW5lcyBtb2RlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2xlZ2FjeV9vbmx5YCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xpZmVjeWNsZV9sZWdhY3lfb25seWApO1xuXHR9XG59XG5cbi8qKlxuICogQ2Fubm90IGRvIGBiaW5kOiVrZXklPXt1bmRlZmluZWR9YCB3aGVuIGAla2V5JWAgaGFzIGEgZmFsbGJhY2sgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BzX2ludmFsaWRfdmFsdWUoa2V5KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcHJvcHNfaW52YWxpZF92YWx1ZVxcbkNhbm5vdCBkbyBcXGBiaW5kOiR7a2V5fT17dW5kZWZpbmVkfVxcYCB3aGVuIFxcYCR7a2V5fVxcYCBoYXMgYSBmYWxsYmFjayB2YWx1ZVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX2ludmFsaWRfdmFsdWVgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfaW52YWxpZF92YWx1ZWApO1xuXHR9XG59XG5cbi8qKlxuICogUmVzdCBlbGVtZW50IHByb3BlcnRpZXMgb2YgYCRwcm9wcygpYCBzdWNoIGFzIGAlcHJvcGVydHklYCBhcmUgcmVhZG9ubHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcHNfcmVzdF9yZWFkb25seShwcm9wZXJ0eSkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHByb3BzX3Jlc3RfcmVhZG9ubHlcXG5SZXN0IGVsZW1lbnQgcHJvcGVydGllcyBvZiBcXGAkcHJvcHMoKVxcYCBzdWNoIGFzIFxcYCR7cHJvcGVydHl9XFxgIGFyZSByZWFkb25seVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3Byb3BzX3Jlc3RfcmVhZG9ubHlgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvcHJvcHNfcmVzdF9yZWFkb25seWApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGAlcnVuZSVgIHJ1bmUgaXMgb25seSBhdmFpbGFibGUgaW5zaWRlIGAuc3ZlbHRlYCBhbmQgYC5zdmVsdGUuanMvdHNgIGZpbGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gcnVuZVxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVuZV9vdXRzaWRlX3N2ZWx0ZShydW5lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgcnVuZV9vdXRzaWRlX3N2ZWx0ZVxcblRoZSBcXGAke3J1bmV9XFxgIHJ1bmUgaXMgb25seSBhdmFpbGFibGUgaW5zaWRlIFxcYC5zdmVsdGVcXGAgYW5kIFxcYC5zdmVsdGUuanMvdHNcXGAgZmlsZXNcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9ydW5lX291dHNpZGVfc3ZlbHRlYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3J1bmVfb3V0c2lkZV9zdmVsdGVgKTtcblx0fVxufVxuXG4vKipcbiAqIGBzZXRDb250ZXh0YCBtdXN0IGJlIGNhbGxlZCB3aGVuIGEgY29tcG9uZW50IGZpcnN0IGluaXRpYWxpemVzLCBub3QgaW4gYSBzdWJzZXF1ZW50IGVmZmVjdCBvciBhZnRlciBhbiBgYXdhaXRgIGV4cHJlc3Npb25cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jb250ZXh0X2FmdGVyX2luaXQoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdFxcblxcYHNldENvbnRleHRcXGAgbXVzdCBiZSBjYWxsZWQgd2hlbiBhIGNvbXBvbmVudCBmaXJzdCBpbml0aWFsaXplcywgbm90IGluIGEgc3Vic2VxdWVudCBlZmZlY3Qgb3IgYWZ0ZXIgYW4gXFxgYXdhaXRcXGAgZXhwcmVzc2lvblxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3NldF9jb250ZXh0X2FmdGVyX2luaXRgKTtcblxuXHRcdGVycm9yLm5hbWUgPSAnU3ZlbHRlIGVycm9yJztcblxuXHRcdHRocm93IGVycm9yO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdGApO1xuXHR9XG59XG5cbi8qKlxuICogUHJvcGVydHkgZGVzY3JpcHRvcnMgZGVmaW5lZCBvbiBgJHN0YXRlYCBvYmplY3RzIG11c3QgY29udGFpbiBgdmFsdWVgIGFuZCBhbHdheXMgYmUgYGVudW1lcmFibGVgLCBgY29uZmlndXJhYmxlYCBhbmQgYHdyaXRhYmxlYC5cbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkKCkge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYHN0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkXFxuUHJvcGVydHkgZGVzY3JpcHRvcnMgZGVmaW5lZCBvbiBcXGAkc3RhdGVcXGAgb2JqZWN0cyBtdXN0IGNvbnRhaW4gXFxgdmFsdWVcXGAgYW5kIGFsd2F5cyBiZSBcXGBlbnVtZXJhYmxlXFxgLCBcXGBjb25maWd1cmFibGVcXGAgYW5kIFxcYHdyaXRhYmxlXFxgLlxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX2Rlc2NyaXB0b3JzX2ZpeGVkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDYW5ub3Qgc2V0IHByb3RvdHlwZSBvZiBgJHN0YXRlYCBvYmplY3RcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Byb3RvdHlwZV9maXhlZCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV9wcm90b3R5cGVfZml4ZWRcXG5DYW5ub3Qgc2V0IHByb3RvdHlwZSBvZiBcXGAkc3RhdGVcXGAgb2JqZWN0XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc3RhdGVfcHJvdG90eXBlX2ZpeGVkYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Byb3RvdHlwZV9maXhlZGApO1xuXHR9XG59XG5cbi8qKlxuICogVXBkYXRpbmcgc3RhdGUgaW5zaWRlIGAkZGVyaXZlZCguLi4pYCwgYCRpbnNwZWN0KC4uLilgIG9yIGEgdGVtcGxhdGUgZXhwcmVzc2lvbiBpcyBmb3JiaWRkZW4uIElmIHRoZSB2YWx1ZSBzaG91bGQgbm90IGJlIHJlYWN0aXZlLCBkZWNsYXJlIGl0IHdpdGhvdXQgYCRzdGF0ZWBcbiAqIEByZXR1cm5zIHtuZXZlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3Vuc2FmZV9tdXRhdGlvbigpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBzdGF0ZV91bnNhZmVfbXV0YXRpb25cXG5VcGRhdGluZyBzdGF0ZSBpbnNpZGUgXFxgJGRlcml2ZWQoLi4uKVxcYCwgXFxgJGluc3BlY3QoLi4uKVxcYCBvciBhIHRlbXBsYXRlIGV4cHJlc3Npb24gaXMgZm9yYmlkZGVuLiBJZiB0aGUgdmFsdWUgc2hvdWxkIG5vdCBiZSByZWFjdGl2ZSwgZGVjbGFyZSBpdCB3aXRob3V0IFxcYCRzdGF0ZVxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3Vuc2FmZV9tdXRhdGlvbmApO1xuXG5cdFx0ZXJyb3IubmFtZSA9ICdTdmVsdGUgZXJyb3InO1xuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV91bnNhZmVfbXV0YXRpb25gKTtcblx0fVxufVxuXG4vKipcbiAqIEEgYDxzdmVsdGU6Ym91bmRhcnk+YCBgcmVzZXRgIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgd2hpbGUgYW4gZXJyb3IgaXMgc3RpbGwgYmVpbmcgaGFuZGxlZFxuICogQHJldHVybnMge25ldmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3IoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3JcXG5BIFxcYDxzdmVsdGU6Ym91bmRhcnk+XFxgIFxcYHJlc2V0XFxgIGZ1bmN0aW9uIGNhbm5vdCBiZSBjYWxsZWQgd2hpbGUgYW4gZXJyb3IgaXMgc3RpbGwgYmVpbmcgaGFuZGxlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9ib3VuZGFyeV9yZXNldF9vbmVycm9yYCk7XG5cblx0XHRlcnJvci5uYW1lID0gJ1N2ZWx0ZSBlcnJvcic7XG5cblx0XHR0aHJvdyBlcnJvcjtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9ib3VuZGFyeV9yZXNldF9vbmVycm9yYCk7XG5cdH1cbn0iLCAiLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBzY3JpcHRzL3Byb2Nlc3MtbWVzc2FnZXMvaW5kZXguanMuIERvIG5vdCBlZGl0ISAqL1xuXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxudmFyIGJvbGQgPSAnZm9udC13ZWlnaHQ6IGJvbGQnO1xudmFyIG5vcm1hbCA9ICdmb250LXdlaWdodDogbm9ybWFsJztcblxuLyoqXG4gKiBBc3NpZ25tZW50IHRvIGAlcHJvcGVydHklYCBwcm9wZXJ0eSAoJWxvY2F0aW9uJSkgd2lsbCBldmFsdWF0ZSB0byB0aGUgcmlnaHQtaGFuZCBzaWRlLCBub3QgdGhlIHZhbHVlIG9mIGAlcHJvcGVydHklYCBmb2xsb3dpbmcgdGhlIGFzc2lnbm1lbnQuIFRoaXMgbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW91ci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25tZW50X3ZhbHVlX3N0YWxlKHByb3BlcnR5LCBsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGFzc2lnbm1lbnRfdmFsdWVfc3RhbGVcXG4lY0Fzc2lnbm1lbnQgdG8gXFxgJHtwcm9wZXJ0eX1cXGAgcHJvcGVydHkgKCR7bG9jYXRpb259KSB3aWxsIGV2YWx1YXRlIHRvIHRoZSByaWdodC1oYW5kIHNpZGUsIG5vdCB0aGUgdmFsdWUgb2YgXFxgJHtwcm9wZXJ0eX1cXGAgZm9sbG93aW5nIHRoZSBhc3NpZ25tZW50LiBUaGlzIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvdXIuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXNzaWdubWVudF92YWx1ZV9zdGFsZWAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9hc3NpZ25tZW50X3ZhbHVlX3N0YWxlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBEZXRlY3RlZCByZWFjdGl2aXR5IGxvc3Mgd2hlbiByZWFkaW5nIGAlbmFtZSVgLiBUaGlzIGhhcHBlbnMgd2hlbiBzdGF0ZSBpcyByZWFkIGluIGFuIGFzeW5jIGZ1bmN0aW9uIGFmdGVyIGFuIGVhcmxpZXIgYGF3YWl0YFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF3YWl0X3JlYWN0aXZpdHlfbG9zcyhuYW1lKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gYXdhaXRfcmVhY3Rpdml0eV9sb3NzXFxuJWNEZXRlY3RlZCByZWFjdGl2aXR5IGxvc3Mgd2hlbiByZWFkaW5nIFxcYCR7bmFtZX1cXGAuIFRoaXMgaGFwcGVucyB3aGVuIHN0YXRlIGlzIHJlYWQgaW4gYW4gYXN5bmMgZnVuY3Rpb24gYWZ0ZXIgYW4gZWFybGllciBcXGBhd2FpdFxcYFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2F3YWl0X3JlYWN0aXZpdHlfbG9zc2AsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9hd2FpdF9yZWFjdGl2aXR5X2xvc3NgKTtcblx0fVxufVxuXG4vKipcbiAqIEFuIGFzeW5jIGRlcml2ZWQsIGAlbmFtZSVgICglbG9jYXRpb24lKSB3YXMgbm90IHJlYWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgcmVzb2x2ZWQuIFRoaXMgb2Z0ZW4gaW5kaWNhdGVzIGFuIHVubmVjZXNzYXJ5IHdhdGVyZmFsbCwgd2hpY2ggY2FuIHNsb3cgZG93biB5b3VyIGFwcFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRfd2F0ZXJmYWxsKG5hbWUsIGxvY2F0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gYXdhaXRfd2F0ZXJmYWxsXFxuJWNBbiBhc3luYyBkZXJpdmVkLCBcXGAke25hbWV9XFxgICgke2xvY2F0aW9ufSkgd2FzIG5vdCByZWFkIGltbWVkaWF0ZWx5IGFmdGVyIGl0IHJlc29sdmVkLiBUaGlzIG9mdGVuIGluZGljYXRlcyBhbiB1bm5lY2Vzc2FyeSB3YXRlcmZhbGwsIHdoaWNoIGNhbiBzbG93IGRvd24geW91ciBhcHBcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9hd2FpdF93YXRlcmZhbGxgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYXdhaXRfd2F0ZXJmYWxsYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBgJWJpbmRpbmclYCAoJWxvY2F0aW9uJSkgaXMgYmluZGluZyB0byBhIG5vbi1yZWFjdGl2ZSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2xvY2F0aW9uXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmUoYmluZGluZywgbG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGAlY1tzdmVsdGVdIGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlXFxuJWMke2xvY2F0aW9uXG5cdFx0XHRcdD8gYFxcYCR7YmluZGluZ31cXGAgKCR7bG9jYXRpb259KSBpcyBiaW5kaW5nIHRvIGEgbm9uLXJlYWN0aXZlIHByb3BlcnR5YFxuXHRcdFx0XHQ6IGBcXGAke2JpbmRpbmd9XFxgIGlzIGJpbmRpbmcgdG8gYSBub24tcmVhY3RpdmUgcHJvcGVydHlgfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2JpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCxcblx0XHRcdGJvbGQsXG5cdFx0XHRub3JtYWxcblx0XHQpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgKTtcblx0fVxufVxuXG4vKipcbiAqIFlvdXIgYGNvbnNvbGUuJW1ldGhvZCVgIGNvbnRhaW5lZCBgJHN0YXRlYCBwcm94aWVzLiBDb25zaWRlciB1c2luZyBgJGluc3BlY3QoLi4uKWAgb3IgYCRzdGF0ZS5zbmFwc2hvdCguLi4pYCBpbnN0ZWFkXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zb2xlX2xvZ19zdGF0ZShtZXRob2QpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBjb25zb2xlX2xvZ19zdGF0ZVxcbiVjWW91ciBcXGBjb25zb2xlLiR7bWV0aG9kfVxcYCBjb250YWluZWQgXFxgJHN0YXRlXFxgIHByb3hpZXMuIENvbnNpZGVyIHVzaW5nIFxcYCRpbnNwZWN0KC4uLilcXGAgb3IgXFxgJHN0YXRlLnNuYXBzaG90KC4uLilcXGAgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbnNvbGVfbG9nX3N0YXRlYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2NvbnNvbGVfbG9nX3N0YXRlYCk7XG5cdH1cbn1cblxuLyoqXG4gKiAlaGFuZGxlciUgc2hvdWxkIGJlIGEgZnVuY3Rpb24uIERpZCB5b3UgbWVhbiB0byAlc3VnZ2VzdGlvbiU/XG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlclxuICogQHBhcmFtIHtzdHJpbmd9IHN1Z2dlc3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50X2hhbmRsZXJfaW52YWxpZChoYW5kbGVyLCBzdWdnZXN0aW9uKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gZXZlbnRfaGFuZGxlcl9pbnZhbGlkXFxuJWMke2hhbmRsZXJ9IHNob3VsZCBiZSBhIGZ1bmN0aW9uLiBEaWQgeW91IG1lYW4gdG8gJHtzdWdnZXN0aW9ufT9cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9ldmVudF9oYW5kbGVyX2ludmFsaWRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZXZlbnRfaGFuZGxlcl9pbnZhbGlkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYCVhdHRyaWJ1dGUlYCBhdHRyaWJ1dGUgb24gYCVodG1sJWAgY2hhbmdlZCBpdHMgdmFsdWUgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlLCBgJXZhbHVlJWAsIHdpbGwgYmUgaWdub3JlZCBpbiBmYXZvdXIgb2YgdGhlIHNlcnZlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkKGF0dHJpYnV0ZSwgaHRtbCwgdmFsdWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBoeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWRcXG4lY1RoZSBcXGAke2F0dHJpYnV0ZX1cXGAgYXR0cmlidXRlIG9uIFxcYCR7aHRtbH1cXGAgY2hhbmdlZCBpdHMgdmFsdWUgYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCByZW5kZXJzLiBUaGUgY2xpZW50IHZhbHVlLCBcXGAke3ZhbHVlfVxcYCwgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaHlkcmF0aW9uX2F0dHJpYnV0ZV9jaGFuZ2VkYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9hdHRyaWJ1dGVfY2hhbmdlZGApO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHZhbHVlIG9mIGFuIGB7QGh0bWwgLi4ufWAgYmxvY2sgJWxvY2F0aW9uJSBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbH0gW2xvY2F0aW9uXVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0aW9uX2h0bWxfY2hhbmdlZChsb2NhdGlvbikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0YCVjW3N2ZWx0ZV0gaHlkcmF0aW9uX2h0bWxfY2hhbmdlZFxcbiVjJHtsb2NhdGlvblxuXHRcdFx0XHQ/IGBUaGUgdmFsdWUgb2YgYW4gXFxge0BodG1sIC4uLn1cXGAgYmxvY2sgJHtsb2NhdGlvbn0gY2hhbmdlZCBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50IHJlbmRlcnMuIFRoZSBjbGllbnQgdmFsdWUgd2lsbCBiZSBpZ25vcmVkIGluIGZhdm91ciBvZiB0aGUgc2VydmVyIHZhbHVlYFxuXHRcdFx0XHQ6ICdUaGUgdmFsdWUgb2YgYW4gYHtAaHRtbCAuLi59YCBibG9jayBjaGFuZ2VkIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgcmVuZGVycy4gVGhlIGNsaWVudCB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaW4gZmF2b3VyIG9mIHRoZSBzZXJ2ZXIgdmFsdWUnfVxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL2h5ZHJhdGlvbl9odG1sX2NoYW5nZWRgLFxuXHRcdFx0Ym9sZCxcblx0XHRcdG5vcm1hbFxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25faHRtbF9jaGFuZ2VkYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci4gVGhlIGVycm9yIG9jY3VycmVkIG5lYXIgJWxvY2F0aW9uJVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbbG9jYXRpb25dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRpb25fbWlzbWF0Y2gobG9jYXRpb24pIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGAlY1tzdmVsdGVdIGh5ZHJhdGlvbl9taXNtYXRjaFxcbiVjJHtsb2NhdGlvblxuXHRcdFx0XHQ/IGBIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIGluaXRpYWwgVUkgZG9lcyBub3QgbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci4gVGhlIGVycm9yIG9jY3VycmVkIG5lYXIgJHtsb2NhdGlvbn1gXG5cdFx0XHRcdDogJ0h5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgaW5pdGlhbCBVSSBkb2VzIG5vdCBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyJ31cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fbWlzbWF0Y2hgLFxuXHRcdFx0Ym9sZCxcblx0XHRcdG5vcm1hbFxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9oeWRyYXRpb25fbWlzbWF0Y2hgKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSBgcmVuZGVyYCBmdW5jdGlvbiBwYXNzZWQgdG8gYGNyZWF0ZVJhd1NuaXBwZXRgIHNob3VsZCByZXR1cm4gSFRNTCBmb3IgYSBzaW5nbGUgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJcXG4lY1RoZSBcXGByZW5kZXJcXGAgZnVuY3Rpb24gcGFzc2VkIHRvIFxcYGNyZWF0ZVJhd1NuaXBwZXRcXGAgc2hvdWxkIHJldHVybiBIVE1MIGZvciBhIHNpbmdsZSBlbGVtZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXJgKTtcblx0fVxufVxuXG4vKipcbiAqIERldGVjdGVkIGEgbWlncmF0ZWQgYCQ6YCByZWFjdGl2ZSBibG9jayBpbiBgJWZpbGVuYW1lJWAgdGhhdCBib3RoIGFjY2Vzc2VzIGFuZCB1cGRhdGVzIHRoZSBzYW1lIHJlYWN0aXZlIHZhbHVlLiBUaGlzIG1heSBjYXVzZSByZWN1cnNpdmUgdXBkYXRlcyB3aGVuIGNvbnZlcnRlZCB0byBhbiBgJGVmZmVjdGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2soZmlsZW5hbWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBsZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrXFxuJWNEZXRlY3RlZCBhIG1pZ3JhdGVkIFxcYCQ6XFxgIHJlYWN0aXZlIGJsb2NrIGluIFxcYCR7ZmlsZW5hbWV9XFxgIHRoYXQgYm90aCBhY2Nlc3NlcyBhbmQgdXBkYXRlcyB0aGUgc2FtZSByZWFjdGl2ZSB2YWx1ZS4gVGhpcyBtYXkgY2F1c2UgcmVjdXJzaXZlIHVwZGF0ZXMgd2hlbiBjb252ZXJ0ZWQgdG8gYW4gXFxgJGVmZmVjdFxcYC5cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9sZWdhY3lfcmVjdXJzaXZlX3JlYWN0aXZlX2Jsb2NrYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL2xlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2tgKTtcblx0fVxufVxuXG4vKipcbiAqIFRyaWVkIHRvIHVubW91bnQgYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IG1vdW50ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBsaWZlY3ljbGVfZG91YmxlX3VubW91bnRcXG4lY1RyaWVkIHRvIHVubW91bnQgYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IG1vdW50ZWRcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9saWZlY3ljbGVfZG91YmxlX3VubW91bnRgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2UvbGlmZWN5Y2xlX2RvdWJsZV91bm1vdW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiAlcGFyZW50JSBwYXNzZWQgcHJvcGVydHkgYCVwcm9wJWAgdG8gJWNoaWxkJSB3aXRoIGBiaW5kOmAsIGJ1dCBpdHMgcGFyZW50IGNvbXBvbmVudCAlb3duZXIlIGRpZCBub3QgZGVjbGFyZSBgJXByb3AlYCBhcyBhIGJpbmRpbmcuIENvbnNpZGVyIGNyZWF0aW5nIGEgYmluZGluZyBiZXR3ZWVuICVvd25lciUgYW5kICVwYXJlbnQlIChlLmcuIGBiaW5kOiVwcm9wJT17Li4ufWAgaW5zdGVhZCBvZiBgJXByb3AlPXsuLi59YClcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvd25lclxuICovXG5leHBvcnQgZnVuY3Rpb24gb3duZXJzaGlwX2ludmFsaWRfYmluZGluZyhwYXJlbnQsIHByb3AsIGNoaWxkLCBvd25lcikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIG93bmVyc2hpcF9pbnZhbGlkX2JpbmRpbmdcXG4lYyR7cGFyZW50fSBwYXNzZWQgcHJvcGVydHkgXFxgJHtwcm9wfVxcYCB0byAke2NoaWxkfSB3aXRoIFxcYGJpbmQ6XFxgLCBidXQgaXRzIHBhcmVudCBjb21wb25lbnQgJHtvd25lcn0gZGlkIG5vdCBkZWNsYXJlIFxcYCR7cHJvcH1cXGAgYXMgYSBiaW5kaW5nLiBDb25zaWRlciBjcmVhdGluZyBhIGJpbmRpbmcgYmV0d2VlbiAke293bmVyfSBhbmQgJHtwYXJlbnR9IChlLmcuIFxcYGJpbmQ6JHtwcm9wfT17Li4ufVxcYCBpbnN0ZWFkIG9mIFxcYCR7cHJvcH09ey4uLn1cXGApXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvb3duZXJzaGlwX2ludmFsaWRfYmluZGluZ2AsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBNdXRhdGluZyB1bmJvdW5kIHByb3BzIChgJW5hbWUlYCwgYXQgJWxvY2F0aW9uJSkgaXMgc3Ryb25nbHkgZGlzY291cmFnZWQuIENvbnNpZGVyIHVzaW5nIGBiaW5kOiVwcm9wJT17Li4ufWAgaW4gJXBhcmVudCUgKG9yIHVzaW5nIGEgY2FsbGJhY2spIGluc3RlYWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvd25lcnNoaXBfaW52YWxpZF9tdXRhdGlvbihuYW1lLCBsb2NhdGlvbiwgcHJvcCwgcGFyZW50KSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gb3duZXJzaGlwX2ludmFsaWRfbXV0YXRpb25cXG4lY011dGF0aW5nIHVuYm91bmQgcHJvcHMgKFxcYCR7bmFtZX1cXGAsIGF0ICR7bG9jYXRpb259KSBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC4gQ29uc2lkZXIgdXNpbmcgXFxgYmluZDoke3Byb3B9PXsuLi59XFxgIGluICR7cGFyZW50fSAob3IgdXNpbmcgYSBjYWxsYmFjaykgaW5zdGVhZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL293bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHZhbHVlYCBwcm9wZXJ0eSBvZiBhIGA8c2VsZWN0IG11bHRpcGxlPmAgZWxlbWVudCBzaG91bGQgYmUgYW4gYXJyYXksIGJ1dCBpdCByZWNlaXZlZCBhIG5vbi1hcnJheSB2YWx1ZS4gVGhlIHNlbGVjdGlvbiB3aWxsIGJlIGtlcHQgYXMgaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RfbXVsdGlwbGVfaW52YWxpZF92YWx1ZSgpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSBzZWxlY3RfbXVsdGlwbGVfaW52YWxpZF92YWx1ZVxcbiVjVGhlIFxcYHZhbHVlXFxgIHByb3BlcnR5IG9mIGEgXFxgPHNlbGVjdCBtdWx0aXBsZT5cXGAgZWxlbWVudCBzaG91bGQgYmUgYW4gYXJyYXksIGJ1dCBpdCByZWNlaXZlZCBhIG5vbi1hcnJheSB2YWx1ZS4gVGhlIHNlbGVjdGlvbiB3aWxsIGJlIGtlcHQgYXMgaXMuXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc2VsZWN0X211bHRpcGxlX2ludmFsaWRfdmFsdWVgLCBib2xkLCBub3JtYWwpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbnNvbGUud2FybihgaHR0cHM6Ly9zdmVsdGUuZGV2L2Uvc2VsZWN0X211bHRpcGxlX2ludmFsaWRfdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIFJlYWN0aXZlIGAkc3RhdGUoLi4uKWAgcHJveGllcyBhbmQgdGhlIHZhbHVlcyB0aGV5IHByb3h5IGhhdmUgZGlmZmVyZW50IGlkZW50aXRpZXMuIEJlY2F1c2Ugb2YgdGhpcywgY29tcGFyaXNvbnMgd2l0aCBgJW9wZXJhdG9yJWAgd2lsbCBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0c1xuICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChvcGVyYXRvcikge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIHN0YXRlX3Byb3h5X2VxdWFsaXR5X21pc21hdGNoXFxuJWNSZWFjdGl2ZSBcXGAkc3RhdGUoLi4uKVxcYCBwcm94aWVzIGFuZCB0aGUgdmFsdWVzIHRoZXkgcHJveHkgaGF2ZSBkaWZmZXJlbnQgaWRlbnRpdGllcy4gQmVjYXVzZSBvZiB0aGlzLCBjb21wYXJpc29ucyB3aXRoIFxcYCR7b3BlcmF0b3J9XFxgIHdpbGwgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHNcXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaGApO1xuXHR9XG59XG5cbi8qKlxuICogQSBgPHN2ZWx0ZTpib3VuZGFyeT5gIGByZXNldGAgZnVuY3Rpb24gb25seSByZXNldHMgdGhlIGJvdW5kYXJ5IHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X25vb3AoKSB7XG5cdGlmIChERVYpIHtcblx0XHRjb25zb2xlLndhcm4oYCVjW3N2ZWx0ZV0gc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X25vb3BcXG4lY0EgXFxgPHN2ZWx0ZTpib3VuZGFyeT5cXGAgXFxgcmVzZXRcXGAgZnVuY3Rpb24gb25seSByZXNldHMgdGhlIGJvdW5kYXJ5IHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZFxcbmh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wYCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N2ZWx0ZV9ib3VuZGFyeV9yZXNldF9ub29wYCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgYHNsaWRlYCB0cmFuc2l0aW9uIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IGZvciBlbGVtZW50cyB3aXRoIGBkaXNwbGF5OiAldmFsdWUlYFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXkodmFsdWUpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2FybihgJWNbc3ZlbHRlXSB0cmFuc2l0aW9uX3NsaWRlX2Rpc3BsYXlcXG4lY1RoZSBcXGBzbGlkZVxcYCB0cmFuc2l0aW9uIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5IGZvciBlbGVtZW50cyB3aXRoIFxcYGRpc3BsYXk6ICR7dmFsdWV9XFxgXFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvdHJhbnNpdGlvbl9zbGlkZV9kaXNwbGF5YCwgYm9sZCwgbm9ybWFsKTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3RyYW5zaXRpb25fc2xpZGVfZGlzcGxheWApO1xuXHR9XG59IiwgIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cblxuaW1wb3J0IHsgQ09NTUVOVF9OT0RFIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHtcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX0VSUk9SLFxuXHRIWURSQVRJT05fU1RBUlQsXG5cdEhZRFJBVElPTl9TVEFSVF9FTFNFXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuL29wZXJhdGlvbnMuanMnO1xuXG4vKipcbiAqIFVzZSB0aGlzIHZhcmlhYmxlIHRvIGd1YXJkIGV2ZXJ5dGhpbmcgcmVsYXRlZCB0byBoeWRyYXRpb24gY29kZSBzbyBpdCBjYW4gYmUgdHJlZXNoYWtlbiBvdXRcbiAqIGlmIHRoZSB1c2VyIGRvZXNuJ3QgdXNlIHRoZSBgaHlkcmF0ZWAgbWV0aG9kIGFuZCB0aGVzZSBjb2RlIHBhdGhzIGFyZSB0aGVyZWZvcmUgbm90IG5lZWRlZC5cbiAqL1xuZXhwb3J0IGxldCBoeWRyYXRpbmcgPSBmYWxzZTtcblxuLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0aW5nKHZhbHVlKSB7XG5cdGh5ZHJhdGluZyA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSBub2RlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGh5ZHJhdGVkLiBUaGlzIHN0YXJ0cyBvdXQgYXMgdGhlIGZpcnN0IG5vZGUgaW5zaWRlIHRoZSBvcGVuaW5nXG4gKiA8IS0tWy0tPiBjb21tZW50LCBhbmQgdXBkYXRlcyBlYWNoIHRpbWUgYSBjb21wb25lbnQgY2FsbHMgYCQuY2hpbGQoLi4uKWAgb3IgYCQuc2libGluZyguLi4pYC5cbiAqIFdoZW4gZW50ZXJpbmcgYSBibG9jayAoZS5nLiBgeyNpZiAuLi59YCksIGBoeWRyYXRlX25vZGVgIGlzIHRoZSBibG9jayBvcGVuaW5nIGNvbW1lbnQ7IGJ5IHRoZVxuICogdGltZSB3ZSBsZWF2ZSB0aGUgYmxvY2sgaXQgaXMgdGhlIGNsb3NpbmcgY29tbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBibG9jaydzIGFuY2hvci5cbiAqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9XG4gKi9cbmV4cG9ydCBsZXQgaHlkcmF0ZV9ub2RlO1xuXG4vKiogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaHlkcmF0ZV9ub2RlKG5vZGUpIHtcblx0aWYgKG5vZGUgPT09IG51bGwpIHtcblx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0fVxuXG5cdHJldHVybiAoaHlkcmF0ZV9ub2RlID0gbm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX25leHQoKSB7XG5cdHJldHVybiBzZXRfaHlkcmF0ZV9ub2RlKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhoeWRyYXRlX25vZGUpKSk7XG59XG5cbi8qKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KG5vZGUpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHJldHVybjtcblxuXHQvLyBJZiB0aGUgbm9kZSBoYXMgcmVtYWluaW5nIHNpYmxpbmdzLCBzb21ldGhpbmcgaGFzIGdvbmUgd3Jvbmdcblx0aWYgKGdldF9uZXh0X3NpYmxpbmcoaHlkcmF0ZV9ub2RlKSAhPT0gbnVsbCkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlX3RlbXBsYXRlKHRlbXBsYXRlKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIFRlbXBsYXRlTm9kZSBkb2Vzbid0IGluY2x1ZGUgRG9jdW1lbnRGcmFnbWVudCwgYnV0IGl0J3MgYWN0dWFsbHkgZmluZVxuXHRcdGh5ZHJhdGVfbm9kZSA9IHRlbXBsYXRlLmNvbnRlbnQ7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHQoY291bnQgPSAxKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHR2YXIgaSA9IGNvdW50O1xuXHRcdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0fVxuXG5cdFx0aHlkcmF0ZV9ub2RlID0gbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIG5vZGVzIHN0YXJ0aW5nIGF0IGBoeWRyYXRlX25vZGVgIHVwIHVudGlsIHRoZSBuZXh0IGh5ZHJhdGlvbiBlbmQgY29tbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX25vZGVzKCkge1xuXHR2YXIgZGVwdGggPSAwO1xuXHR2YXIgbm9kZSA9IGh5ZHJhdGVfbm9kZTtcblxuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdGlmIChub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcblx0XHRcdHZhciBkYXRhID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAobm9kZSkuZGF0YTtcblxuXHRcdFx0aWYgKGRhdGEgPT09IEhZRFJBVElPTl9FTkQpIHtcblx0XHRcdFx0aWYgKGRlcHRoID09PSAwKSByZXR1cm4gbm9kZTtcblx0XHRcdFx0ZGVwdGggLT0gMTtcblx0XHRcdH0gZWxzZSBpZiAoZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUIHx8IGRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFKSB7XG5cdFx0XHRcdGRlcHRoICs9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIG5leHQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uKG5vZGUpIHtcblx0aWYgKCFub2RlIHx8IG5vZGUubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuXHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHR9XG5cblx0cmV0dXJuIC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpLmRhdGE7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFcXVhbHMgfSBmcm9tICcjY2xpZW50JyAqL1xuXG4vKiogQHR5cGUge0VxdWFsc30gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHModmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlID09PSB0aGlzLnY7XG59XG5cbi8qKlxuICogQHBhcmFtIHt1bmtub3dufSBhXG4gKiBAcGFyYW0ge3Vua25vd259IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPSBhXG5cdFx0PyBiID09IGJcblx0XHQ6IGEgIT09IGIgfHwgKGEgIT09IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGFcbiAqIEBwYXJhbSB7dW5rbm93bn0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3RfZXF1YWwoYSwgYikge1xuXHRyZXR1cm4gYSAhPT0gYjtcbn1cblxuLyoqIEB0eXBlIHtFcXVhbHN9ICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9lcXVhbHModmFsdWUpIHtcblx0cmV0dXJuICFzYWZlX25vdF9lcXVhbCh2YWx1ZSwgdGhpcy52KTtcbn1cbiIsICJleHBvcnQgbGV0IGFzeW5jX21vZGVfZmxhZyA9IGZhbHNlO1xuZXhwb3J0IGxldCBsZWdhY3lfbW9kZV9mbGFnID0gZmFsc2U7XG5leHBvcnQgbGV0IHRyYWNpbmdfbW9kZV9mbGFnID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVfYXN5bmNfbW9kZV9mbGFnKCkge1xuXHRhc3luY19tb2RlX2ZsYWcgPSB0cnVlO1xufVxuXG4vKiogT05MWSBVU0UgVEhJUyBEVVJJTkcgVEVTVElORyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVfYXN5bmNfbW9kZV9mbGFnKCkge1xuXHRhc3luY19tb2RlX2ZsYWcgPSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZV9sZWdhY3lfbW9kZV9mbGFnKCkge1xuXHRsZWdhY3lfbW9kZV9mbGFnID0gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZV90cmFjaW5nX21vZGVfZmxhZygpIHtcblx0dHJhY2luZ19tb2RlX2ZsYWcgPSB0cnVlO1xufVxuIiwgIi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgc2NyaXB0cy9wcm9jZXNzLW1lc3NhZ2VzL2luZGV4LmpzLiBEbyBub3QgZWRpdCEgKi9cblxuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5cbnZhciBib2xkID0gJ2ZvbnQtd2VpZ2h0OiBib2xkJztcbnZhciBub3JtYWwgPSAnZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cbi8qKlxuICogYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJXRhZyVcIj5gIGlzIGEgdm9pZCBlbGVtZW50IFx1MjAxNCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkeW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50KHRhZykge1xuXHRpZiAoREVWKSB7XG5cdFx0Y29uc29sZS53YXJuKGAlY1tzdmVsdGVdIGR5bmFtaWNfdm9pZF9lbGVtZW50X2NvbnRlbnRcXG4lY1xcYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+XFxgIGlzIGEgdm9pZCBlbGVtZW50IFx1MjAxNCBpdCBjYW5ub3QgaGF2ZSBjb250ZW50XFxuaHR0cHM6Ly9zdmVsdGUuZGV2L2UvZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudGAsIGJvbGQsIG5vcm1hbCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc29sZS53YXJuKGBodHRwczovL3N2ZWx0ZS5kZXYvZS9keW5hbWljX3ZvaWRfZWxlbWVudF9jb250ZW50YCk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIFx1MjAxNCB0aGUgcmV0dXJuIHZhbHVlIGNvbnRhaW5zIHRoZSBvcmlnaW5hbHM6XG4gKiBcbiAqICVwcm9wZXJ0aWVzJVxuICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsfSBbcHJvcGVydGllc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHByb3BlcnRpZXMpIHtcblx0aWYgKERFVikge1xuXHRcdGNvbnNvbGUud2Fybihcblx0XHRcdGAlY1tzdmVsdGVdIHN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlXFxuJWMke3Byb3BlcnRpZXNcblx0XHRcdFx0PyBgVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBjbG9uZWQgd2l0aCBcXGAkc3RhdGUuc25hcHNob3RcXGAgXHUyMDE0IHRoZSByZXR1cm4gdmFsdWUgY29udGFpbnMgdGhlIG9yaWdpbmFsczpcblxuJHtwcm9wZXJ0aWVzfWBcblx0XHRcdFx0OiAnVmFsdWUgY2Fubm90IGJlIGNsb25lZCB3aXRoIGAkc3RhdGUuc25hcHNob3RgIFx1MjAxNCB0aGUgb3JpZ2luYWwgdmFsdWUgd2FzIHJldHVybmVkJ31cXG5odHRwczovL3N2ZWx0ZS5kZXYvZS9zdGF0ZV9zbmFwc2hvdF91bmNsb25lYWJsZWAsXG5cdFx0XHRib2xkLFxuXHRcdFx0bm9ybWFsXG5cdFx0KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLndhcm4oYGh0dHBzOi8vc3ZlbHRlLmRldi9lL3N0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlYCk7XG5cdH1cbn0iLCAiLyoqIEBpbXBvcnQgeyBTbmFwc2hvdCB9IGZyb20gJy4vdHlwZXMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBnZXRfcHJvdG90eXBlX29mLCBpc19hcnJheSwgb2JqZWN0X3Byb3RvdHlwZSB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEluIGRldiwgd2Uga2VlcCB0cmFjayBvZiB3aGljaCBwcm9wZXJ0aWVzIGNvdWxkIG5vdCBiZSBjbG9uZWQuIEluIHByb2RcbiAqIHdlIGRvbid0IGJvdGhlciwgYnV0IHdlIGtlZXAgYSBkdW1teSBhcnJheSBhcm91bmQgc28gdGhhdCB0aGVcbiAqIHNpZ25hdHVyZSBzdGF5cyB0aGUgc2FtZVxuICogQHR5cGUge3N0cmluZ1tdfVxuICovXG5jb25zdCBlbXB0eSA9IFtdO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtub190b2pzb25dXG4gKiBAcmV0dXJucyB7U25hcHNob3Q8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmFwc2hvdCh2YWx1ZSwgc2tpcF93YXJuaW5nID0gZmFsc2UsIG5vX3RvanNvbiA9IGZhbHNlKSB7XG5cdGlmIChERVYgJiYgIXNraXBfd2FybmluZykge1xuXHRcdC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG5cdFx0Y29uc3QgcGF0aHMgPSBbXTtcblxuXHRcdGNvbnN0IGNvcHkgPSBjbG9uZSh2YWx1ZSwgbmV3IE1hcCgpLCAnJywgcGF0aHMsIG51bGwsIG5vX3RvanNvbik7XG5cdFx0aWYgKHBhdGhzLmxlbmd0aCA9PT0gMSAmJiBwYXRoc1swXSA9PT0gJycpIHtcblx0XHRcdC8vIHZhbHVlIGNvdWxkIG5vdCBiZSBjbG9uZWRcblx0XHRcdHcuc3RhdGVfc25hcHNob3RfdW5jbG9uZWFibGUoKTtcblx0XHR9IGVsc2UgaWYgKHBhdGhzLmxlbmd0aCA+IDApIHtcblx0XHRcdC8vIHNvbWUgcHJvcGVydGllcyBjb3VsZCBub3QgYmUgY2xvbmVkXG5cdFx0XHRjb25zdCBzbGljZSA9IHBhdGhzLmxlbmd0aCA+IDEwID8gcGF0aHMuc2xpY2UoMCwgNykgOiBwYXRocy5zbGljZSgwLCAxMCk7XG5cdFx0XHRjb25zdCBleGNlc3MgPSBwYXRocy5sZW5ndGggLSBzbGljZS5sZW5ndGg7XG5cblx0XHRcdGxldCB1bmNsb25lZCA9IHNsaWNlLm1hcCgocGF0aCkgPT4gYC0gPHZhbHVlPiR7cGF0aH1gKS5qb2luKCdcXG4nKTtcblx0XHRcdGlmIChleGNlc3MgPiAwKSB1bmNsb25lZCArPSBgXFxuLSAuLi5hbmQgJHtleGNlc3N9IG1vcmVgO1xuXG5cdFx0XHR3LnN0YXRlX3NuYXBzaG90X3VuY2xvbmVhYmxlKHVuY2xvbmVkKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29weTtcblx0fVxuXG5cdHJldHVybiBjbG9uZSh2YWx1ZSwgbmV3IE1hcCgpLCAnJywgZW1wdHksIG51bGwsIG5vX3RvanNvbik7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gdmFsdWVcbiAqIEBwYXJhbSB7TWFwPFQsIFNuYXBzaG90PFQ+Pn0gY2xvbmVkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHNcbiAqIEBwYXJhbSB7bnVsbCB8IFR9IFtvcmlnaW5hbF0gVGhlIG9yaWdpbmFsIHZhbHVlLCBpZiBgdmFsdWVgIHdhcyBwcm9kdWNlZCBmcm9tIGEgYHRvSlNPTmAgY2FsbFxuICogQHBhcmFtIHtib29sZWFufSBbbm9fdG9qc29uXVxuICogQHJldHVybnMge1NuYXBzaG90PFQ+fVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSwgY2xvbmVkLCBwYXRoLCBwYXRocywgb3JpZ2luYWwgPSBudWxsLCBub190b2pzb24gPSBmYWxzZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdHZhciB1bndyYXBwZWQgPSBjbG9uZWQuZ2V0KHZhbHVlKTtcblx0XHRpZiAodW53cmFwcGVkICE9PSB1bmRlZmluZWQpIHJldHVybiB1bndyYXBwZWQ7XG5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAobmV3IE1hcCh2YWx1ZSkpO1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkgcmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovIChuZXcgU2V0KHZhbHVlKSk7XG5cblx0XHRpZiAoaXNfYXJyYXkodmFsdWUpKSB7XG5cdFx0XHR2YXIgY29weSA9IC8qKiBAdHlwZSB7U25hcHNob3Q8YW55Pn0gKi8gKEFycmF5KHZhbHVlLmxlbmd0aCkpO1xuXHRcdFx0Y2xvbmVkLnNldCh2YWx1ZSwgY29weSk7XG5cblx0XHRcdGlmIChvcmlnaW5hbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRjbG9uZWQuc2V0KG9yaWdpbmFsLCBjb3B5KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHZhbHVlW2ldO1xuXHRcdFx0XHRpZiAoaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGNvcHlbaV0gPSBjbG9uZShlbGVtZW50LCBjbG9uZWQsIERFViA/IGAke3BhdGh9WyR7aX1dYCA6IHBhdGgsIHBhdGhzLCBudWxsLCBub190b2pzb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBjb3B5O1xuXHRcdH1cblxuXHRcdGlmIChnZXRfcHJvdG90eXBlX29mKHZhbHVlKSA9PT0gb2JqZWN0X3Byb3RvdHlwZSkge1xuXHRcdFx0LyoqIEB0eXBlIHtTbmFwc2hvdDxhbnk+fSAqL1xuXHRcdFx0Y29weSA9IHt9O1xuXHRcdFx0Y2xvbmVkLnNldCh2YWx1ZSwgY29weSk7XG5cblx0XHRcdGlmIChvcmlnaW5hbCAhPT0gbnVsbCkge1xuXHRcdFx0XHRjbG9uZWQuc2V0KG9yaWdpbmFsLCBjb3B5KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRcdGNvcHlba2V5XSA9IGNsb25lKFxuXHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHR2YWx1ZVtrZXldLFxuXHRcdFx0XHRcdGNsb25lZCxcblx0XHRcdFx0XHRERVYgPyBgJHtwYXRofS4ke2tleX1gIDogcGF0aCxcblx0XHRcdFx0XHRwYXRocyxcblx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdG5vX3RvanNvblxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY29weTtcblx0XHR9XG5cblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtTbmFwc2hvdDxUPn0gKi8gKHN0cnVjdHVyZWRDbG9uZSh2YWx1ZSkpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgKC8qKiBAdHlwZSB7VCAmIHsgdG9KU09OPzogYW55IH0gfSAqLyAodmFsdWUpLnRvSlNPTikgPT09ICdmdW5jdGlvbicgJiYgIW5vX3RvanNvbikge1xuXHRcdFx0cmV0dXJuIGNsb25lKFxuXHRcdFx0XHQvKiogQHR5cGUge1QgJiB7IHRvSlNPTigpOiBhbnkgfSB9ICovICh2YWx1ZSkudG9KU09OKCksXG5cdFx0XHRcdGNsb25lZCxcblx0XHRcdFx0REVWID8gYCR7cGF0aH0udG9KU09OKClgIDogcGF0aCxcblx0XHRcdFx0cGF0aHMsXG5cdFx0XHRcdC8vIEFzc29jaWF0ZSB0aGUgaW5zdGFuY2Ugd2l0aCB0aGUgdG9KU09OIGNsb25lXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0Ly8gY2FuJ3QgYmUgY2xvbmVkXG5cdFx0cmV0dXJuIC8qKiBAdHlwZSB7U25hcHNob3Q8VD59ICovICh2YWx1ZSk7XG5cdH1cblxuXHR0cnkge1xuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAoc3RydWN0dXJlZENsb25lKHZhbHVlKSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAoREVWKSB7XG5cdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdH1cblxuXHRcdHJldHVybiAvKiogQHR5cGUge1NuYXBzaG90PFQ+fSAqLyAodmFsdWUpO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBSZWFjdGlvbiwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBzbmFwc2hvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jbG9uZS5qcyc7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHkgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgREVSSVZFRCwgQVNZTkMsIFBST1hZX1BBVEhfU1lNQk9MLCBTVEFURV9TWU1CT0wgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBlZmZlY3RfdHJhY2tpbmcgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgYWN0aXZlX3JlYWN0aW9uLCB1bnRyYWNrIH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdHJhY2VzOiBFcnJvcltdO1xuICogfX0gVHJhY2VFbnRyeVxuICovXG5cbi8qKiBAdHlwZSB7eyByZWFjdGlvbjogUmVhY3Rpb24gfCBudWxsLCBlbnRyaWVzOiBNYXA8VmFsdWUsIFRyYWNlRW50cnk+IH0gfCBudWxsfSAqL1xuZXhwb3J0IGxldCB0cmFjaW5nX2V4cHJlc3Npb25zID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEBwYXJhbSB7VHJhY2VFbnRyeX0gW2VudHJ5XVxuICovXG5mdW5jdGlvbiBsb2dfZW50cnkoc2lnbmFsLCBlbnRyeSkge1xuXHRjb25zdCB2YWx1ZSA9IHNpZ25hbC52O1xuXG5cdGlmICh2YWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IHR5cGUgPSBnZXRfdHlwZShzaWduYWwpO1xuXHRjb25zdCBjdXJyZW50X3JlYWN0aW9uID0gLyoqIEB0eXBlIHtSZWFjdGlvbn0gKi8gKGFjdGl2ZV9yZWFjdGlvbik7XG5cdGNvbnN0IGRpcnR5ID0gc2lnbmFsLnd2ID4gY3VycmVudF9yZWFjdGlvbi53diB8fCBjdXJyZW50X3JlYWN0aW9uLnd2ID09PSAwO1xuXHRjb25zdCBzdHlsZSA9IGRpcnR5XG5cdFx0PyAnY29sb3I6IENvcm5mbG93ZXJCbHVlOyBmb250LXdlaWdodDogYm9sZCdcblx0XHQ6ICdjb2xvcjogZ3JleTsgZm9udC13ZWlnaHQ6IG5vcm1hbCc7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5ncm91cENvbGxhcHNlZChcblx0XHRzaWduYWwubGFiZWwgPyBgJWMke3R5cGV9JWMgJHtzaWduYWwubGFiZWx9YCA6IGAlYyR7dHlwZX0lY2AsXG5cdFx0c3R5bGUsXG5cdFx0ZGlydHkgPyAnZm9udC13ZWlnaHQ6IG5vcm1hbCcgOiBzdHlsZSxcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIFNUQVRFX1NZTUJPTCBpbiB2YWx1ZVxuXHRcdFx0PyBzbmFwc2hvdCh2YWx1ZSwgdHJ1ZSlcblx0XHRcdDogdmFsdWVcblx0KTtcblxuXHRpZiAodHlwZSA9PT0gJyRkZXJpdmVkJykge1xuXHRcdGNvbnN0IGRlcHMgPSBuZXcgU2V0KC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCkuZGVwcyk7XG5cdFx0Zm9yIChjb25zdCBkZXAgb2YgZGVwcykge1xuXHRcdFx0bG9nX2VudHJ5KGRlcCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKHNpZ25hbC5jcmVhdGVkKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRjb25zb2xlLmxvZyhzaWduYWwuY3JlYXRlZCk7XG5cdH1cblxuXHRpZiAoZGlydHkgJiYgc2lnbmFsLnVwZGF0ZWQpIHtcblx0XHRmb3IgKGNvbnN0IHVwZGF0ZWQgb2Ygc2lnbmFsLnVwZGF0ZWQudmFsdWVzKCkpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmxvZyh1cGRhdGVkLmVycm9yKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoZW50cnkpIHtcblx0XHRmb3IgKHZhciB0cmFjZSBvZiBlbnRyeS50cmFjZXMpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmxvZyh0cmFjZSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0Y29uc29sZS5ncm91cEVuZCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNpZ25hbFxuICogQHJldHVybnMgeyckc3RhdGUnIHwgJyRkZXJpdmVkJyB8ICdzdG9yZSd9XG4gKi9cbmZ1bmN0aW9uIGdldF90eXBlKHNpZ25hbCkge1xuXHRpZiAoKHNpZ25hbC5mICYgKERFUklWRUQgfCBBU1lOQykpICE9PSAwKSByZXR1cm4gJyRkZXJpdmVkJztcblx0cmV0dXJuIHNpZ25hbC5sYWJlbD8uc3RhcnRzV2l0aCgnJCcpID8gJ3N0b3JlJyA6ICckc3RhdGUnO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IHN0cmluZ30gbGFiZWxcbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNlKGxhYmVsLCBmbikge1xuXHR2YXIgcHJldmlvdXNseV90cmFjaW5nX2V4cHJlc3Npb25zID0gdHJhY2luZ19leHByZXNzaW9ucztcblxuXHR0cnkge1xuXHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMgPSB7IGVudHJpZXM6IG5ldyBNYXAoKSwgcmVhY3Rpb246IGFjdGl2ZV9yZWFjdGlvbiB9O1xuXG5cdFx0dmFyIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0dmFyIHZhbHVlID0gZm4oKTtcblx0XHR2YXIgdGltZSA9IChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KS50b0ZpeGVkKDIpO1xuXG5cdFx0dmFyIHByZWZpeCA9IHVudHJhY2sobGFiZWwpO1xuXG5cdFx0aWYgKCFlZmZlY3RfdHJhY2tpbmcoKSkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUubG9nKGAke3ByZWZpeH0gJWNyYW4gb3V0c2lkZSBvZiBhbiBlZmZlY3QgKCR7dGltZX1tcylgLCAnY29sb3I6IGdyZXknKTtcblx0XHR9IGVsc2UgaWYgKHRyYWNpbmdfZXhwcmVzc2lvbnMuZW50cmllcy5zaXplID09PSAwKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5sb2coYCR7cHJlZml4fSAlY25vIHJlYWN0aXZlIGRlcGVuZGVuY2llcyAoJHt0aW1lfW1zKWAsICdjb2xvcjogZ3JleScpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS5ncm91cChgJHtwcmVmaXh9ICVjKCR7dGltZX1tcylgLCAnY29sb3I6IGdyZXknKTtcblxuXHRcdFx0dmFyIGVudHJpZXMgPSB0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXM7XG5cblx0XHRcdHVudHJhY2soKCkgPT4ge1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtzaWduYWwsIHRyYWNlc10gb2YgZW50cmllcykge1xuXHRcdFx0XHRcdGxvZ19lbnRyeShzaWduYWwsIHRyYWNlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zID0gbnVsbDtcblxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblx0XHRcdGNvbnNvbGUuZ3JvdXBFbmQoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0gZmluYWxseSB7XG5cdFx0dHJhY2luZ19leHByZXNzaW9ucyA9IHByZXZpb3VzbHlfdHJhY2luZ19leHByZXNzaW9ucztcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICogQHJldHVybnMge0Vycm9yICYgeyBzdGFjazogc3RyaW5nIH0gfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X3N0YWNrKGxhYmVsKSB7XG5cdGxldCBlcnJvciA9IEVycm9yKCk7XG5cdGNvbnN0IHN0YWNrID0gZXJyb3Iuc3RhY2s7XG5cblx0aWYgKCFzdGFjaykgcmV0dXJuIG51bGw7XG5cblx0Y29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG5cdGNvbnN0IG5ld19saW5lcyA9IFsnXFxuJ107XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcblxuXHRcdGlmIChsaW5lID09PSAnRXJyb3InKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0aWYgKGxpbmUuaW5jbHVkZXMoJ3ZhbGlkYXRlX2VhY2hfa2V5cycpKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0aWYgKGxpbmUuaW5jbHVkZXMoJ3N2ZWx0ZS9zcmMvaW50ZXJuYWwnKSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdG5ld19saW5lcy5wdXNoKGxpbmUpO1xuXHR9XG5cblx0aWYgKG5ld19saW5lcy5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGRlZmluZV9wcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywge1xuXHRcdHZhbHVlOiBuZXdfbGluZXMuam9pbignXFxuJylcblx0fSk7XG5cblx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnbmFtZScsIHtcblx0XHQvLyAnRXJyb3InIHN1ZmZpeCBpcyByZXF1aXJlZCBmb3Igc3RhY2sgdHJhY2VzIHRvIGJlIHJlbmRlcmVkIHByb3Blcmx5XG5cdFx0dmFsdWU6IGAke2xhYmVsfUVycm9yYFxuXHR9KTtcblxuXHRyZXR1cm4gLyoqIEB0eXBlIHtFcnJvciAmIHsgc3RhY2s6IHN0cmluZyB9fSAqLyAoZXJyb3IpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VmFsdWV9IHNvdXJjZVxuICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWcoc291cmNlLCBsYWJlbCkge1xuXHRzb3VyY2UubGFiZWwgPSBsYWJlbDtcblx0dGFnX3Byb3h5KHNvdXJjZS52LCBsYWJlbCk7XG5cblx0cmV0dXJuIHNvdXJjZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhZ19wcm94eSh2YWx1ZSwgbGFiZWwpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHR2YWx1ZT8uW1BST1hZX1BBVEhfU1lNQk9MXT8uKGxhYmVsKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhYmVsKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSByZXR1cm4gYFN5bWJvbCgke3ZhbHVlLmRlc2NyaXB0aW9ufSlgO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gJzxmdW5jdGlvbj4nO1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSkgcmV0dXJuICc8b2JqZWN0Pic7XG5cdHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgRGV2U3RhY2tFbnRyeSwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBhY3RpdmVfcmVhY3Rpb24gfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY3JlYXRlX3VzZXJfZWZmZWN0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnLCBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQlJBTkNIX0VGRkVDVCwgRUZGRUNUX1JBTiB9IGZyb20gJy4vY29uc3RhbnRzLmpzJztcblxuLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgY29tcG9uZW50X2NvbnRleHQgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0IHwgbnVsbH0gY29udGV4dCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9jb21wb25lbnRfY29udGV4dChjb250ZXh0KSB7XG5cdGNvbXBvbmVudF9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqIEB0eXBlIHtEZXZTdGFja0VudHJ5IHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgZGV2X3N0YWNrID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7RGV2U3RhY2tFbnRyeSB8IG51bGx9IHN0YWNrICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9zdGFjayhzdGFjaykge1xuXHRkZXZfc3RhY2sgPSBzdGFjaztcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgY2FsbGJhY2sgd2l0aCBhIG5ldyBkZXYgc3RhY2sgZW50cnlcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAqIEBwYXJhbSB7RGV2U3RhY2tFbnRyeVsndHlwZSddfSB0eXBlIC0gVHlwZSBvZiBibG9jay9jb21wb25lbnRcbiAqIEBwYXJhbSB7YW55fSBjb21wb25lbnQgLSBDb21wb25lbnQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW5lIC0gTGluZSBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW4gLSBDb2x1bW4gbnVtYmVyXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFthZGRpdGlvbmFsXSAtIEFueSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYWRkIHRvIHRoZSBkZXYgc3RhY2sgZW50cnlcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfc3ZlbHRlX21ldGEoY2FsbGJhY2ssIHR5cGUsIGNvbXBvbmVudCwgbGluZSwgY29sdW1uLCBhZGRpdGlvbmFsKSB7XG5cdGNvbnN0IHBhcmVudCA9IGRldl9zdGFjaztcblxuXHRkZXZfc3RhY2sgPSB7XG5cdFx0dHlwZSxcblx0XHRmaWxlOiBjb21wb25lbnRbRklMRU5BTUVdLFxuXHRcdGxpbmUsXG5cdFx0Y29sdW1uLFxuXHRcdHBhcmVudCxcblx0XHQuLi5hZGRpdGlvbmFsXG5cdH07XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gY2FsbGJhY2soKTtcblx0fSBmaW5hbGx5IHtcblx0XHRkZXZfc3RhY2sgPSBwYXJlbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBjb21wb25lbnQgZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIGN1cnJlbnQgY29tcG9uZW50IGNvbnRleHQ6XG4gKiBgYGBodG1sXG4gKiA8IS0tIEFwcC5zdmVsdGUgLS0+XG4gKiA8Rm9vPlxuICogICA8QmFyIC8+IDwhLS0gY29udGV4dCA9PSBGb28uc3ZlbHRlLCBmdW5jdGlvbiA9PSBBcHAuc3ZlbHRlIC0tPlxuICogPC9Gb28+XG4gKiBgYGBcbiAqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0WydmdW5jdGlvbiddfVxuICovXG5leHBvcnQgbGV0IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge0NvbXBvbmVudENvbnRleHRbJ2Z1bmN0aW9uJ119IGZuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihmbikge1xuXHRkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24gPSBmbjtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbnRleHQgdGhhdCBiZWxvbmdzIHRvIHRoZSBjbG9zZXN0IHBhcmVudCBjb21wb25lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGBrZXlgLlxuICogTXVzdCBiZSBjYWxsZWQgZHVyaW5nIGNvbXBvbmVudCBpbml0aWFsaXNhdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHthbnl9IGtleVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250ZXh0KGtleSkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRDb250ZXh0Jyk7XG5cdGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7VH0gKi8gKGNvbnRleHRfbWFwLmdldChrZXkpKTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2FueX0ga2V5XG4gKiBAcGFyYW0ge1R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnc2V0Q29udGV4dCcpO1xuXG5cdGlmIChhc3luY19tb2RlX2ZsYWcpIHtcblx0XHR2YXIgZmxhZ3MgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmY7XG5cdFx0dmFyIHZhbGlkID0gIWFjdGl2ZV9yZWFjdGlvbiAmJiAoZmxhZ3MgJiBCUkFOQ0hfRUZGRUNUKSAhPT0gMCAmJiAoZmxhZ3MgJiBFRkZFQ1RfUkFOKSA9PT0gMDtcblxuXHRcdGlmICghdmFsaWQpIHtcblx0XHRcdGUuc2V0X2NvbnRleHRfYWZ0ZXJfaW5pdCgpO1xuXHRcdH1cblx0fVxuXG5cdGNvbnRleHRfbWFwLnNldChrZXksIGNvbnRleHQpO1xuXHRyZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGBrZXlgIGhhcyBiZWVuIHNldCBpbiB0aGUgY29udGV4dCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gKiBNdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSBrZXlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcblx0Y29uc3QgY29udGV4dF9tYXAgPSBnZXRfb3JfaW5pdF9jb250ZXh0X21hcCgnaGFzQ29udGV4dCcpO1xuXHRyZXR1cm4gY29udGV4dF9tYXAuaGFzKGtleSk7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBAdGVtcGxhdGUge01hcDxhbnksIGFueT59IFtUPU1hcDxhbnksIGFueT5dXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuXHRjb25zdCBjb250ZXh0X21hcCA9IGdldF9vcl9pbml0X2NvbnRleHRfbWFwKCdnZXRBbGxDb250ZXh0cycpO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAoY29udGV4dF9tYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge2FueX0gcnVuZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaChwcm9wcywgcnVuZXMgPSBmYWxzZSwgZm4pIHtcblx0Y29tcG9uZW50X2NvbnRleHQgPSB7XG5cdFx0cDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0YzogbnVsbCxcblx0XHRlOiBudWxsLFxuXHRcdHM6IHByb3BzLFxuXHRcdHg6IG51bGwsXG5cdFx0bDogbGVnYWN5X21vZGVfZmxhZyAmJiAhcnVuZXMgPyB7IHM6IG51bGwsIHU6IG51bGwsICQ6IFtdIH0gOiBudWxsXG5cdH07XG5cblx0aWYgKERFVikge1xuXHRcdC8vIGNvbXBvbmVudCBmdW5jdGlvblxuXHRcdGNvbXBvbmVudF9jb250ZXh0LmZ1bmN0aW9uID0gZm47XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gZm47XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFRcbiAqIEBwYXJhbSB7VH0gW2NvbXBvbmVudF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9wKGNvbXBvbmVudCkge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dH0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblx0dmFyIGVmZmVjdHMgPSBjb250ZXh0LmU7XG5cblx0aWYgKGVmZmVjdHMgIT09IG51bGwpIHtcblx0XHRjb250ZXh0LmUgPSBudWxsO1xuXG5cdFx0Zm9yICh2YXIgZm4gb2YgZWZmZWN0cykge1xuXHRcdFx0Y3JlYXRlX3VzZXJfZWZmZWN0KGZuKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY29tcG9uZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHRjb250ZXh0LnggPSBjb21wb25lbnQ7XG5cdH1cblxuXHRjb21wb25lbnRfY29udGV4dCA9IGNvbnRleHQucDtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uID0gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uID8/IG51bGw7XG5cdH1cblxuXHRyZXR1cm4gY29tcG9uZW50ID8/IC8qKiBAdHlwZSB7VH0gKi8gKHt9KTtcbn1cblxuLyoqIEByZXR1cm5zIHtib29sZWFufSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3J1bmVzKCkge1xuXHRyZXR1cm4gIWxlZ2FjeV9tb2RlX2ZsYWcgfHwgKGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsICYmIGNvbXBvbmVudF9jb250ZXh0LmwgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7TWFwPHVua25vd24sIHVua25vd24+fVxuICovXG5mdW5jdGlvbiBnZXRfb3JfaW5pdF9jb250ZXh0X21hcChuYW1lKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KG5hbWUpO1xuXHR9XG5cblx0cmV0dXJuIChjb21wb25lbnRfY29udGV4dC5jID8/PSBuZXcgTWFwKGdldF9wYXJlbnRfY29udGV4dChjb21wb25lbnRfY29udGV4dCkgfHwgdW5kZWZpbmVkKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0fSBjb21wb25lbnRfY29udGV4dFxuICogQHJldHVybnMge01hcDx1bmtub3duLCB1bmtub3duPiB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldF9wYXJlbnRfY29udGV4dChjb21wb25lbnRfY29udGV4dCkge1xuXHRsZXQgcGFyZW50ID0gY29tcG9uZW50X2NvbnRleHQucDtcblx0d2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IGNvbnRleHRfbWFwID0gcGFyZW50LmM7XG5cdFx0aWYgKGNvbnRleHRfbWFwICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dF9tYXA7XG5cdFx0fVxuXHRcdHBhcmVudCA9IHBhcmVudC5wO1xuXHR9XG5cdHJldHVybiBudWxsO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRGVyaXZlZCwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQm91bmRhcnkgfSBmcm9tICcuL2RvbS9ibG9ja3MvYm91bmRhcnkuanMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGlzX2ZpcmVmb3ggfSBmcm9tICcuL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IEVSUk9SX1ZBTFVFLCBCT1VOREFSWV9FRkZFQ1QsIEVGRkVDVF9SQU4gfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHksIGdldF9kZXNjcmlwdG9yIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QsIGFjdGl2ZV9yZWFjdGlvbiB9IGZyb20gJy4vcnVudGltZS5qcyc7XG5cbmNvbnN0IGFkanVzdG1lbnRzID0gbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVfZXJyb3IoZXJyb3IpIHtcblx0dmFyIGVmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cblx0Ly8gZm9yIHVub3duZWQgZGVyaXZlZHMsIGRvbid0IHRocm93IHVudGlsIHdlIHJlYWQgdGhlIHZhbHVlXG5cdGlmIChlZmZlY3QgPT09IG51bGwpIHtcblx0XHQvKiogQHR5cGUge0Rlcml2ZWR9ICovIChhY3RpdmVfcmVhY3Rpb24pLmYgfD0gRVJST1JfVkFMVUU7XG5cdFx0cmV0dXJuIGVycm9yO1xuXHR9XG5cblx0aWYgKERFViAmJiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICFhZGp1c3RtZW50cy5oYXMoZXJyb3IpKSB7XG5cdFx0YWRqdXN0bWVudHMuc2V0KGVycm9yLCBnZXRfYWRqdXN0bWVudHMoZXJyb3IsIGVmZmVjdCkpO1xuXHR9XG5cblx0aWYgKChlZmZlY3QuZiAmIEVGRkVDVF9SQU4pID09PSAwKSB7XG5cdFx0Ly8gaWYgdGhlIGVycm9yIG9jY3VycmVkIHdoaWxlIGNyZWF0aW5nIHRoaXMgc3VidHJlZSwgd2UgbGV0IGl0XG5cdFx0Ly8gYnViYmxlIHVwIHVudGlsIGl0IGhpdHMgYSBib3VuZGFyeSB0aGF0IGNhbiBoYW5kbGUgaXRcblx0XHRpZiAoKGVmZmVjdC5mICYgQk9VTkRBUllfRUZGRUNUKSA9PT0gMCkge1xuXHRcdFx0aWYgKCFlZmZlY3QucGFyZW50ICYmIGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0YXBwbHlfYWRqdXN0bWVudHMoZXJyb3IpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHQvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoZWZmZWN0LmIpLmVycm9yKGVycm9yKTtcblx0fSBlbHNlIHtcblx0XHQvLyBvdGhlcndpc2Ugd2UgYnViYmxlIHVwIHRoZSBlZmZlY3QgdHJlZSBvdXJzZWx2ZXNcblx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIGVmZmVjdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGVycm9yXG4gKiBAcGFyYW0ge0VmZmVjdCB8IG51bGx9IGVmZmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBlZmZlY3QpIHtcblx0d2hpbGUgKGVmZmVjdCAhPT0gbnVsbCkge1xuXHRcdGlmICgoZWZmZWN0LmYgJiBCT1VOREFSWV9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAoZWZmZWN0LmIpLmVycm9yKGVycm9yKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWZmZWN0ID0gZWZmZWN0LnBhcmVudDtcblx0fVxuXG5cdGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0YXBwbHlfYWRqdXN0bWVudHMoZXJyb3IpO1xuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG5cbi8qKlxuICogQWRkIHVzZWZ1bCBpbmZvcm1hdGlvbiB0byB0aGUgZXJyb3IgbWVzc2FnZS9zdGFjayBpbiBkZXZlbG9wbWVudFxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0X2FkanVzdG1lbnRzKGVycm9yLCBlZmZlY3QpIHtcblx0Y29uc3QgbWVzc2FnZV9kZXNjcmlwdG9yID0gZ2V0X2Rlc2NyaXB0b3IoZXJyb3IsICdtZXNzYWdlJyk7XG5cblx0Ly8gaWYgdGhlIG1lc3NhZ2Ugd2FzIGFscmVhZHkgY2hhbmdlZCBhbmQgaXQncyBub3QgY29uZmlndXJhYmxlIHdlIGNhbid0IGNoYW5nZSBpdFxuXHQvLyBvciBpdCB3aWxsIHRocm93IGEgZGlmZmVyZW50IGVycm9yIHN3YWxsb3dpbmcgdGhlIG9yaWdpbmFsIGVycm9yXG5cdGlmIChtZXNzYWdlX2Rlc2NyaXB0b3IgJiYgIW1lc3NhZ2VfZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHJldHVybjtcblxuXHR2YXIgaW5kZW50ID0gaXNfZmlyZWZveCA/ICcgICcgOiAnXFx0Jztcblx0dmFyIGNvbXBvbmVudF9zdGFjayA9IGBcXG4ke2luZGVudH1pbiAke2VmZmVjdC5mbj8ubmFtZSB8fCAnPHVua25vd24+J31gO1xuXHR2YXIgY29udGV4dCA9IGVmZmVjdC5jdHg7XG5cblx0d2hpbGUgKGNvbnRleHQgIT09IG51bGwpIHtcblx0XHRjb21wb25lbnRfc3RhY2sgKz0gYFxcbiR7aW5kZW50fWluICR7Y29udGV4dC5mdW5jdGlvbj8uW0ZJTEVOQU1FXS5zcGxpdCgnLycpLnBvcCgpfWA7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQucDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bWVzc2FnZTogZXJyb3IubWVzc2FnZSArIGBcXG4ke2NvbXBvbmVudF9zdGFja31cXG5gLFxuXHRcdHN0YWNrOiBlcnJvci5zdGFja1xuXHRcdFx0Py5zcGxpdCgnXFxuJylcblx0XHRcdC5maWx0ZXIoKGxpbmUpID0+ICFsaW5lLmluY2x1ZGVzKCdzdmVsdGUvc3JjL2ludGVybmFsJykpXG5cdFx0XHQuam9pbignXFxuJylcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICovXG5mdW5jdGlvbiBhcHBseV9hZGp1c3RtZW50cyhlcnJvcikge1xuXHRjb25zdCBhZGp1c3RlZCA9IGFkanVzdG1lbnRzLmdldChlcnJvcik7XG5cblx0aWYgKGFkanVzdGVkKSB7XG5cdFx0ZGVmaW5lX3Byb3BlcnR5KGVycm9yLCAnbWVzc2FnZScsIHtcblx0XHRcdHZhbHVlOiBhZGp1c3RlZC5tZXNzYWdlXG5cdFx0fSk7XG5cblx0XHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHtcblx0XHRcdHZhbHVlOiBhZGp1c3RlZC5zdGFja1xuXHRcdH0pO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgcnVuX2FsbCB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbi8vIEZhbGxiYWNrIGZvciB3aGVuIHJlcXVlc3RJZGxlQ2FsbGJhY2sgaXMgbm90IGF2YWlsYWJsZVxuY29uc3QgcmVxdWVzdF9pZGxlX2NhbGxiYWNrID1cblx0dHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgPT09ICd1bmRlZmluZWQnXG5cdFx0PyAoLyoqIEB0eXBlIHsoKSA9PiB2b2lkfSAqLyBjYikgPT4gc2V0VGltZW91dChjYiwgMSlcblx0XHQ6IHJlcXVlc3RJZGxlQ2FsbGJhY2s7XG5cbi8qKiBAdHlwZSB7QXJyYXk8KCkgPT4gdm9pZD59ICovXG5sZXQgbWljcm9fdGFza3MgPSBbXTtcblxuLyoqIEB0eXBlIHtBcnJheTwoKSA9PiB2b2lkPn0gKi9cbmxldCBpZGxlX3Rhc2tzID0gW107XG5cbmZ1bmN0aW9uIHJ1bl9taWNyb190YXNrcygpIHtcblx0dmFyIHRhc2tzID0gbWljcm9fdGFza3M7XG5cdG1pY3JvX3Rhc2tzID0gW107XG5cdHJ1bl9hbGwodGFza3MpO1xufVxuXG5mdW5jdGlvbiBydW5faWRsZV90YXNrcygpIHtcblx0dmFyIHRhc2tzID0gaWRsZV90YXNrcztcblx0aWRsZV90YXNrcyA9IFtdO1xuXHRydW5fYWxsKHRhc2tzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWV1ZV9taWNyb190YXNrKGZuKSB7XG5cdGlmIChtaWNyb190YXNrcy5sZW5ndGggPT09IDApIHtcblx0XHRxdWV1ZU1pY3JvdGFzayhydW5fbWljcm9fdGFza3MpO1xuXHR9XG5cblx0bWljcm9fdGFza3MucHVzaChmbik7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVldWVfaWRsZV90YXNrKGZuKSB7XG5cdGlmIChpZGxlX3Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHJlcXVlc3RfaWRsZV9jYWxsYmFjayhydW5faWRsZV90YXNrcyk7XG5cdH1cblxuXHRpZGxlX3Rhc2tzLnB1c2goZm4pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgcnVuIGFueSBxdWV1ZWQgdGFza3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaF90YXNrcygpIHtcblx0aWYgKG1pY3JvX3Rhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRydW5fbWljcm9fdGFza3MoKTtcblx0fVxuXG5cdGlmIChpZGxlX3Rhc2tzLmxlbmd0aCA+IDApIHtcblx0XHRydW5faWRsZV90YXNrcygpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgZ2V0LCB0aWNrLCB1bnRyYWNrIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZWZmZWN0X3RyYWNraW5nLCByZW5kZXJfZWZmZWN0IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzb3VyY2UsIGluY3JlbWVudCB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgdGFnIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9kb20vdGFzay5qcyc7XG5cbi8qKlxuICogUmV0dXJucyBhIGBzdWJzY3JpYmVgIGZ1bmN0aW9uIHRoYXQgaW50ZWdyYXRlcyBleHRlcm5hbCBldmVudC1iYXNlZCBzeXN0ZW1zIHdpdGggU3ZlbHRlJ3MgcmVhY3Rpdml0eS5cbiAqIEl0J3MgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgaW50ZWdyYXRpbmcgd2l0aCB3ZWIgQVBJcyBsaWtlIGBNZWRpYVF1ZXJ5YCwgYEludGVyc2VjdGlvbk9ic2VydmVyYCwgb3IgYFdlYlNvY2tldGAuXG4gKlxuICogSWYgYHN1YnNjcmliZWAgaXMgY2FsbGVkIGluc2lkZSBhbiBlZmZlY3QgKGluY2x1ZGluZyBpbmRpcmVjdGx5LCBmb3IgZXhhbXBsZSBpbnNpZGUgYSBnZXR0ZXIpLFxuICogdGhlIGBzdGFydGAgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBgdXBkYXRlYCBmdW5jdGlvbi4gV2hlbmV2ZXIgYHVwZGF0ZWAgaXMgY2FsbGVkLCB0aGUgZWZmZWN0IHJlLXJ1bnMuXG4gKlxuICogSWYgYHN0YXJ0YCByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZWZmZWN0IGlzIGRlc3Ryb3llZC5cbiAqXG4gKiBJZiBgc3Vic2NyaWJlYCBpcyBjYWxsZWQgaW4gbXVsdGlwbGUgZWZmZWN0cywgYHN0YXJ0YCB3aWxsIG9ubHkgYmUgY2FsbGVkIG9uY2UgYXMgbG9uZyBhcyB0aGUgZWZmZWN0c1xuICogYXJlIGFjdGl2ZSwgYW5kIHRoZSByZXR1cm5lZCB0ZWFyZG93biBmdW5jdGlvbiB3aWxsIG9ubHkgYmUgY2FsbGVkIHdoZW4gYWxsIGVmZmVjdHMgYXJlIGRlc3Ryb3llZC5cbiAqXG4gKiBJdCdzIGJlc3QgdW5kZXJzdG9vZCB3aXRoIGFuIGV4YW1wbGUuIEhlcmUncyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBbYE1lZGlhUXVlcnlgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvc3ZlbHRlLXJlYWN0aXZpdHkjTWVkaWFRdWVyeSk6XG4gKlxuICogYGBganNcbiAqIGltcG9ydCB7IGNyZWF0ZVN1YnNjcmliZXIgfSBmcm9tICdzdmVsdGUvcmVhY3Rpdml0eSc7XG4gKiBpbXBvcnQgeyBvbiB9IGZyb20gJ3N2ZWx0ZS9ldmVudHMnO1xuICpcbiAqIGV4cG9ydCBjbGFzcyBNZWRpYVF1ZXJ5IHtcbiAqIFx0I3F1ZXJ5O1xuICogXHQjc3Vic2NyaWJlO1xuICpcbiAqIFx0Y29uc3RydWN0b3IocXVlcnkpIHtcbiAqIFx0XHR0aGlzLiNxdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKGAoJHtxdWVyeX0pYCk7XG4gKlxuICogXHRcdHRoaXMuI3N1YnNjcmliZSA9IGNyZWF0ZVN1YnNjcmliZXIoKHVwZGF0ZSkgPT4ge1xuICogXHRcdFx0Ly8gd2hlbiB0aGUgYGNoYW5nZWAgZXZlbnQgb2NjdXJzLCByZS1ydW4gYW55IGVmZmVjdHMgdGhhdCByZWFkIGB0aGlzLmN1cnJlbnRgXG4gKiBcdFx0XHRjb25zdCBvZmYgPSBvbih0aGlzLiNxdWVyeSwgJ2NoYW5nZScsIHVwZGF0ZSk7XG4gKlxuICogXHRcdFx0Ly8gc3RvcCBsaXN0ZW5pbmcgd2hlbiBhbGwgdGhlIGVmZmVjdHMgYXJlIGRlc3Ryb3llZFxuICogXHRcdFx0cmV0dXJuICgpID0+IG9mZigpO1xuICogXHRcdH0pO1xuICogXHR9XG4gKlxuICogXHRnZXQgY3VycmVudCgpIHtcbiAqIFx0XHQvLyBUaGlzIG1ha2VzIHRoZSBnZXR0ZXIgcmVhY3RpdmUsIGlmIHJlYWQgaW4gYW4gZWZmZWN0XG4gKiBcdFx0dGhpcy4jc3Vic2NyaWJlKCk7XG4gKlxuICogXHRcdC8vIFJldHVybiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcXVlcnksIHdoZXRoZXIgb3Igbm90IHdlJ3JlIGluIGFuIGVmZmVjdFxuICogXHRcdHJldHVybiB0aGlzLiNxdWVyeS5tYXRjaGVzO1xuICogXHR9XG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7KHVwZGF0ZTogKCkgPT4gdm9pZCkgPT4gKCgpID0+IHZvaWQpIHwgdm9pZH0gc3RhcnRcbiAqIEBzaW5jZSA1LjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlcihzdGFydCkge1xuXHRsZXQgc3Vic2NyaWJlcnMgPSAwO1xuXHRsZXQgdmVyc2lvbiA9IHNvdXJjZSgwKTtcblx0LyoqIEB0eXBlIHsoKCkgPT4gdm9pZCkgfCB2b2lkfSAqL1xuXHRsZXQgc3RvcDtcblxuXHRpZiAoREVWKSB7XG5cdFx0dGFnKHZlcnNpb24sICdjcmVhdGVTdWJzY3JpYmVyIHZlcnNpb24nKTtcblx0fVxuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGVmZmVjdF90cmFja2luZygpKSB7XG5cdFx0XHRnZXQodmVyc2lvbik7XG5cblx0XHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHRpZiAoc3Vic2NyaWJlcnMgPT09IDApIHtcblx0XHRcdFx0XHRzdG9wID0gdW50cmFjaygoKSA9PiBzdGFydCgoKSA9PiBpbmNyZW1lbnQodmVyc2lvbikpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHN1YnNjcmliZXJzICs9IDE7XG5cblx0XHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdFx0XHRcdC8vIE9ubHkgY291bnQgZG93biBhZnRlciBhIG1pY3JvdGFzaywgZWxzZSB3ZSB3b3VsZCByZWFjaCAwIGJlZm9yZSBvdXIgb3duIHJlbmRlciBlZmZlY3QgcmVydW5zLFxuXHRcdFx0XHRcdFx0Ly8gYnV0IHJlYWNoIDEgYWdhaW4gd2hlbiB0aGUgdGljayBjYWxsYmFjayBvZiB0aGUgcHJpb3IgdGVhcmRvd24gcnVucy4gVGhhdCB3b3VsZCBtZWFuIHdlXG5cdFx0XHRcdFx0XHQvLyByZS1zdWJjcmliZSB1bm5lY2Vzc2FyaWx5IGFuZCBjcmVhdGUgYSBtZW1vcnkgbGVhayBiZWNhdXNlIHRoZSBvbGQgc3Vic2NyaXB0aW9uIGlzIG5ldmVyIGNsZWFuZWQgdXAuXG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVycyAtPSAxO1xuXG5cdFx0XHRcdFx0XHRpZiAoc3Vic2NyaWJlcnMgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0c3RvcD8uKCk7XG5cdFx0XHRcdFx0XHRcdHN0b3AgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdC8vIEluY3JlbWVudCB0aGUgdmVyc2lvbiB0byBlbnN1cmUgYW55IGRlcGVuZGVudCBkZXJpdmVkcyBhcmUgbWFya2VkIGRpcnR5IHdoZW4gdGhlIHN1YnNjcmlwdGlvbiBpcyBwaWNrZWQgdXAgYWdhaW4gbGF0ZXIuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHdlIGRpZG4ndCBkbyB0aGlzIHRoZW4gdGhlIGNvbXBhcmlzb24gb2Ygd3JpdGUgdmVyc2lvbnMgd291bGQgZGV0ZXJtaW5lIHRoYXQgdGhlIGRlcml2ZWQgaGFzIGEgbGF0ZXIgdmVyc2lvbiB0aGFuXG5cdFx0XHRcdFx0XHRcdC8vIHRoZSBzdWJzY3JpYmVyLCBhbmQgaXQgd291bGQgbm90IGJlIHJlLXJ1bi5cblx0XHRcdFx0XHRcdFx0aW5jcmVtZW50KHZlcnNpb24pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBTb3VyY2UsIFRlbXBsYXRlTm9kZSwgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHtcblx0Qk9VTkRBUllfRUZGRUNULFxuXHRFRkZFQ1RfUFJFU0VSVkVELFxuXHRFRkZFQ1RfUkFOLFxuXHRFRkZFQ1RfVFJBTlNQQVJFTlRcbn0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIHNldF9jb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgaGFuZGxlX2Vycm9yLCBpbnZva2VfZXJyb3JfYm91bmRhcnkgfSBmcm9tICcuLi8uLi9lcnJvci1oYW5kbGluZy5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBkZXN0cm95X2VmZmVjdCwgcGF1c2VfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0Z2V0LFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0c2V0X2FjdGl2ZV9yZWFjdGlvblxufSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdG5leHQsXG5cdHJlbW92ZV9ub2Rlcyxcblx0c2V0X2h5ZHJhdGVfbm9kZVxufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgZ2V0X25leHRfc2libGluZyB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi8uLi9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IEJhdGNoLCBlZmZlY3RfcGVuZGluZ191cGRhdGVzIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQgeyBpbnRlcm5hbF9zZXQsIHNvdXJjZSB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyB0YWcgfSBmcm9tICcuLi8uLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdWJzY3JpYmVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vcmVhY3Rpdml0eS9jcmVhdGUtc3Vic2NyaWJlci5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIFx0IG9uZXJyb3I/OiAoZXJyb3I6IHVua25vd24sIHJlc2V0OiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xuICogICBmYWlsZWQ/OiAoYW5jaG9yOiBOb2RlLCBlcnJvcjogKCkgPT4gdW5rbm93biwgcmVzZXQ6ICgpID0+ICgpID0+IHZvaWQpID0+IHZvaWQ7XG4gKiAgIHBlbmRpbmc/OiAoYW5jaG9yOiBOb2RlKSA9PiB2b2lkO1xuICogfX0gQm91bmRhcnlQcm9wc1xuICovXG5cbnZhciBmbGFncyA9IEVGRkVDVF9UUkFOU1BBUkVOVCB8IEVGRkVDVF9QUkVTRVJWRUQgfCBCT1VOREFSWV9FRkZFQ1Q7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Qm91bmRhcnlQcm9wc30gcHJvcHNcbiAqIEBwYXJhbSB7KChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBjaGlsZHJlblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBib3VuZGFyeShub2RlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bmV3IEJvdW5kYXJ5KG5vZGUsIHByb3BzLCBjaGlsZHJlbik7XG59XG5cbmV4cG9ydCBjbGFzcyBCb3VuZGFyeSB7XG5cdHBlbmRpbmcgPSBmYWxzZTtcblxuXHQvKiogQHR5cGUge0JvdW5kYXJ5IHwgbnVsbH0gKi9cblx0cGFyZW50O1xuXG5cdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqL1xuXHQjYW5jaG9yO1xuXG5cdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqL1xuXHQjaHlkcmF0ZV9vcGVuO1xuXG5cdC8qKiBAdHlwZSB7Qm91bmRhcnlQcm9wc30gKi9cblx0I3Byb3BzO1xuXG5cdC8qKiBAdHlwZSB7KChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSAqL1xuXHQjY2hpbGRyZW47XG5cblx0LyoqIEB0eXBlIHtFZmZlY3R9ICovXG5cdCNlZmZlY3Q7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHQjbWFpbl9lZmZlY3QgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0I3BlbmRpbmdfZWZmZWN0ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdCNmYWlsZWRfZWZmZWN0ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnQgfCBudWxsfSAqL1xuXHQjb2Zmc2NyZWVuX2ZyYWdtZW50ID0gbnVsbDtcblxuXHQjcGVuZGluZ19jb3VudCA9IDA7XG5cdCNpc19jcmVhdGluZ19mYWxsYmFjayA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBBIHNvdXJjZSBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgcGVuZGluZyBhc3luYyBkZXJpdmVkcy9leHByZXNzaW9ucy5cblx0ICogT25seSBjcmVhdGVkIGlmIGAkZWZmZWN0LnBlbmRpbmcoKWAgaXMgdXNlZCBpbnNpZGUgdGhlIGJvdW5kYXJ5LFxuXHQgKiBvdGhlcndpc2UgdXBkYXRpbmcgdGhlIHNvdXJjZSByZXN1bHRzIGluIG5lZWRsZXNzIGBCYXRjaC5lbnN1cmUoKWBcblx0ICogY2FsbHMgZm9sbG93ZWQgYnkgbm8tb3AgZmx1c2hlc1xuXHQgKiBAdHlwZSB7U291cmNlPG51bWJlcj4gfCBudWxsfVxuXHQgKi9cblx0I2VmZmVjdF9wZW5kaW5nID0gbnVsbDtcblxuXHQjZWZmZWN0X3BlbmRpbmdfdXBkYXRlID0gKCkgPT4ge1xuXHRcdGlmICh0aGlzLiNlZmZlY3RfcGVuZGluZykge1xuXHRcdFx0aW50ZXJuYWxfc2V0KHRoaXMuI2VmZmVjdF9wZW5kaW5nLCB0aGlzLiNwZW5kaW5nX2NvdW50KTtcblx0XHR9XG5cdH07XG5cblx0I2VmZmVjdF9wZW5kaW5nX3N1YnNjcmliZXIgPSBjcmVhdGVTdWJzY3JpYmVyKCgpID0+IHtcblx0XHR0aGlzLiNlZmZlY3RfcGVuZGluZyA9IHNvdXJjZSh0aGlzLiNwZW5kaW5nX2NvdW50KTtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdHRhZyh0aGlzLiNlZmZlY3RfcGVuZGluZywgJyRlZmZlY3QucGVuZGluZygpJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuI2VmZmVjdF9wZW5kaW5nID0gbnVsbDtcblx0XHR9O1xuXHR9KTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcblx0ICogQHBhcmFtIHtCb3VuZGFyeVByb3BzfSBwcm9wc1xuXHQgKiBAcGFyYW0geygoYW5jaG9yOiBOb2RlKSA9PiB2b2lkKX0gY2hpbGRyZW5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG5vZGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRcdHRoaXMuI2FuY2hvciA9IG5vZGU7XG5cdFx0dGhpcy4jcHJvcHMgPSBwcm9wcztcblx0XHR0aGlzLiNjaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG5cdFx0dGhpcy4jaHlkcmF0ZV9vcGVuID0gaHlkcmF0ZV9ub2RlO1xuXG5cdFx0dGhpcy5wYXJlbnQgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmI7XG5cblx0XHR0aGlzLnBlbmRpbmcgPSAhIXRoaXMuI3Byb3BzLnBlbmRpbmc7XG5cblx0XHR0aGlzLiNlZmZlY3QgPSBibG9jaygoKSA9PiB7XG5cdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLmIgPSB0aGlzO1xuXG5cdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBwZW5kaW5nID0gdGhpcy4jcHJvcHMucGVuZGluZztcblxuXHRcdFx0aWYgKGh5ZHJhdGluZyAmJiBwZW5kaW5nKSB7XG5cdFx0XHRcdHRoaXMuI3BlbmRpbmdfZWZmZWN0ID0gYnJhbmNoKCgpID0+IHBlbmRpbmcodGhpcy4jYW5jaG9yKSk7XG5cblx0XHRcdFx0Ly8gZnV0dXJlIHdvcms6IHdoZW4gd2UgaGF2ZSBzb21lIGZvcm0gb2YgYXN5bmMgU1NSLCB3ZSB3aWxsXG5cdFx0XHRcdC8vIG5lZWQgdG8gdXNlIGh5ZHJhdGlvbiBib3VuZGFyeSBjb21tZW50cyB0byByZXBvcnQgd2hldGhlclxuXHRcdFx0XHQvLyB0aGUgcGVuZGluZyBvciBtYWluIGJsb2NrIHdhcyByZW5kZXJlZCBmb3IgYSBnaXZlblxuXHRcdFx0XHQvLyBib3VuZGFyeSwgYW5kIGh5ZHJhdGUgYWNjb3JkaW5nbHlcblx0XHRcdFx0QmF0Y2guZW5xdWV1ZSgoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4jbWFpbl9lZmZlY3QgPSB0aGlzLiNydW4oKCkgPT4ge1xuXHRcdFx0XHRcdFx0QmF0Y2guZW5zdXJlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYnJhbmNoKCgpID0+IHRoaXMuI2NoaWxkcmVuKHRoaXMuI2FuY2hvcikpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMuI3BlbmRpbmdfY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0XHR0aGlzLiNzaG93X3BlbmRpbmdfc25pcHBldCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwYXVzZV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovICh0aGlzLiNwZW5kaW5nX2VmZmVjdCksICgpID0+IHtcblx0XHRcdFx0XHRcdFx0dGhpcy4jcGVuZGluZ19lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHRoaXMucGVuZGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMuI21haW5fZWZmZWN0ID0gYnJhbmNoKCgpID0+IGNoaWxkcmVuKHRoaXMuI2FuY2hvcikpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHRoaXMuI3BlbmRpbmdfY291bnQgPiAwKSB7XG5cdFx0XHRcdFx0dGhpcy4jc2hvd19wZW5kaW5nX3NuaXBwZXQoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnBlbmRpbmcgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sIGZsYWdzKTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdHRoaXMuI2FuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cdH1cblxuXHRoYXNfcGVuZGluZ19zbmlwcGV0KCkge1xuXHRcdHJldHVybiAhIXRoaXMuI3Byb3BzLnBlbmRpbmc7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHsoKSA9PiBFZmZlY3QgfCBudWxsfSBmblxuXHQgKi9cblx0I3J1bihmbikge1xuXHRcdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHRcdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHR2YXIgcHJldmlvdXNfY3R4ID0gY29tcG9uZW50X2NvbnRleHQ7XG5cblx0XHRzZXRfYWN0aXZlX2VmZmVjdCh0aGlzLiNlZmZlY3QpO1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24odGhpcy4jZWZmZWN0KTtcblx0XHRzZXRfY29tcG9uZW50X2NvbnRleHQodGhpcy4jZWZmZWN0LmN0eCk7XG5cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aGFuZGxlX2Vycm9yKGUpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRcdHNldF9jb21wb25lbnRfY29udGV4dChwcmV2aW91c19jdHgpO1xuXHRcdH1cblx0fVxuXG5cdCNzaG93X3BlbmRpbmdfc25pcHBldCgpIHtcblx0XHRjb25zdCBwZW5kaW5nID0gLyoqIEB0eXBlIHsoYW5jaG9yOiBOb2RlKSA9PiB2b2lkfSAqLyAodGhpcy4jcHJvcHMucGVuZGluZyk7XG5cblx0XHRpZiAodGhpcy4jbWFpbl9lZmZlY3QgIT09IG51bGwpIHtcblx0XHRcdHRoaXMuI29mZnNjcmVlbl9mcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdG1vdmVfZWZmZWN0KHRoaXMuI21haW5fZWZmZWN0LCB0aGlzLiNvZmZzY3JlZW5fZnJhZ21lbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNwZW5kaW5nX2VmZmVjdCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy4jcGVuZGluZ19lZmZlY3QgPSBicmFuY2goKCkgPT4gcGVuZGluZyh0aGlzLiNhbmNob3IpKTtcblx0XHR9XG5cdH1cblxuXHQvKiogQHBhcmFtIHsxIHwgLTF9IGQgKi9cblx0I3VwZGF0ZV9wZW5kaW5nX2NvdW50KGQpIHtcblx0XHR0aGlzLiNwZW5kaW5nX2NvdW50ICs9IGQ7XG5cblx0XHRpZiAodGhpcy4jcGVuZGluZ19jb3VudCA9PT0gMCkge1xuXHRcdFx0dGhpcy5wZW5kaW5nID0gZmFsc2U7XG5cblx0XHRcdGlmICh0aGlzLiNwZW5kaW5nX2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QodGhpcy4jcGVuZGluZ19lZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KSB7XG5cdFx0XHRcdHRoaXMuI2FuY2hvci5iZWZvcmUodGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50KTtcblx0XHRcdFx0dGhpcy4jb2Zmc2NyZWVuX2ZyYWdtZW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiogQHBhcmFtIHsxIHwgLTF9IGQgKi9cblx0dXBkYXRlX3BlbmRpbmdfY291bnQoZCkge1xuXHRcdGlmICh0aGlzLmhhc19wZW5kaW5nX3NuaXBwZXQoKSkge1xuXHRcdFx0dGhpcy4jdXBkYXRlX3BlbmRpbmdfY291bnQoZCk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuXHRcdFx0dGhpcy5wYXJlbnQuI3VwZGF0ZV9wZW5kaW5nX2NvdW50KGQpO1xuXHRcdH1cblxuXHRcdGVmZmVjdF9wZW5kaW5nX3VwZGF0ZXMuYWRkKHRoaXMuI2VmZmVjdF9wZW5kaW5nX3VwZGF0ZSk7XG5cdH1cblxuXHRnZXRfZWZmZWN0X3BlbmRpbmcoKSB7XG5cdFx0dGhpcy4jZWZmZWN0X3BlbmRpbmdfc3Vic2NyaWJlcigpO1xuXHRcdHJldHVybiBnZXQoLyoqIEB0eXBlIHtTb3VyY2U8bnVtYmVyPn0gKi8gKHRoaXMuI2VmZmVjdF9wZW5kaW5nKSk7XG5cdH1cblxuXHQvKiogQHBhcmFtIHt1bmtub3dufSBlcnJvciAqL1xuXHRlcnJvcihlcnJvcikge1xuXHRcdHZhciBvbmVycm9yID0gdGhpcy4jcHJvcHMub25lcnJvcjtcblx0XHRsZXQgZmFpbGVkID0gdGhpcy4jcHJvcHMuZmFpbGVkO1xuXG5cdFx0aWYgKHRoaXMuI21haW5fZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCh0aGlzLiNtYWluX2VmZmVjdCk7XG5cdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmdfZWZmZWN0KSB7XG5cdFx0XHRkZXN0cm95X2VmZmVjdCh0aGlzLiNwZW5kaW5nX2VmZmVjdCk7XG5cdFx0XHR0aGlzLiNwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuI2ZhaWxlZF9lZmZlY3QpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KHRoaXMuI2ZhaWxlZF9lZmZlY3QpO1xuXHRcdFx0dGhpcy4jZmFpbGVkX2VmZmVjdCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZSh0aGlzLiNoeWRyYXRlX29wZW4pO1xuXHRcdFx0bmV4dCgpO1xuXHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShyZW1vdmVfbm9kZXMoKSk7XG5cdFx0fVxuXG5cdFx0dmFyIGRpZF9yZXNldCA9IGZhbHNlO1xuXHRcdHZhciBjYWxsaW5nX29uX2Vycm9yID0gZmFsc2U7XG5cblx0XHRjb25zdCByZXNldCA9ICgpID0+IHtcblx0XHRcdGlmIChkaWRfcmVzZXQpIHtcblx0XHRcdFx0dy5zdmVsdGVfYm91bmRhcnlfcmVzZXRfbm9vcCgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGRpZF9yZXNldCA9IHRydWU7XG5cblx0XHRcdGlmIChjYWxsaW5nX29uX2Vycm9yKSB7XG5cdFx0XHRcdGUuc3ZlbHRlX2JvdW5kYXJ5X3Jlc2V0X29uZXJyb3IoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy4jcGVuZGluZ19jb3VudCA9IDA7XG5cblx0XHRcdGlmICh0aGlzLiNmYWlsZWRfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdCh0aGlzLiNmYWlsZWRfZWZmZWN0LCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4jZmFpbGVkX2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnBlbmRpbmcgPSB0cnVlO1xuXG5cdFx0XHR0aGlzLiNtYWluX2VmZmVjdCA9IHRoaXMuI3J1bigoKSA9PiB7XG5cdFx0XHRcdHRoaXMuI2lzX2NyZWF0aW5nX2ZhbGxiYWNrID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiBicmFuY2goKCkgPT4gdGhpcy4jY2hpbGRyZW4odGhpcy4jYW5jaG9yKSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHRoaXMuI3BlbmRpbmdfY291bnQgPiAwKSB7XG5cdFx0XHRcdHRoaXMuI3Nob3dfcGVuZGluZ19zbmlwcGV0KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBlbmRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Ly8gSWYgd2UgaGF2ZSBub3RoaW5nIHRvIGNhcHR1cmUgdGhlIGVycm9yLCBvciBpZiB3ZSBoaXQgYW4gZXJyb3Igd2hpbGVcblx0XHQvLyByZW5kZXJpbmcgdGhlIGZhbGxiYWNrLCByZS10aHJvdyBmb3IgYW5vdGhlciBib3VuZGFyeSB0byBoYW5kbGVcblx0XHRpZiAodGhpcy4jaXNfY3JlYXRpbmdfZmFsbGJhY2sgfHwgKCFvbmVycm9yICYmICFmYWlsZWQpKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHR2YXIgcHJldmlvdXNfcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cblx0XHR0cnkge1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHRcdGNhbGxpbmdfb25fZXJyb3IgPSB0cnVlO1xuXHRcdFx0b25lcnJvcj8uKGVycm9yLCByZXNldCk7XG5cdFx0XHRjYWxsaW5nX29uX2Vycm9yID0gZmFsc2U7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgdGhpcy4jZWZmZWN0ICYmIHRoaXMuI2VmZmVjdC5wYXJlbnQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHR9XG5cblx0XHRpZiAoZmFpbGVkKSB7XG5cdFx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdFx0dGhpcy4jZmFpbGVkX2VmZmVjdCA9IHRoaXMuI3J1bigoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy4jaXNfY3JlYXRpbmdfZmFsbGJhY2sgPSB0cnVlO1xuXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHJldHVybiBicmFuY2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRmYWlsZWQoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy4jYW5jaG9yLFxuXHRcdFx0XHRcdFx0XHRcdCgpID0+IGVycm9yLFxuXHRcdFx0XHRcdFx0XHRcdCgpID0+IHJlc2V0XG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCAvKiogQHR5cGUge0VmZmVjdH0gKi8gKHRoaXMuI2VmZmVjdC5wYXJlbnQpKTtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHR0aGlzLiNpc19jcmVhdGluZ19mYWxsYmFjayA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiBtb3ZlX2VmZmVjdChlZmZlY3QsIGZyYWdtZW50KSB7XG5cdHZhciBub2RlID0gZWZmZWN0Lm5vZGVzX3N0YXJ0O1xuXHR2YXIgZW5kID0gZWZmZWN0Lm5vZGVzX2VuZDtcblxuXHR3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuXHRcdC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlIHwgbnVsbH0gKi9cblx0XHR2YXIgbmV4dCA9IG5vZGUgPT09IGVuZCA/IG51bGwgOiAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcobm9kZSkpO1xuXG5cdFx0ZnJhZ21lbnQuYXBwZW5kKG5vZGUpO1xuXHRcdG5vZGUgPSBuZXh0O1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcGVuZGluZ19ib3VuZGFyeSgpIHtcblx0dmFyIGJvdW5kYXJ5ID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5iO1xuXG5cdHdoaWxlIChib3VuZGFyeSAhPT0gbnVsbCAmJiAhYm91bmRhcnkuaGFzX3BlbmRpbmdfc25pcHBldCgpKSB7XG5cdFx0Ym91bmRhcnkgPSBib3VuZGFyeS5wYXJlbnQ7XG5cdH1cblxuXHRpZiAoYm91bmRhcnkgPT09IG51bGwpIHtcblx0XHRlLmF3YWl0X291dHNpZGVfYm91bmRhcnkoKTtcblx0fVxuXG5cdHJldHVybiBib3VuZGFyeTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBlbmRpbmcoKSB7XG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsKSB7XG5cdFx0ZS5lZmZlY3RfcGVuZGluZ19vdXRzaWRlX3JlYWN0aW9uKCk7XG5cdH1cblxuXHR2YXIgYm91bmRhcnkgPSBhY3RpdmVfZWZmZWN0LmI7XG5cblx0aWYgKGJvdW5kYXJ5ID09PSBudWxsKSB7XG5cdFx0cmV0dXJuIDA7IC8vIFRPRE8gZXZlbnR1YWxseSB3ZSB3aWxsIG5lZWQgdGhpcyB0byBiZSBnbG9iYWxcblx0fVxuXG5cdHJldHVybiBib3VuZGFyeS5nZXRfZWZmZWN0X3BlbmRpbmcoKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCwgU291cmNlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQmF0Y2ggfSBmcm9tICcuL2JhdGNoLmpzJzsgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0RVJST1JfVkFMVUUsXG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRESVJUWSxcblx0RUZGRUNUX1BSRVNFUlZFRCxcblx0TUFZQkVfRElSVFksXG5cdFNUQUxFX1JFQUNUSU9OLFxuXHRVTk9XTkVELFxuXHRBU1lOQ1xufSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHRza2lwX3JlYWN0aW9uLFxuXHR1cGRhdGVfcmVhY3Rpb24sXG5cdGluY3JlbWVudF93cml0ZV92ZXJzaW9uLFxuXHRzZXRfYWN0aXZlX2VmZmVjdCxcblx0cHVzaF9yZWFjdGlvbl92YWx1ZSxcblx0aXNfZGVzdHJveWluZ19lZmZlY3Rcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlcXVhbHMsIHNhZmVfZXF1YWxzIH0gZnJvbSAnLi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGFzeW5jX2VmZmVjdCwgZGVzdHJveV9lZmZlY3QgfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaW5zcGVjdF9lZmZlY3RzLCBpbnRlcm5hbF9zZXQsIHNldF9pbnNwZWN0X2VmZmVjdHMsIHNvdXJjZSB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyBnZXRfc3RhY2sgfSBmcm9tICcuLi9kZXYvdHJhY2luZy5qcyc7XG5pbXBvcnQgeyB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IEJvdW5kYXJ5IH0gZnJvbSAnLi4vZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBiYXRjaF9kZXJpdmVkcywgY3VycmVudF9iYXRjaCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHsgdW5zZXRfY29udGV4dCB9IGZyb20gJy4vYXN5bmMuanMnO1xuXG4vKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5leHBvcnQgbGV0IGN1cnJlbnRfYXN5bmNfZWZmZWN0ID0gbnVsbDtcblxuLyoqIEBwYXJhbSB7RWZmZWN0IHwgbnVsbH0gdiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9mcm9tX2FzeW5jX2Rlcml2ZWQodikge1xuXHRjdXJyZW50X2FzeW5jX2VmZmVjdCA9IHY7XG59XG5cbmV4cG9ydCBjb25zdCByZWNlbnRfYXN5bmNfZGVyaXZlZHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7KCkgPT4gVn0gZm5cbiAqIEByZXR1cm5zIHtEZXJpdmVkPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKGZuKSB7XG5cdHZhciBmbGFncyA9IERFUklWRUQgfCBESVJUWTtcblx0dmFyIHBhcmVudF9kZXJpdmVkID1cblx0XHRhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDBcblx0XHRcdD8gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKVxuXHRcdFx0OiBudWxsO1xuXG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsIHx8IChwYXJlbnRfZGVyaXZlZCAhPT0gbnVsbCAmJiAocGFyZW50X2Rlcml2ZWQuZiAmIFVOT1dORUQpICE9PSAwKSkge1xuXHRcdGZsYWdzIHw9IFVOT1dORUQ7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2luY2UgZGVyaXZlZHMgYXJlIGV2YWx1YXRlZCBsYXppbHksIGFueSBlZmZlY3RzIGNyZWF0ZWQgaW5zaWRlIHRoZW0gYXJlXG5cdFx0Ly8gY3JlYXRlZCB0b28gbGF0ZSB0byBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IGVmZmVjdCBpcyBhZGRlZCB0byB0aGUgdHJlZVxuXHRcdGFjdGl2ZV9lZmZlY3QuZiB8PSBFRkZFQ1RfUFJFU0VSVkVEO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtEZXJpdmVkPFY+fSAqL1xuXHRjb25zdCBzaWduYWwgPSB7XG5cdFx0Y3R4OiBjb21wb25lbnRfY29udGV4dCxcblx0XHRkZXBzOiBudWxsLFxuXHRcdGVmZmVjdHM6IG51bGwsXG5cdFx0ZXF1YWxzLFxuXHRcdGY6IGZsYWdzLFxuXHRcdGZuLFxuXHRcdHJlYWN0aW9uczogbnVsbCxcblx0XHRydjogMCxcblx0XHR2OiAvKiogQHR5cGUge1Z9ICovIChVTklOSVRJQUxJWkVEKSxcblx0XHR3djogMCxcblx0XHRwYXJlbnQ6IHBhcmVudF9kZXJpdmVkID8/IGFjdGl2ZV9lZmZlY3QsXG5cdFx0YWM6IG51bGxcblx0fTtcblxuXHRpZiAoREVWICYmIHRyYWNpbmdfbW9kZV9mbGFnKSB7XG5cdFx0c2lnbmFsLmNyZWF0ZWQgPSBnZXRfc3RhY2soJ0NyZWF0ZWRBdCcpO1xuXHR9XG5cblx0cmV0dXJuIHNpZ25hbDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWIHwgUHJvbWlzZTxWPn0gZm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbG9jYXRpb25dIElmIHByb3ZpZGVkLCBwcmludCBhIHdhcm5pbmcgaWYgdGhlIHZhbHVlIGlzIG5vdCByZWFkIGltbWVkaWF0ZWx5IGFmdGVyIHVwZGF0ZVxuICogQHJldHVybnMge1Byb21pc2U8U291cmNlPFY+Pn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNfZGVyaXZlZChmbiwgbG9jYXRpb24pIHtcblx0bGV0IHBhcmVudCA9IC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdGlmIChwYXJlbnQgPT09IG51bGwpIHtcblx0XHRlLmFzeW5jX2Rlcml2ZWRfb3JwaGFuKCk7XG5cdH1cblxuXHR2YXIgYm91bmRhcnkgPSAvKiogQHR5cGUge0JvdW5kYXJ5fSAqLyAocGFyZW50LmIpO1xuXG5cdHZhciBwcm9taXNlID0gLyoqIEB0eXBlIHtQcm9taXNlPFY+fSAqLyAoLyoqIEB0eXBlIHt1bmtub3dufSAqLyAodW5kZWZpbmVkKSk7XG5cdHZhciBzaWduYWwgPSBzb3VyY2UoLyoqIEB0eXBlIHtWfSAqLyAoVU5JTklUSUFMSVpFRCkpO1xuXG5cdC8qKiBAdHlwZSB7UHJvbWlzZTxWPiB8IG51bGx9ICovXG5cdHZhciBwcmV2ID0gbnVsbDtcblxuXHQvLyBvbmx5IHN1c3BlbmQgaW4gYXN5bmMgZGVyaXZlZHMgY3JlYXRlZCBvbiBpbml0aWFsaXNhdGlvblxuXHR2YXIgc2hvdWxkX3N1c3BlbmQgPSAhYWN0aXZlX3JlYWN0aW9uO1xuXG5cdGFzeW5jX2VmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKERFVikgY3VycmVudF9hc3luY19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciBwID0gZm4oKTtcblx0XHRcdC8vIE1ha2Ugc3VyZSB0byBhbHdheXMgYWNjZXNzIHRoZSB0aGVuIHByb3BlcnR5IHRvIHJlYWQgYW55IHNpZ25hbHNcblx0XHRcdC8vIGl0IG1pZ2h0IGFjY2Vzcywgc28gdGhhdCB3ZSB0cmFjayB0aGVtIGFzIGRlcGVuZGVuY2llcy5cblx0XHRcdGlmIChwcmV2KSBQcm9taXNlLnJlc29sdmUocCkuY2F0Y2goKCkgPT4ge30pOyAvLyBhdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uXG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdHAgPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG5cdFx0fVxuXG5cdFx0aWYgKERFVikgY3VycmVudF9hc3luY19lZmZlY3QgPSBudWxsO1xuXG5cdFx0dmFyIHIgPSAoKSA9PiBwO1xuXHRcdHByb21pc2UgPSBwcmV2Py50aGVuKHIsIHIpID8/IFByb21pc2UucmVzb2x2ZShwKTtcblxuXHRcdHByZXYgPSBwcm9taXNlO1xuXG5cdFx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHRcdHZhciBwZW5kaW5nID0gYm91bmRhcnkucGVuZGluZztcblxuXHRcdGlmIChzaG91bGRfc3VzcGVuZCkge1xuXHRcdFx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoMSk7XG5cdFx0XHRpZiAoIXBlbmRpbmcpIGJhdGNoLmluY3JlbWVudCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHRcdCAqIEBwYXJhbSB7dW5rbm93bn0gZXJyb3Jcblx0XHQgKi9cblx0XHRjb25zdCBoYW5kbGVyID0gKHZhbHVlLCBlcnJvciA9IHVuZGVmaW5lZCkgPT4ge1xuXHRcdFx0cHJldiA9IG51bGw7XG5cblx0XHRcdGN1cnJlbnRfYXN5bmNfZWZmZWN0ID0gbnVsbDtcblxuXHRcdFx0aWYgKCFwZW5kaW5nKSBiYXRjaC5hY3RpdmF0ZSgpO1xuXG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0aWYgKGVycm9yICE9PSBTVEFMRV9SRUFDVElPTikge1xuXHRcdFx0XHRcdHNpZ25hbC5mIHw9IEVSUk9SX1ZBTFVFO1xuXG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciB0aGUgZXJyb3IgaXMgdGhlIHdyb25nIHR5cGUsIGJ1dCB3ZSBkb24ndCBjYXJlXG5cdFx0XHRcdFx0aW50ZXJuYWxfc2V0KHNpZ25hbCwgZXJyb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoKHNpZ25hbC5mICYgRVJST1JfVkFMVUUpICE9PSAwKSB7XG5cdFx0XHRcdFx0c2lnbmFsLmYgXj0gRVJST1JfVkFMVUU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbnRlcm5hbF9zZXQoc2lnbmFsLCB2YWx1ZSk7XG5cblx0XHRcdFx0aWYgKERFViAmJiBsb2NhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLmFkZChzaWduYWwpO1xuXG5cdFx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAocmVjZW50X2FzeW5jX2Rlcml2ZWRzLmhhcyhzaWduYWwpKSB7XG5cdFx0XHRcdFx0XHRcdHcuYXdhaXRfd2F0ZXJmYWxsKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc2lnbmFsLmxhYmVsKSwgbG9jYXRpb24pO1xuXHRcdFx0XHRcdFx0XHRyZWNlbnRfYXN5bmNfZGVyaXZlZHMuZGVsZXRlKHNpZ25hbCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHNob3VsZF9zdXNwZW5kKSB7XG5cdFx0XHRcdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KC0xKTtcblx0XHRcdFx0aWYgKCFwZW5kaW5nKSBiYXRjaC5kZWNyZW1lbnQoKTtcblx0XHRcdH1cblxuXHRcdFx0dW5zZXRfY29udGV4dCgpO1xuXHRcdH07XG5cblx0XHRwcm9taXNlLnRoZW4oaGFuZGxlciwgKGUpID0+IGhhbmRsZXIobnVsbCwgZSB8fCAndW5rbm93bicpKTtcblxuXHRcdGlmIChiYXRjaCkge1xuXHRcdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdFx0cXVldWVNaWNyb3Rhc2soKCkgPT4gYmF0Y2gubmV1dGVyKCkpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBhZGQgYSBmbGFnIHRoYXQgbGV0cyB0aGlzIGJlIHByaW50ZWQgYXMgYSBkZXJpdmVkXG5cdFx0Ly8gd2hlbiB1c2luZyBgJGluc3BlY3QudHJhY2UoKWBcblx0XHRzaWduYWwuZiB8PSBBU1lOQztcblx0fVxuXG5cdHJldHVybiBuZXcgUHJvbWlzZSgoZnVsZmlsKSA9PiB7XG5cdFx0LyoqIEBwYXJhbSB7UHJvbWlzZTxWPn0gcCAqL1xuXHRcdGZ1bmN0aW9uIG5leHQocCkge1xuXHRcdFx0ZnVuY3Rpb24gZ28oKSB7XG5cdFx0XHRcdGlmIChwID09PSBwcm9taXNlKSB7XG5cdFx0XHRcdFx0ZnVsZmlsKHNpZ25hbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gaWYgdGhlIGVmZmVjdCByZS1ydW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBwcm9taXNlXG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZXMsIGRlbGF5IHJlc29sdXRpb24gdW50aWwgd2UgaGF2ZSBhIHZhbHVlXG5cdFx0XHRcdFx0bmV4dChwcm9taXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRwLnRoZW4oZ28sIGdvKTtcblx0XHR9XG5cblx0XHRuZXh0KHByb21pc2UpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWfSBmblxuICogQHJldHVybnMge0Rlcml2ZWQ8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJfZGVyaXZlZChmbikge1xuXHRjb25zdCBkID0gZGVyaXZlZChmbik7XG5cblx0cHVzaF9yZWFjdGlvbl92YWx1ZShkKTtcblxuXHRyZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHsoKSA9PiBWfSBmblxuICogQHJldHVybnMge0Rlcml2ZWQ8Vj59XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZWRfc2FmZV9lcXVhbChmbikge1xuXHRjb25zdCBzaWduYWwgPSBkZXJpdmVkKGZuKTtcblx0c2lnbmFsLmVxdWFscyA9IHNhZmVfZXF1YWxzO1xuXHRyZXR1cm4gc2lnbmFsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKSB7XG5cdHZhciBlZmZlY3RzID0gZGVyaXZlZC5lZmZlY3RzO1xuXG5cdGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG5cdFx0ZGVyaXZlZC5lZmZlY3RzID0gbnVsbDtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChlZmZlY3RzW2ldKSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSB1cGRhdGluZyBkZXJpdmVkcywgdXNlZCB0byBkZXRlY3QgaW5maW5pdGUgcmVjdXJzaW9uXG4gKiBpbiBkZXYgbW9kZSBhbmQgcHJvdmlkZSBhIG5pY2VyIGVycm9yIHRoYW4gJ3RvbyBtdWNoIHJlY3Vyc2lvbidcbiAqIEB0eXBlIHtEZXJpdmVkW119XG4gKi9cbmxldCBzdGFjayA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge0VmZmVjdCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldF9kZXJpdmVkX3BhcmVudF9lZmZlY3QoZGVyaXZlZCkge1xuXHR2YXIgcGFyZW50ID0gZGVyaXZlZC5wYXJlbnQ7XG5cdHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcblx0XHRpZiAoKHBhcmVudC5mICYgREVSSVZFRCkgPT09IDApIHtcblx0XHRcdHJldHVybiAvKiogQHR5cGUge0VmZmVjdH0gKi8gKHBhcmVudCk7XG5cdFx0fVxuXHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdH1cblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX2Rlcml2ZWQoZGVyaXZlZCkge1xuXHR2YXIgdmFsdWU7XG5cdHZhciBwcmV2X2FjdGl2ZV9lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdHNldF9hY3RpdmVfZWZmZWN0KGdldF9kZXJpdmVkX3BhcmVudF9lZmZlY3QoZGVyaXZlZCkpO1xuXG5cdGlmIChERVYpIHtcblx0XHRsZXQgcHJldl9pbnNwZWN0X2VmZmVjdHMgPSBpbnNwZWN0X2VmZmVjdHM7XG5cdFx0c2V0X2luc3BlY3RfZWZmZWN0cyhuZXcgU2V0KCkpO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoc3RhY2suaW5jbHVkZXMoZGVyaXZlZCkpIHtcblx0XHRcdFx0ZS5kZXJpdmVkX3JlZmVyZW5jZXNfc2VsZigpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdGFjay5wdXNoKGRlcml2ZWQpO1xuXG5cdFx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyhkZXJpdmVkKTtcblx0XHRcdHZhbHVlID0gdXBkYXRlX3JlYWN0aW9uKGRlcml2ZWQpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2X2FjdGl2ZV9lZmZlY3QpO1xuXHRcdFx0c2V0X2luc3BlY3RfZWZmZWN0cyhwcmV2X2luc3BlY3RfZWZmZWN0cyk7XG5cdFx0XHRzdGFjay5wb3AoKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dHJ5IHtcblx0XHRcdGRlc3Ryb3lfZGVyaXZlZF9lZmZlY3RzKGRlcml2ZWQpO1xuXHRcdFx0dmFsdWUgPSB1cGRhdGVfcmVhY3Rpb24oZGVyaXZlZCk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZfYWN0aXZlX2VmZmVjdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVyaXZlZH0gZGVyaXZlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZGVyaXZlZChkZXJpdmVkKSB7XG5cdHZhciB2YWx1ZSA9IGV4ZWN1dGVfZGVyaXZlZChkZXJpdmVkKTtcblxuXHRpZiAoIWRlcml2ZWQuZXF1YWxzKHZhbHVlKSkge1xuXHRcdGRlcml2ZWQudiA9IHZhbHVlO1xuXHRcdGRlcml2ZWQud3YgPSBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpO1xuXHR9XG5cblx0Ly8gZG9uJ3QgbWFyayBkZXJpdmVkIGNsZWFuIGlmIHdlJ3JlIHJlYWRpbmcgaXQgaW5zaWRlIGFcblx0Ly8gY2xlYW51cCBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYWNoZSBhIHN0YWxlIHZhbHVlXG5cdGlmIChpc19kZXN0cm95aW5nX2VmZmVjdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChiYXRjaF9kZXJpdmVkcyAhPT0gbnVsbCkge1xuXHRcdGJhdGNoX2Rlcml2ZWRzLnNldChkZXJpdmVkLCBkZXJpdmVkLnYpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBzdGF0dXMgPVxuXHRcdFx0KHNraXBfcmVhY3Rpb24gfHwgKGRlcml2ZWQuZiAmIFVOT1dORUQpICE9PSAwKSAmJiBkZXJpdmVkLmRlcHMgIT09IG51bGwgPyBNQVlCRV9ESVJUWSA6IENMRUFOO1xuXG5cdFx0c2V0X3NpZ25hbF9zdGF0dXMoZGVyaXZlZCwgc3RhdHVzKTtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5cbmltcG9ydCB7IERFU1RST1lFRCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQsIGlzX3J1bmVzLCBzZXRfY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGdldF9wZW5kaW5nX2JvdW5kYXJ5IH0gZnJvbSAnLi4vZG9tL2Jsb2Nrcy9ib3VuZGFyeS5qcyc7XG5pbXBvcnQgeyBpbnZva2VfZXJyb3JfYm91bmRhcnkgfSBmcm9tICcuLi9lcnJvci1oYW5kbGluZy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgY3VycmVudF9iYXRjaCwgc3VzcGVuZCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHtcblx0YXN5bmNfZGVyaXZlZCxcblx0Y3VycmVudF9hc3luY19lZmZlY3QsXG5cdGRlcml2ZWQsXG5cdGRlcml2ZWRfc2FmZV9lcXVhbCxcblx0c2V0X2Zyb21fYXN5bmNfZGVyaXZlZFxufSBmcm9tICcuL2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IGFib3J0ZWQgfSBmcm9tICcuL2VmZmVjdHMuanMnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IGFueT59IHN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gUHJvbWlzZTxhbnk+Pn0gYXN5bmNcbiAqIEBwYXJhbSB7KHZhbHVlczogVmFsdWVbXSkgPT4gYW55fSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbihzeW5jLCBhc3luYywgZm4pIHtcblx0Y29uc3QgZCA9IGlzX3J1bmVzKCkgPyBkZXJpdmVkIDogZGVyaXZlZF9zYWZlX2VxdWFsO1xuXG5cdGlmIChhc3luYy5sZW5ndGggPT09IDApIHtcblx0XHRmbihzeW5jLm1hcChkKSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIGJhdGNoID0gY3VycmVudF9iYXRjaDtcblx0dmFyIHBhcmVudCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0dmFyIHJlc3RvcmUgPSBjYXB0dXJlKCk7XG5cdHZhciBib3VuZGFyeSA9IGdldF9wZW5kaW5nX2JvdW5kYXJ5KCk7XG5cblx0UHJvbWlzZS5hbGwoYXN5bmMubWFwKChleHByZXNzaW9uKSA9PiBhc3luY19kZXJpdmVkKGV4cHJlc3Npb24pKSlcblx0XHQudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRiYXRjaD8uYWN0aXZhdGUoKTtcblxuXHRcdFx0cmVzdG9yZSgpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmbihbLi4uc3luYy5tYXAoZCksIC4uLnJlc3VsdF0pO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVycm9ycyBpbiBibG9ja3MgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcblx0XHRcdFx0aWYgKChwYXJlbnQuZiAmIERFU1RST1lFRCkgPT09IDApIHtcblx0XHRcdFx0XHRpbnZva2VfZXJyb3JfYm91bmRhcnkoZXJyb3IsIHBhcmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0YmF0Y2g/LmRlYWN0aXZhdGUoKTtcblx0XHRcdHVuc2V0X2NvbnRleHQoKTtcblx0XHR9KVxuXHRcdC5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHRcdGJvdW5kYXJ5LmVycm9yKGVycm9yKTtcblx0XHR9KTtcbn1cblxuLyoqXG4gKiBDYXB0dXJlcyB0aGUgY3VycmVudCBlZmZlY3QgY29udGV4dCBzbyB0aGF0IHdlIGNhbiByZXN0b3JlIGl0IGFmdGVyXG4gKiBzb21lIGFzeW5jaHJvbm91cyB3b3JrIGhhcyBoYXBwZW5lZCAoc28gdGhhdCBlLmcuIGBhd2FpdCBhICsgYmBcbiAqIGNhdXNlcyBgYmAgdG8gYmUgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGVuY3kpLlxuICovXG5mdW5jdGlvbiBjYXB0dXJlKCkge1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0dmFyIHByZXZpb3VzX2JhdGNoID0gY3VycmVudF9iYXRjaDtcblxuXHRyZXR1cm4gZnVuY3Rpb24gcmVzdG9yZSgpIHtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdHNldF9jb21wb25lbnRfY29udGV4dChwcmV2aW91c19jb21wb25lbnRfY29udGV4dCk7XG5cdFx0cHJldmlvdXNfYmF0Y2g/LmFjdGl2YXRlKCk7XG5cblx0XHRpZiAoREVWKSB7XG5cdFx0XHRzZXRfZnJvbV9hc3luY19kZXJpdmVkKG51bGwpO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBXcmFwcyBhbiBgYXdhaXRgIGV4cHJlc3Npb24gaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBlZmZlY3QgY29udGV4dCB0aGF0IHdhc1xuICogYWN0aXZlIGJlZm9yZSB0aGUgZXhwcmVzc2lvbiBldmFsdWF0ZWQgY2FuIGJlIHJlYXBwbGllZCBhZnRlcndhcmRzIFx1MjAxNFxuICogYGF3YWl0IGEgKyBiYCBiZWNvbWVzIGAoYXdhaXQgJC5zYXZlKGEpKSgpICsgYmBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1Byb21pc2U8VD59IHByb21pc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPCgpID0+IFQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZShwcm9taXNlKSB7XG5cdHZhciByZXN0b3JlID0gY2FwdHVyZSgpO1xuXHR2YXIgdmFsdWUgPSBhd2FpdCBwcm9taXNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0cmVzdG9yZSgpO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXNldCBgY3VycmVudF9hc3luY19lZmZlY3RgIGFmdGVyIHRoZSBgcHJvbWlzZWAgcmVzb2x2ZXMsIHNvXG4gKiB0aGF0IHdlIGNhbiBlbWl0IGBhd2FpdF9yZWFjdGl2aXR5X2xvc3NgIHdhcm5pbmdzXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtQcm9taXNlPFQ+fSBwcm9taXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwoKSA9PiBUPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYWNrX3JlYWN0aXZpdHlfbG9zcyhwcm9taXNlKSB7XG5cdHZhciBwcmV2aW91c19hc3luY19lZmZlY3QgPSBjdXJyZW50X2FzeW5jX2VmZmVjdDtcblx0dmFyIHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdHNldF9mcm9tX2FzeW5jX2Rlcml2ZWQocHJldmlvdXNfYXN5bmNfZWZmZWN0KTtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG59XG5cbi8qKlxuICogVXNlZCBpbiBgZm9yIGF3YWl0YCBsb29wcyBpbiBERVYsIHNvXG4gKiB0aGF0IHdlIGNhbiBlbWl0IGBhd2FpdF9yZWFjdGl2aXR5X2xvc3NgIHdhcm5pbmdzXG4gKiBhZnRlciBlYWNoIGBhc3luY19pdGVyYXRvcmAgcmVzdWx0IHJlc29sdmVzIGFuZFxuICogYWZ0ZXIgdGhlIGBhc3luY19pdGVyYXRvcmAgcmV0dXJuIHJlc29sdmVzIChpZiBpdCBydW5zKVxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBUUmV0dXJuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+IHwgQXN5bmNJdGVyYWJsZTxUPn0gaXRlcmFibGVcbiAqIEByZXR1cm5zIHtBc3luY0dlbmVyYXRvcjxULCBUUmV0dXJuIHwgdW5kZWZpbmVkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiBmb3JfYXdhaXRfdHJhY2tfcmVhY3Rpdml0eV9sb3NzKGl0ZXJhYmxlKSB7XG5cdC8vIFRoaXMgaXMgYmFzZWQgb24gdGhlIGFsZ29yaXRobXMgZGVzY3JpYmVkIGluIEVDTUEtMjYyOlxuXHQvLyBGb3JJbi9PZkJvZHlFdmFsdWF0aW9uXG5cdC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyL211bHRpcGFnZS9lY21hc2NyaXB0LWxhbmd1YWdlLXN0YXRlbWVudHMtYW5kLWRlY2xhcmF0aW9ucy5odG1sI3NlYy1ydW50aW1lLXNlbWFudGljcy1mb3Jpbi1kaXYtb2Zib2R5ZXZhbHVhdGlvbi1saHMtc3RtdC1pdGVyYXRvci1saHNraW5kLWxhYmVsc2V0XG5cdC8vIEFzeW5jSXRlcmF0b3JDbG9zZVxuXHQvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi9tdWx0aXBhZ2UvYWJzdHJhY3Qtb3BlcmF0aW9ucy5odG1sI3NlYy1hc3luY2l0ZXJhdG9yY2xvc2VcblxuXHQvKiogQHR5cGUge0FzeW5jSXRlcmF0b3I8VCwgVFJldHVybj59ICovXG5cdC8vIEB0cy1pZ25vcmVcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0/LigpID8/IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0/LigpO1xuXG5cdGlmIChpdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcigndmFsdWUgaXMgbm90IGFzeW5jIGl0ZXJhYmxlJyk7XG5cdH1cblxuXHQvKiogV2hldGhlciB0aGUgY29tcGxldGlvbiBvZiB0aGUgaXRlcmF0b3Igd2FzIFwibm9ybWFsXCIsIG1lYW5pbmcgaXQgd2Fzbid0IGVuZGVkIHZpYSBgYnJlYWtgIG9yIGEgc2ltaWxhciBtZXRob2QgKi9cblx0bGV0IG5vcm1hbF9jb21wbGV0aW9uID0gZmFsc2U7XG5cdHRyeSB7XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IChhd2FpdCB0cmFja19yZWFjdGl2aXR5X2xvc3MoaXRlcmF0b3IubmV4dCgpKSkoKTtcblx0XHRcdGlmIChkb25lKSB7XG5cdFx0XHRcdG5vcm1hbF9jb21wbGV0aW9uID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHR5aWVsZCB2YWx1ZTtcblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gSWYgdGhlIGl0ZXJhdG9yIGhhZCBhIG5vcm1hbCBjb21wbGV0aW9uIGFuZCBgcmV0dXJuYCBpcyBkZWZpbmVkIG9uIHRoZSBpdGVyYXRvciwgY2FsbCBpdCBhbmQgcmV0dXJuIHRoZSB2YWx1ZVxuXHRcdGlmIChub3JtYWxfY29tcGxldGlvbiAmJiBpdGVyYXRvci5yZXR1cm4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuc2FmZS1maW5hbGx5XG5cdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtUUmV0dXJufSAqLyAoKGF3YWl0IHRyYWNrX3JlYWN0aXZpdHlfbG9zcyhpdGVyYXRvci5yZXR1cm4oKSkpKCkudmFsdWUpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zZXRfY29udGV4dCgpIHtcblx0c2V0X2FjdGl2ZV9lZmZlY3QobnVsbCk7XG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9jb21wb25lbnRfY29udGV4dChudWxsKTtcblx0aWYgKERFVikgc2V0X2Zyb21fYXN5bmNfZGVyaXZlZChudWxsKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IFByb21pc2U8dm9pZD59IGZuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY19ib2R5KGZuKSB7XG5cdHZhciB1bnN1c3BlbmQgPSBzdXNwZW5kKCk7XG5cdHZhciBhY3RpdmUgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdHRyeSB7XG5cdFx0YXdhaXQgZm4oKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRpZiAoIWFib3J0ZWQoYWN0aXZlKSkge1xuXHRcdFx0aW52b2tlX2Vycm9yX2JvdW5kYXJ5KGVycm9yLCBhY3RpdmUpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHR1bnN1c3BlbmQoKTtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRGVyaXZlZCwgRWZmZWN0LCBTb3VyY2UgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHtcblx0QkxPQ0tfRUZGRUNULFxuXHRCUkFOQ0hfRUZGRUNULFxuXHRDTEVBTixcblx0REVTVFJPWUVELFxuXHRESVJUWSxcblx0RUZGRUNULFxuXHRBU1lOQyxcblx0SU5FUlQsXG5cdFJFTkRFUl9FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRVU0VSX0VGRkVDVCxcblx0TUFZQkVfRElSVFlcbn0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuaW1wb3J0IHsgZGVmZXJyZWQsIGRlZmluZV9wcm9wZXJ0eSB9IGZyb20gJy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBnZXRfcGVuZGluZ19ib3VuZGFyeSB9IGZyb20gJy4uL2RvbS9ibG9ja3MvYm91bmRhcnkuanMnO1xuaW1wb3J0IHtcblx0YWN0aXZlX2VmZmVjdCxcblx0aXNfZGlydHksXG5cdGlzX3VwZGF0aW5nX2VmZmVjdCxcblx0c2V0X2lzX3VwZGF0aW5nX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVwZGF0ZV9lZmZlY3Rcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBmbHVzaF90YXNrcyB9IGZyb20gJy4uL2RvbS90YXNrLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaW52b2tlX2Vycm9yX2JvdW5kYXJ5IH0gZnJvbSAnLi4vZXJyb3ItaGFuZGxpbmcuanMnO1xuaW1wb3J0IHsgb2xkX3ZhbHVlcyB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyB1bmxpbmtfZWZmZWN0IH0gZnJvbSAnLi9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHVuc2V0X2NvbnRleHQgfSBmcm9tICcuL2FzeW5jLmpzJztcblxuLyoqIEB0eXBlIHtTZXQ8QmF0Y2g+fSAqL1xuY29uc3QgYmF0Y2hlcyA9IG5ldyBTZXQoKTtcblxuLyoqIEB0eXBlIHtCYXRjaCB8IG51bGx9ICovXG5leHBvcnQgbGV0IGN1cnJlbnRfYmF0Y2ggPSBudWxsO1xuXG4vKipcbiAqIFRoaXMgaXMgbmVlZGVkIHRvIGF2b2lkIG92ZXJ3cml0aW5nIGlucHV0cyBpbiBub24tYXN5bmMgbW9kZVxuICogVE9ETyA2LjAgcmVtb3ZlIHRoaXMsIGFzIG5vbi1hc3luYyBtb2RlIHdpbGwgZ28gYXdheVxuICogQHR5cGUge0JhdGNoIHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBwcmV2aW91c19iYXRjaCA9IG51bGw7XG5cbi8qKlxuICogV2hlbiB0aW1lIHRyYXZlbGxpbmcsIHdlIHJlLWV2YWx1YXRlIGRlcml2ZWRzIGJhc2VkIG9uIHRoZSB0ZW1wb3JhcnlcbiAqIHZhbHVlcyBvZiB0aGVpciBkZXBlbmRlbmNpZXMgcmF0aGVyIHRoYW4gdGhlaXIgYWN0dWFsIHZhbHVlcywgYW5kIGNhY2hlXG4gKiB0aGUgcmVzdWx0cyBpbiB0aGlzIG1hcCByYXRoZXIgdGhhbiBvbiB0aGUgZGVyaXZlZHMgdGhlbXNlbHZlc1xuICogQHR5cGUge01hcDxEZXJpdmVkLCBhbnk+IHwgbnVsbH1cbiAqL1xuZXhwb3J0IGxldCBiYXRjaF9kZXJpdmVkcyA9IG51bGw7XG5cbi8qKiBAdHlwZSB7U2V0PCgpID0+IHZvaWQ+fSAqL1xuZXhwb3J0IGxldCBlZmZlY3RfcGVuZGluZ191cGRhdGVzID0gbmV3IFNldCgpO1xuXG4vKiogQHR5cGUge0FycmF5PCgpID0+IHZvaWQ+fSAqL1xubGV0IHRhc2tzID0gW107XG5cbmZ1bmN0aW9uIGRlcXVldWUoKSB7XG5cdGNvbnN0IHRhc2sgPSAvKiogQHR5cGUgeygpID0+IHZvaWR9ICovICh0YXNrcy5zaGlmdCgpKTtcblxuXHRpZiAodGFza3MubGVuZ3RoID4gMCkge1xuXHRcdHF1ZXVlTWljcm90YXNrKGRlcXVldWUpO1xuXHR9XG5cblx0dGFzaygpO1xufVxuXG4vKiogQHR5cGUge0VmZmVjdFtdfSAqL1xubGV0IHF1ZXVlZF9yb290X2VmZmVjdHMgPSBbXTtcblxuLyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xubGV0IGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cbmxldCBpc19mbHVzaGluZyA9IGZhbHNlO1xubGV0IGlzX2ZsdXNoaW5nX3N5bmMgPSBmYWxzZTtcblxuZXhwb3J0IGNsYXNzIEJhdGNoIHtcblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50IHZhbHVlcyBvZiBhbnkgc291cmNlcyB0aGF0IGFyZSB1cGRhdGVkIGluIHRoaXMgYmF0Y2hcblx0ICogVGhleSBrZXlzIG9mIHRoaXMgbWFwIGFyZSBpZGVudGljYWwgdG8gYHRoaXMuI3ByZXZpb3VzYFxuXHQgKiBAdHlwZSB7TWFwPFNvdXJjZSwgYW55Pn1cblx0ICovXG5cdGN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cblx0LyoqXG5cdCAqIFRoZSB2YWx1ZXMgb2YgYW55IHNvdXJjZXMgdGhhdCBhcmUgdXBkYXRlZCBpbiB0aGlzIGJhdGNoIF9iZWZvcmVfIHRob3NlIHVwZGF0ZXMgdG9vayBwbGFjZS5cblx0ICogVGhleSBrZXlzIG9mIHRoaXMgbWFwIGFyZSBpZGVudGljYWwgdG8gYHRoaXMuI2N1cnJlbnRgXG5cdCAqIEB0eXBlIHtNYXA8U291cmNlLCBhbnk+fVxuXHQgKi9cblx0I3ByZXZpb3VzID0gbmV3IE1hcCgpO1xuXG5cdC8qKlxuXHQgKiBXaGVuIHRoZSBiYXRjaCBpcyBjb21taXR0ZWQgKGFuZCB0aGUgRE9NIGlzIHVwZGF0ZWQpLCB3ZSBuZWVkIHRvIHJlbW92ZSBvbGQgYnJhbmNoZXNcblx0ICogYW5kIGFwcGVuZCBuZXcgb25lcyBieSBjYWxsaW5nIHRoZSBmdW5jdGlvbnMgYWRkZWQgaW5zaWRlIChpZi9lYWNoL2tleS9ldGMpIGJsb2Nrc1xuXHQgKiBAdHlwZSB7U2V0PCgpID0+IHZvaWQ+fVxuXHQgKi9cblx0I2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcblxuXHQvKipcblx0ICogVGhlIG51bWJlciBvZiBhc3luYyBlZmZlY3RzIHRoYXQgYXJlIGN1cnJlbnRseSBpbiBmbGlnaHRcblx0ICovXG5cdCNwZW5kaW5nID0gMDtcblxuXHQvKipcblx0ICogQSBkZWZlcnJlZCB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGJhdGNoIGlzIGNvbW1pdHRlZCwgdXNlZCB3aXRoIGBzZXR0bGVkKClgXG5cdCAqIFRPRE8gcmVwbGFjZSB3aXRoIFByb21pc2Uud2l0aFJlc29sdmVycyBvbmNlIHN1cHBvcnRlZCB3aWRlbHkgZW5vdWdoXG5cdCAqIEB0eXBlIHt7IHByb21pc2U6IFByb21pc2U8dm9pZD4sIHJlc29sdmU6ICh2YWx1ZT86IGFueSkgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uOiB1bmtub3duKSA9PiB2b2lkIH0gfCBudWxsfVxuXHQgKi9cblx0I2RlZmVycmVkID0gbnVsbDtcblxuXHQvKipcblx0ICogVHJ1ZSBpZiBhbiBhc3luYyBlZmZlY3QgaW5zaWRlIHRoaXMgYmF0Y2ggcmVzb2x2ZWQgYW5kXG5cdCAqIGl0cyBwYXJlbnQgYnJhbmNoIHdhcyBhbHJlYWR5IGRlbGV0ZWRcblx0ICovXG5cdCNuZXV0ZXJlZCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBBc3luYyBlZmZlY3RzIChjcmVhdGVkIGluc2lkZSBgYXN5bmNfZGVyaXZlZGApIGVuY291bnRlcmVkIGR1cmluZyBwcm9jZXNzaW5nLlxuXHQgKiBUaGVzZSBydW4gYWZ0ZXIgdGhlIHJlc3Qgb2YgdGhlIGJhdGNoIGhhcyB1cGRhdGVkLCBzaW5jZSB0aGV5IHNob3VsZFxuXHQgKiBhbHdheXMgaGF2ZSB0aGUgbGF0ZXN0IHZhbHVlc1xuXHQgKiBAdHlwZSB7RWZmZWN0W119XG5cdCAqL1xuXHQjYXN5bmNfZWZmZWN0cyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBUaGUgc2FtZSBhcyBgI2FzeW5jX2VmZmVjdHNgLCBidXQgZm9yIGVmZmVjdHMgaW5zaWRlIGEgbmV3bHktY3JlYXRlZFxuXHQgKiBgPHN2ZWx0ZTpib3VuZGFyeT5gIFx1MjAxNCB0aGVzZSBkbyBub3QgcHJldmVudCB0aGUgYmF0Y2ggZnJvbSBjb21taXR0aW5nXG5cdCAqIEB0eXBlIHtFZmZlY3RbXX1cblx0ICovXG5cdCNib3VuZGFyeV9hc3luY19lZmZlY3RzID0gW107XG5cblx0LyoqXG5cdCAqIFRlbXBsYXRlIGVmZmVjdHMgYW5kIGAkZWZmZWN0LnByZWAgZWZmZWN0cywgd2hpY2ggcnVuIHdoZW5cblx0ICogYSBiYXRjaCBpcyBjb21taXR0ZWRcblx0ICogQHR5cGUge0VmZmVjdFtdfVxuXHQgKi9cblx0I3JlbmRlcl9lZmZlY3RzID0gW107XG5cblx0LyoqXG5cdCAqIFRoZSBzYW1lIGFzIGAjcmVuZGVyX2VmZmVjdHNgLCBidXQgZm9yIGAkZWZmZWN0YCAod2hpY2ggcnVucyBhZnRlcilcblx0ICogQHR5cGUge0VmZmVjdFtdfVxuXHQgKi9cblx0I2VmZmVjdHMgPSBbXTtcblxuXHQvKipcblx0ICogQmxvY2sgZWZmZWN0cywgd2hpY2ggbWF5IG5lZWQgdG8gcmUtcnVuIG9uIHN1YnNlcXVlbnQgZmx1c2hlc1xuXHQgKiBpbiBvcmRlciB0byB1cGRhdGUgaW50ZXJuYWwgc291cmNlcyAoZS5nLiBlYWNoIGJsb2NrIGl0ZW1zKVxuXHQgKiBAdHlwZSB7RWZmZWN0W119XG5cdCAqL1xuXHQjYmxvY2tfZWZmZWN0cyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBEZWZlcnJlZCBlZmZlY3RzICh3aGljaCBydW4gYWZ0ZXIgYXN5bmMgd29yayBoYXMgY29tcGxldGVkKSB0aGF0IGFyZSBESVJUWVxuXHQgKiBAdHlwZSB7RWZmZWN0W119XG5cdCAqL1xuXHQjZGlydHlfZWZmZWN0cyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBEZWZlcnJlZCBlZmZlY3RzIHRoYXQgYXJlIE1BWUJFX0RJUlRZXG5cdCAqIEB0eXBlIHtFZmZlY3RbXX1cblx0ICovXG5cdCNtYXliZV9kaXJ0eV9lZmZlY3RzID0gW107XG5cblx0LyoqXG5cdCAqIEEgc2V0IG9mIGJyYW5jaGVzIHRoYXQgc3RpbGwgZXhpc3QsIGJ1dCB3aWxsIGJlIGRlc3Ryb3llZCB3aGVuIHRoaXMgYmF0Y2hcblx0ICogaXMgY29tbWl0dGVkIFx1MjAxNCB3ZSBza2lwIG92ZXIgdGhlc2UgZHVyaW5nIGBwcm9jZXNzYFxuXHQgKiBAdHlwZSB7U2V0PEVmZmVjdD59XG5cdCAqL1xuXHRza2lwcGVkX2VmZmVjdHMgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWZmZWN0W119IHJvb3RfZWZmZWN0c1xuXHQgKi9cblx0cHJvY2Vzcyhyb290X2VmZmVjdHMpIHtcblx0XHRxdWV1ZWRfcm9vdF9lZmZlY3RzID0gW107XG5cblx0XHRwcmV2aW91c19iYXRjaCA9IG51bGw7XG5cblx0XHQvKiogQHR5cGUge01hcDxTb3VyY2UsIHsgdjogdW5rbm93biwgd3Y6IG51bWJlciB9PiB8IG51bGx9ICovXG5cdFx0dmFyIGN1cnJlbnRfdmFsdWVzID0gbnVsbDtcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBiYXRjaGVzLCB3ZSBhcmUgJ3RpbWUgdHJhdmVsbGluZycgXHUyMDE0XG5cdFx0Ly8gd2UgbmVlZCB0byB1bmRvIHRoZSBjaGFuZ2VzIGJlbG9uZ2luZyB0byBhbnkgYmF0Y2hcblx0XHQvLyBvdGhlciB0aGFuIHRoZSBjdXJyZW50IG9uZVxuXHRcdGlmIChhc3luY19tb2RlX2ZsYWcgJiYgYmF0Y2hlcy5zaXplID4gMSkge1xuXHRcdFx0Y3VycmVudF92YWx1ZXMgPSBuZXcgTWFwKCk7XG5cdFx0XHRiYXRjaF9kZXJpdmVkcyA9IG5ldyBNYXAoKTtcblxuXHRcdFx0Zm9yIChjb25zdCBbc291cmNlLCBjdXJyZW50XSBvZiB0aGlzLmN1cnJlbnQpIHtcblx0XHRcdFx0Y3VycmVudF92YWx1ZXMuc2V0KHNvdXJjZSwgeyB2OiBzb3VyY2Uudiwgd3Y6IHNvdXJjZS53diB9KTtcblx0XHRcdFx0c291cmNlLnYgPSBjdXJyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGNvbnN0IGJhdGNoIG9mIGJhdGNoZXMpIHtcblx0XHRcdFx0aWYgKGJhdGNoID09PSB0aGlzKSBjb250aW51ZTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IFtzb3VyY2UsIHByZXZpb3VzXSBvZiBiYXRjaC4jcHJldmlvdXMpIHtcblx0XHRcdFx0XHRpZiAoIWN1cnJlbnRfdmFsdWVzLmhhcyhzb3VyY2UpKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50X3ZhbHVlcy5zZXQoc291cmNlLCB7IHY6IHNvdXJjZS52LCB3djogc291cmNlLnd2IH0pO1xuXHRcdFx0XHRcdFx0c291cmNlLnYgPSBwcmV2aW91cztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdF9lZmZlY3RzKSB7XG5cdFx0XHR0aGlzLiN0cmF2ZXJzZV9lZmZlY3RfdHJlZShyb290KTtcblx0XHR9XG5cblx0XHQvLyBpZiB3ZSBkaWRuJ3Qgc3RhcnQgYW55IG5ldyBhc3luYyB3b3JrLCBhbmQgbm8gYXN5bmMgd29ya1xuXHRcdC8vIGlzIG91dHN0YW5kaW5nIGZyb20gYSBwcmV2aW91cyBmbHVzaCwgY29tbWl0XG5cdFx0aWYgKHRoaXMuI2FzeW5jX2VmZmVjdHMubGVuZ3RoID09PSAwICYmIHRoaXMuI3BlbmRpbmcgPT09IDApIHtcblx0XHRcdHRoaXMuI2NvbW1pdCgpO1xuXG5cdFx0XHR2YXIgcmVuZGVyX2VmZmVjdHMgPSB0aGlzLiNyZW5kZXJfZWZmZWN0cztcblx0XHRcdHZhciBlZmZlY3RzID0gdGhpcy4jZWZmZWN0cztcblxuXHRcdFx0dGhpcy4jcmVuZGVyX2VmZmVjdHMgPSBbXTtcblx0XHRcdHRoaXMuI2VmZmVjdHMgPSBbXTtcblx0XHRcdHRoaXMuI2Jsb2NrX2VmZmVjdHMgPSBbXTtcblxuXHRcdFx0Ly8gSWYgc291cmNlcyBhcmUgd3JpdHRlbiB0bywgdGhlbiB3b3JrIG5lZWRzIHRvIGhhcHBlbiBpbiBhIHNlcGFyYXRlIGJhdGNoLCBlbHNlIHByaW9yIHNvdXJjZXMgd291bGQgYmUgbWl4ZWQgd2l0aFxuXHRcdFx0Ly8gbmV3bHkgdXBkYXRlZCBzb3VyY2VzLCB3aGljaCBjb3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3BzIHdoZW4gZWZmZWN0cyBydW4gb3ZlciBhbmQgb3ZlciBhZ2Fpbi5cblx0XHRcdHByZXZpb3VzX2JhdGNoID0gY3VycmVudF9iYXRjaDtcblx0XHRcdGN1cnJlbnRfYmF0Y2ggPSBudWxsO1xuXG5cdFx0XHRmbHVzaF9xdWV1ZWRfZWZmZWN0cyhyZW5kZXJfZWZmZWN0cyk7XG5cdFx0XHRmbHVzaF9xdWV1ZWRfZWZmZWN0cyhlZmZlY3RzKTtcblxuXHRcdFx0Ly8gUmVpbnN0YXRlIHRoZSBjdXJyZW50IGJhdGNoIGlmIHRoZXJlIHdhcyBubyBuZXcgb25lIGNyZWF0ZWQsIGFzIGBwcm9jZXNzKClgIHJ1bnMgaW4gYSBsb29wIGluIGBmbHVzaF9lZmZlY3RzKClgLlxuXHRcdFx0Ly8gVGhhdCBtZXRob2QgZXhwZWN0cyBgY3VycmVudF9iYXRjaGAgdG8gYmUgc2V0LCBhbmQgY291bGQgcnVuIHRoZSBsb29wIGFnYWluIGlmIGVmZmVjdHMgcmVzdWx0IGluIG5ldyBlZmZlY3RzXG5cdFx0XHQvLyBiZWluZyBzY2hlZHVsZWQgYnV0IHdpdGhvdXQgd3JpdGVzIGhhcHBlbmluZyBpbiB3aGljaCBjYXNlIG5vIG5ldyBiYXRjaCBpcyBjcmVhdGVkLlxuXHRcdFx0aWYgKGN1cnJlbnRfYmF0Y2ggPT09IG51bGwpIHtcblx0XHRcdFx0Y3VycmVudF9iYXRjaCA9IHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRiYXRjaGVzLmRlbGV0ZSh0aGlzKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy4jZGVmZXJyZWQ/LnJlc29sdmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4jZGVmZXJfZWZmZWN0cyh0aGlzLiNyZW5kZXJfZWZmZWN0cyk7XG5cdFx0XHR0aGlzLiNkZWZlcl9lZmZlY3RzKHRoaXMuI2VmZmVjdHMpO1xuXHRcdFx0dGhpcy4jZGVmZXJfZWZmZWN0cyh0aGlzLiNibG9ja19lZmZlY3RzKTtcblx0XHR9XG5cblx0XHRpZiAoY3VycmVudF92YWx1ZXMpIHtcblx0XHRcdGZvciAoY29uc3QgW3NvdXJjZSwgeyB2LCB3diB9XSBvZiBjdXJyZW50X3ZhbHVlcykge1xuXHRcdFx0XHQvLyByZXNldCB0aGUgc291cmNlIHRvIHRoZSBjdXJyZW50IHZhbHVlICh1bmxlc3Ncblx0XHRcdFx0Ly8gaXQgZ290IGEgbmV3ZXIgdmFsdWUgYXMgYSByZXN1bHQgb2YgZWZmZWN0cyBydW5uaW5nKVxuXHRcdFx0XHRpZiAoc291cmNlLnd2IDw9IHd2KSB7XG5cdFx0XHRcdFx0c291cmNlLnYgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGJhdGNoX2Rlcml2ZWRzID0gbnVsbDtcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IGVmZmVjdCBvZiB0aGlzLiNhc3luY19lZmZlY3RzKSB7XG5cdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBlZmZlY3Qgb2YgdGhpcy4jYm91bmRhcnlfYXN5bmNfZWZmZWN0cykge1xuXHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXHRcdH1cblxuXHRcdHRoaXMuI2FzeW5jX2VmZmVjdHMgPSBbXTtcblx0XHR0aGlzLiNib3VuZGFyeV9hc3luY19lZmZlY3RzID0gW107XG5cdH1cblxuXHQvKipcblx0ICogVHJhdmVyc2UgdGhlIGVmZmVjdCB0cmVlLCBleGVjdXRpbmcgZWZmZWN0cyBvciBzdGFzaGluZ1xuXHQgKiB0aGVtIGZvciBsYXRlciBleGVjdXRpb24gYXMgYXBwcm9wcmlhdGVcblx0ICogQHBhcmFtIHtFZmZlY3R9IHJvb3Rcblx0ICovXG5cdCN0cmF2ZXJzZV9lZmZlY3RfdHJlZShyb290KSB7XG5cdFx0cm9vdC5mIF49IENMRUFOO1xuXG5cdFx0dmFyIGVmZmVjdCA9IHJvb3QuZmlyc3Q7XG5cblx0XHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblx0XHRcdHZhciBpc19icmFuY2ggPSAoZmxhZ3MgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgIT09IDA7XG5cdFx0XHR2YXIgaXNfc2tpcHBhYmxlX2JyYW5jaCA9IGlzX2JyYW5jaCAmJiAoZmxhZ3MgJiBDTEVBTikgIT09IDA7XG5cblx0XHRcdHZhciBza2lwID0gaXNfc2tpcHBhYmxlX2JyYW5jaCB8fCAoZmxhZ3MgJiBJTkVSVCkgIT09IDAgfHwgdGhpcy5za2lwcGVkX2VmZmVjdHMuaGFzKGVmZmVjdCk7XG5cblx0XHRcdGlmICghc2tpcCAmJiBlZmZlY3QuZm4gIT09IG51bGwpIHtcblx0XHRcdFx0aWYgKGlzX2JyYW5jaCkge1xuXHRcdFx0XHRcdGVmZmVjdC5mIF49IENMRUFOO1xuXHRcdFx0XHR9IGVsc2UgaWYgKChmbGFncyAmIEVGRkVDVCkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLiNlZmZlY3RzLnB1c2goZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIGlmIChhc3luY19tb2RlX2ZsYWcgJiYgKGZsYWdzICYgUkVOREVSX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdFx0XHR0aGlzLiNyZW5kZXJfZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoKGZsYWdzICYgQ0xFQU4pID09PSAwKSB7XG5cdFx0XHRcdFx0aWYgKChmbGFncyAmIEFTWU5DKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0dmFyIGVmZmVjdHMgPSBlZmZlY3QuYj8ucGVuZGluZyA/IHRoaXMuI2JvdW5kYXJ5X2FzeW5jX2VmZmVjdHMgOiB0aGlzLiNhc3luY19lZmZlY3RzO1xuXHRcdFx0XHRcdFx0ZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChpc19kaXJ0eShlZmZlY3QpKSB7XG5cdFx0XHRcdFx0XHRpZiAoKGVmZmVjdC5mICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkgdGhpcy4jYmxvY2tfZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG5cdFx0XHRcdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNoaWxkID0gZWZmZWN0LmZpcnN0O1xuXG5cdFx0XHRcdGlmIChjaGlsZCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGVmZmVjdCA9IGNoaWxkO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXJlbnQgPSBlZmZlY3QucGFyZW50O1xuXHRcdFx0ZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG5cblx0XHRcdHdoaWxlIChlZmZlY3QgPT09IG51bGwgJiYgcGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdGVmZmVjdCA9IHBhcmVudC5uZXh0O1xuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VmZmVjdFtdfSBlZmZlY3RzXG5cdCAqL1xuXHQjZGVmZXJfZWZmZWN0cyhlZmZlY3RzKSB7XG5cdFx0Zm9yIChjb25zdCBlIG9mIGVmZmVjdHMpIHtcblx0XHRcdGNvbnN0IHRhcmdldCA9IChlLmYgJiBESVJUWSkgIT09IDAgPyB0aGlzLiNkaXJ0eV9lZmZlY3RzIDogdGhpcy4jbWF5YmVfZGlydHlfZWZmZWN0cztcblx0XHRcdHRhcmdldC5wdXNoKGUpO1xuXG5cdFx0XHQvLyBtYXJrIGFzIGNsZWFuIHNvIHRoZXkgZ2V0IHNjaGVkdWxlZCBpZiB0aGV5IGRlcGVuZCBvbiBwZW5kaW5nIGFzeW5jIHN0YXRlXG5cdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlLCBDTEVBTik7XG5cdFx0fVxuXG5cdFx0ZWZmZWN0cy5sZW5ndGggPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFzc29jaWF0ZSBhIGNoYW5nZSB0byBhIGdpdmVuIHNvdXJjZSB3aXRoIHRoZSBjdXJyZW50XG5cdCAqIGJhdGNoLCBub3RpbmcgaXRzIHByZXZpb3VzIGFuZCBjdXJyZW50IHZhbHVlc1xuXHQgKiBAcGFyYW0ge1NvdXJjZX0gc291cmNlXG5cdCAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuXHQgKi9cblx0Y2FwdHVyZShzb3VyY2UsIHZhbHVlKSB7XG5cdFx0aWYgKCF0aGlzLiNwcmV2aW91cy5oYXMoc291cmNlKSkge1xuXHRcdFx0dGhpcy4jcHJldmlvdXMuc2V0KHNvdXJjZSwgdmFsdWUpO1xuXHRcdH1cblxuXHRcdHRoaXMuY3VycmVudC5zZXQoc291cmNlLCBzb3VyY2Uudik7XG5cdH1cblxuXHRhY3RpdmF0ZSgpIHtcblx0XHRjdXJyZW50X2JhdGNoID0gdGhpcztcblx0fVxuXG5cdGRlYWN0aXZhdGUoKSB7XG5cdFx0Y3VycmVudF9iYXRjaCA9IG51bGw7XG5cdFx0cHJldmlvdXNfYmF0Y2ggPSBudWxsO1xuXG5cdFx0Zm9yIChjb25zdCB1cGRhdGUgb2YgZWZmZWN0X3BlbmRpbmdfdXBkYXRlcykge1xuXHRcdFx0ZWZmZWN0X3BlbmRpbmdfdXBkYXRlcy5kZWxldGUodXBkYXRlKTtcblx0XHRcdHVwZGF0ZSgpO1xuXG5cdFx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBvbmx5IGRvIG9uZSBhdCBhIHRpbWVcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bmV1dGVyKCkge1xuXHRcdHRoaXMuI25ldXRlcmVkID0gdHJ1ZTtcblx0fVxuXG5cdGZsdXNoKCkge1xuXHRcdGlmIChxdWV1ZWRfcm9vdF9lZmZlY3RzLmxlbmd0aCA+IDApIHtcblx0XHRcdGZsdXNoX2VmZmVjdHMoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy4jY29tbWl0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGN1cnJlbnRfYmF0Y2ggIT09IHRoaXMpIHtcblx0XHRcdC8vIHRoaXMgY2FuIGhhcHBlbiBpZiBhIGBmbHVzaFN5bmNgIG9jY3VycmVkIGR1cmluZyBgZmx1c2hfZWZmZWN0cygpYCxcblx0XHRcdC8vIHdoaWNoIGlzIHBlcm1pdHRlZCBpbiBsZWdhY3kgbW9kZSBkZXNwaXRlIGJlaW5nIGEgdGVycmlibGUgaWRlYVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiNwZW5kaW5nID09PSAwKSB7XG5cdFx0XHRiYXRjaGVzLmRlbGV0ZSh0aGlzKTtcblx0XHR9XG5cblx0XHR0aGlzLmRlYWN0aXZhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBlbmQgYW5kIHJlbW92ZSBicmFuY2hlcyB0by9mcm9tIHRoZSBET01cblx0ICovXG5cdCNjb21taXQoKSB7XG5cdFx0aWYgKCF0aGlzLiNuZXV0ZXJlZCkge1xuXHRcdFx0Zm9yIChjb25zdCBmbiBvZiB0aGlzLiNjYWxsYmFja3MpIHtcblx0XHRcdFx0Zm4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLiNjYWxsYmFja3MuY2xlYXIoKTtcblx0fVxuXG5cdGluY3JlbWVudCgpIHtcblx0XHR0aGlzLiNwZW5kaW5nICs9IDE7XG5cdH1cblxuXHRkZWNyZW1lbnQoKSB7XG5cdFx0dGhpcy4jcGVuZGluZyAtPSAxO1xuXG5cdFx0aWYgKHRoaXMuI3BlbmRpbmcgPT09IDApIHtcblx0XHRcdGZvciAoY29uc3QgZSBvZiB0aGlzLiNkaXJ0eV9lZmZlY3RzKSB7XG5cdFx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGUsIERJUlRZKTtcblx0XHRcdFx0c2NoZWR1bGVfZWZmZWN0KGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKGNvbnN0IGUgb2YgdGhpcy4jbWF5YmVfZGlydHlfZWZmZWN0cykge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhlLCBNQVlCRV9ESVJUWSk7XG5cdFx0XHRcdHNjaGVkdWxlX2VmZmVjdChlKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy4jcmVuZGVyX2VmZmVjdHMgPSBbXTtcblx0XHRcdHRoaXMuI2VmZmVjdHMgPSBbXTtcblxuXHRcdFx0dGhpcy5mbHVzaCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRlYWN0aXZhdGUoKTtcblx0XHR9XG5cdH1cblxuXHQvKiogQHBhcmFtIHsoKSA9PiB2b2lkfSBmbiAqL1xuXHRhZGRfY2FsbGJhY2soZm4pIHtcblx0XHR0aGlzLiNjYWxsYmFja3MuYWRkKGZuKTtcblx0fVxuXG5cdHNldHRsZWQoKSB7XG5cdFx0cmV0dXJuICh0aGlzLiNkZWZlcnJlZCA/Pz0gZGVmZXJyZWQoKSkucHJvbWlzZTtcblx0fVxuXG5cdHN0YXRpYyBlbnN1cmUoKSB7XG5cdFx0aWYgKGN1cnJlbnRfYmF0Y2ggPT09IG51bGwpIHtcblx0XHRcdGNvbnN0IGJhdGNoID0gKGN1cnJlbnRfYmF0Y2ggPSBuZXcgQmF0Y2goKSk7XG5cdFx0XHRiYXRjaGVzLmFkZChjdXJyZW50X2JhdGNoKTtcblxuXHRcdFx0aWYgKCFpc19mbHVzaGluZ19zeW5jKSB7XG5cdFx0XHRcdEJhdGNoLmVucXVldWUoKCkgPT4ge1xuXHRcdFx0XHRcdGlmIChjdXJyZW50X2JhdGNoICE9PSBiYXRjaCkge1xuXHRcdFx0XHRcdFx0Ly8gYSBmbHVzaFN5bmMgaGFwcGVuZWQgaW4gdGhlIG1lYW50aW1lXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YmF0Y2guZmx1c2goKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cnJlbnRfYmF0Y2g7XG5cdH1cblxuXHQvKiogQHBhcmFtIHsoKSA9PiB2b2lkfSB0YXNrICovXG5cdHN0YXRpYyBlbnF1ZXVlKHRhc2spIHtcblx0XHRpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRxdWV1ZU1pY3JvdGFzayhkZXF1ZXVlKTtcblx0XHR9XG5cblx0XHR0YXNrcy51bnNoaWZ0KHRhc2spO1xuXHR9XG59XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBmbHVzaCBhbnkgcGVuZGluZyB1cGRhdGVzLlxuICogUmV0dXJucyB2b2lkIGlmIG5vIGNhbGxiYWNrIGlzIHByb3ZpZGVkLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIGNhbGxiYWNrLlxuICogQHRlbXBsYXRlIFtUPXZvaWRdXG4gKiBAcGFyYW0geygoKSA9PiBUKSB8IHVuZGVmaW5lZH0gW2ZuXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcblx0aWYgKGFzeW5jX21vZGVfZmxhZyAmJiBhY3RpdmVfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0Ly8gV2UgZGlzYWxsb3cgdGhpcyBiZWNhdXNlIGl0IGNyZWF0ZXMgc3VwZXItaGFyZCB0byByZWFzb24gYWJvdXQgc3RhY2sgdHJhY2UgYW5kIGJlY2F1c2UgaXQncyBnZW5lcmFsbHkgYSBiYWQgaWRlYVxuXHRcdGUuZmx1c2hfc3luY19pbl9lZmZlY3QoKTtcblx0fVxuXG5cdHZhciB3YXNfZmx1c2hpbmdfc3luYyA9IGlzX2ZsdXNoaW5nX3N5bmM7XG5cdGlzX2ZsdXNoaW5nX3N5bmMgPSB0cnVlO1xuXG5cdHRyeSB7XG5cdFx0dmFyIHJlc3VsdDtcblxuXHRcdGlmIChmbikge1xuXHRcdFx0Zmx1c2hfZWZmZWN0cygpO1xuXHRcdFx0cmVzdWx0ID0gZm4oKTtcblx0XHR9XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0Zmx1c2hfdGFza3MoKTtcblxuXHRcdFx0aWYgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGN1cnJlbnRfYmF0Y2g/LmZsdXNoKCk7XG5cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBjaGVjayBhZ2FpbiwgaW4gY2FzZSB3ZSBqdXN0IHVwZGF0ZWQgYW4gYCRlZmZlY3QucGVuZGluZygpYFxuXHRcdFx0XHRpZiAocXVldWVkX3Jvb3RfZWZmZWN0cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHQvLyB0aGlzIHdvdWxkIGJlIHJlc2V0IGluIGBmbHVzaF9lZmZlY3RzKClgIGJ1dCBzaW5jZSB3ZSBhcmUgZWFybHkgcmV0dXJuaW5nIGhlcmUsXG5cdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byByZXNldCBpdCBoZXJlIGFzIHdlbGwgaW4gY2FzZSB0aGUgZmlyc3QgdGltZSB0aGVyZSdzIDAgcXVldWVkIHJvb3QgZWZmZWN0c1xuXHRcdFx0XHRcdGxhc3Rfc2NoZWR1bGVkX2VmZmVjdCA9IG51bGw7XG5cblx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmbHVzaF9lZmZlY3RzKCk7XG5cdFx0fVxuXHR9IGZpbmFsbHkge1xuXHRcdGlzX2ZsdXNoaW5nX3N5bmMgPSB3YXNfZmx1c2hpbmdfc3luYztcblx0fVxufVxuXG5mdW5jdGlvbiBmbHVzaF9lZmZlY3RzKCkge1xuXHR2YXIgd2FzX3VwZGF0aW5nX2VmZmVjdCA9IGlzX3VwZGF0aW5nX2VmZmVjdDtcblx0aXNfZmx1c2hpbmcgPSB0cnVlO1xuXG5cdHRyeSB7XG5cdFx0dmFyIGZsdXNoX2NvdW50ID0gMDtcblx0XHRzZXRfaXNfdXBkYXRpbmdfZWZmZWN0KHRydWUpO1xuXG5cdFx0d2hpbGUgKHF1ZXVlZF9yb290X2VmZmVjdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIGJhdGNoID0gQmF0Y2guZW5zdXJlKCk7XG5cblx0XHRcdGlmIChmbHVzaF9jb3VudCsrID4gMTAwMCkge1xuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0dmFyIHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG5cblx0XHRcdFx0XHRmb3IgKGNvbnN0IHNvdXJjZSBvZiBiYXRjaC5jdXJyZW50LmtleXMoKSkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBbc3RhY2ssIHVwZGF0ZV0gb2Ygc291cmNlLnVwZGF0ZWQgPz8gW10pIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVudHJ5ID0gdXBkYXRlcy5nZXQoc3RhY2spO1xuXG5cdFx0XHRcdFx0XHRcdGlmICghZW50cnkpIHtcblx0XHRcdFx0XHRcdFx0XHRlbnRyeSA9IHsgZXJyb3I6IHVwZGF0ZS5lcnJvciwgY291bnQ6IDAgfTtcblx0XHRcdFx0XHRcdFx0XHR1cGRhdGVzLnNldChzdGFjaywgZW50cnkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0ZW50cnkuY291bnQgKz0gdXBkYXRlLmNvdW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoY29uc3QgdXBkYXRlIG9mIHVwZGF0ZXMudmFsdWVzKCkpIHtcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKHVwZGF0ZS5lcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5maW5pdGVfbG9vcF9ndWFyZCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRiYXRjaC5wcm9jZXNzKHF1ZXVlZF9yb290X2VmZmVjdHMpO1xuXHRcdFx0b2xkX3ZhbHVlcy5jbGVhcigpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRpc19mbHVzaGluZyA9IGZhbHNlO1xuXHRcdHNldF9pc191cGRhdGluZ19lZmZlY3Qod2FzX3VwZGF0aW5nX2VmZmVjdCk7XG5cblx0XHRsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBudWxsO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGluZmluaXRlX2xvb3BfZ3VhcmQoKSB7XG5cdHRyeSB7XG5cdFx0ZS5lZmZlY3RfdXBkYXRlX2RlcHRoX2V4Y2VlZGVkKCk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0Ly8gc3RhY2sgY29udGFpbnMgbm8gdXNlZnVsIGluZm9ybWF0aW9uLCByZXBsYWNlIGl0XG5cdFx0XHRkZWZpbmVfcHJvcGVydHkoZXJyb3IsICdzdGFjaycsIHsgdmFsdWU6ICcnIH0pO1xuXHRcdH1cblxuXHRcdC8vIEJlc3QgZWZmb3J0OiBpbnZva2UgdGhlIGJvdW5kYXJ5IG5lYXJlc3QgdGhlIG1vc3QgcmVjZW50XG5cdFx0Ly8gZWZmZWN0IGFuZCBob3BlIHRoYXQgaXQncyByZWxldmFudCB0byB0aGUgaW5maW5pdGUgbG9vcFxuXHRcdGludm9rZV9lcnJvcl9ib3VuZGFyeShlcnJvciwgbGFzdF9zY2hlZHVsZWRfZWZmZWN0KTtcblx0fVxufVxuXG4vKiogQHR5cGUge0VmZmVjdFtdIHwgbnVsbH0gKi9cbmV4cG9ydCBsZXQgZWFnZXJfYmxvY2tfZWZmZWN0cyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxFZmZlY3Q+fSBlZmZlY3RzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcXVldWVkX2VmZmVjdHMoZWZmZWN0cykge1xuXHR2YXIgbGVuZ3RoID0gZWZmZWN0cy5sZW5ndGg7XG5cdGlmIChsZW5ndGggPT09IDApIHJldHVybjtcblxuXHR2YXIgaSA9IDA7XG5cblx0d2hpbGUgKGkgPCBsZW5ndGgpIHtcblx0XHR2YXIgZWZmZWN0ID0gZWZmZWN0c1tpKytdO1xuXG5cdFx0aWYgKChlZmZlY3QuZiAmIChERVNUUk9ZRUQgfCBJTkVSVCkpID09PSAwICYmIGlzX2RpcnR5KGVmZmVjdCkpIHtcblx0XHRcdGVhZ2VyX2Jsb2NrX2VmZmVjdHMgPSBbXTtcblxuXHRcdFx0dXBkYXRlX2VmZmVjdChlZmZlY3QpO1xuXG5cdFx0XHQvLyBFZmZlY3RzIHdpdGggbm8gZGVwZW5kZW5jaWVzIG9yIHRlYXJkb3duIGRvIG5vdCBnZXQgYWRkZWQgdG8gdGhlIGVmZmVjdCB0cmVlLlxuXHRcdFx0Ly8gRGVmZXJyZWQgZWZmZWN0cyAoZS5nLiBgJGVmZmVjdCguLi4pYCkgX2FyZV8gYWRkZWQgdG8gdGhlIHRyZWUgYmVjYXVzZSB3ZVxuXHRcdFx0Ly8gZG9uJ3Qga25vdyBpZiB3ZSBuZWVkIHRvIGtlZXAgdGhlbSB1bnRpbCB0aGV5IGFyZSBleGVjdXRlZC4gRG9pbmcgdGhlIGNoZWNrXG5cdFx0XHQvLyBoZXJlIChyYXRoZXIgdGhhbiBpbiBgdXBkYXRlX2VmZmVjdGApIGFsbG93cyB1cyB0byBza2lwIHRoZSB3b3JrIGZvclxuXHRcdFx0Ly8gaW1tZWRpYXRlIGVmZmVjdHMuXG5cdFx0XHRpZiAoZWZmZWN0LmRlcHMgPT09IG51bGwgJiYgZWZmZWN0LmZpcnN0ID09PSBudWxsICYmIGVmZmVjdC5ub2Rlc19zdGFydCA9PT0gbnVsbCkge1xuXHRcdFx0XHQvLyBpZiB0aGVyZSdzIG5vIHRlYXJkb3duIG9yIGFib3J0IGNvbnRyb2xsZXIgd2UgY29tcGxldGVseSB1bmxpbmtcblx0XHRcdFx0Ly8gdGhlIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRpZiAoZWZmZWN0LnRlYXJkb3duID09PSBudWxsICYmIGVmZmVjdC5hYyA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSB0aGlzIGVmZmVjdCBmcm9tIHRoZSBncmFwaFxuXHRcdFx0XHRcdHVubGlua19lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBrZWVwIHRoZSBlZmZlY3QgaW4gdGhlIGdyYXBoLCBidXQgZnJlZSB1cCBzb21lIG1lbW9yeVxuXHRcdFx0XHRcdGVmZmVjdC5mbiA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdXBkYXRlX2VmZmVjdCgpIGhhcyBhIGZsdXNoU3luYygpIGluIGl0LCB3ZSBtYXkgaGF2ZSBmbHVzaGVkIGFub3RoZXIgZmx1c2hfcXVldWVkX2VmZmVjdHMoKSxcblx0XHRcdC8vIHdoaWNoIGFscmVhZHkgaGFuZGxlZCB0aGlzIGxvZ2ljIGFuZCBkaWQgc2V0IGVhZ2VyX2Jsb2NrX2VmZmVjdHMgdG8gbnVsbC5cblx0XHRcdGlmIChlYWdlcl9ibG9ja19lZmZlY3RzPy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8vIFRPRE8gdGhpcyBmZWVscyBpbmNvcnJlY3QhIGl0IGdldHMgdGhlIHRlc3RzIHBhc3Npbmdcblx0XHRcdFx0b2xkX3ZhbHVlcy5jbGVhcigpO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgZSBvZiBlYWdlcl9ibG9ja19lZmZlY3RzKSB7XG5cdFx0XHRcdFx0dXBkYXRlX2VmZmVjdChlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVhZ2VyX2Jsb2NrX2VmZmVjdHMgPSBbXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRlYWdlcl9ibG9ja19lZmZlY3RzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gc2lnbmFsXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjaGVkdWxlX2VmZmVjdChzaWduYWwpIHtcblx0dmFyIGVmZmVjdCA9IChsYXN0X3NjaGVkdWxlZF9lZmZlY3QgPSBzaWduYWwpO1xuXG5cdHdoaWxlIChlZmZlY3QucGFyZW50ICE9PSBudWxsKSB7XG5cdFx0ZWZmZWN0ID0gZWZmZWN0LnBhcmVudDtcblx0XHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRcdC8vIGlmIHRoZSBlZmZlY3QgaXMgYmVpbmcgc2NoZWR1bGVkIGJlY2F1c2UgYSBwYXJlbnQgKGVhY2gvYXdhaXQvZXRjKSBibG9ja1xuXHRcdC8vIHVwZGF0ZWQgYW4gaW50ZXJuYWwgc291cmNlLCBiYWlsIG91dCBvciB3ZSdsbCBjYXVzZSBhIHNlY29uZCBmbHVzaFxuXHRcdGlmIChpc19mbHVzaGluZyAmJiBlZmZlY3QgPT09IGFjdGl2ZV9lZmZlY3QgJiYgKGZsYWdzICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgoZmxhZ3MgJiAoUk9PVF9FRkZFQ1QgfCBCUkFOQ0hfRUZGRUNUKSkgIT09IDApIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBDTEVBTikgPT09IDApIHJldHVybjtcblx0XHRcdGVmZmVjdC5mIF49IENMRUFOO1xuXHRcdH1cblx0fVxuXG5cdHF1ZXVlZF9yb290X2VmZmVjdHMucHVzaChlZmZlY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZCgpIHtcblx0dmFyIGJvdW5kYXJ5ID0gZ2V0X3BlbmRpbmdfYm91bmRhcnkoKTtcblx0dmFyIGJhdGNoID0gLyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpO1xuXHR2YXIgcGVuZGluZyA9IGJvdW5kYXJ5LnBlbmRpbmc7XG5cblx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoMSk7XG5cdGlmICghcGVuZGluZykgYmF0Y2guaW5jcmVtZW50KCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVuc3VzcGVuZCgpIHtcblx0XHRib3VuZGFyeS51cGRhdGVfcGVuZGluZ19jb3VudCgtMSk7XG5cblx0XHRpZiAoIXBlbmRpbmcpIHtcblx0XHRcdGJhdGNoLmFjdGl2YXRlKCk7XG5cdFx0XHRiYXRjaC5kZWNyZW1lbnQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YmF0Y2guZGVhY3RpdmF0ZSgpO1xuXHRcdH1cblxuXHRcdHVuc2V0X2NvbnRleHQoKTtcblx0fTtcbn1cblxuLyoqXG4gKiBGb3JjaWJseSByZW1vdmUgYWxsIGN1cnJlbnQgYmF0Y2hlcywgdG8gcHJldmVudCBjcm9zcy10YWxrIGJldHdlZW4gdGVzdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRiYXRjaGVzLmNsZWFyKCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBEZXJpdmVkLCBFZmZlY3QsIFNvdXJjZSwgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGFjdGl2ZV9lZmZlY3QsXG5cdHVudHJhY2tlZF93cml0ZXMsXG5cdGdldCxcblx0c2V0X3VudHJhY2tlZF93cml0ZXMsXG5cdHNldF9zaWduYWxfc3RhdHVzLFxuXHR1bnRyYWNrLFxuXHRpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbixcblx0dXBkYXRlX2VmZmVjdCxcblx0Y3VycmVudF9zb3VyY2VzLFxuXHRpc19kaXJ0eSxcblx0dW50cmFja2luZyxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHB1c2hfcmVhY3Rpb25fdmFsdWVcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBlcXVhbHMsIHNhZmVfZXF1YWxzIH0gZnJvbSAnLi9lcXVhbGl0eS5qcyc7XG5pbXBvcnQge1xuXHRDTEVBTixcblx0REVSSVZFRCxcblx0RElSVFksXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdElOU1BFQ1RfRUZGRUNULFxuXHRVTk9XTkVELFxuXHRNQVlCRV9ESVJUWSxcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0QVNZTkNcbn0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgbGVnYWN5X21vZGVfZmxhZywgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi8uLi9mbGFncy9pbmRleC5qcyc7XG5pbXBvcnQgeyBnZXRfc3RhY2ssIHRhZ19wcm94eSB9IGZyb20gJy4uL2Rldi90cmFjaW5nLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBpc19ydW5lcyB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGVhZ2VyX2Jsb2NrX2VmZmVjdHMsIHNjaGVkdWxlX2VmZmVjdCB9IGZyb20gJy4vYmF0Y2guanMnO1xuaW1wb3J0IHsgcHJveHkgfSBmcm9tICcuLi9wcm94eS5qcyc7XG5pbXBvcnQgeyBleGVjdXRlX2Rlcml2ZWQgfSBmcm9tICcuL2Rlcml2ZWRzLmpzJztcblxuLyoqIEB0eXBlIHtTZXQ8YW55Pn0gKi9cbmV4cG9ydCBsZXQgaW5zcGVjdF9lZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKiogQHR5cGUge01hcDxTb3VyY2UsIGFueT59ICovXG5leHBvcnQgY29uc3Qgb2xkX3ZhbHVlcyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBAcGFyYW0ge1NldDxhbnk+fSB2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfaW5zcGVjdF9lZmZlY3RzKHYpIHtcblx0aW5zcGVjdF9lZmZlY3RzID0gdjtcbn1cblxubGV0IGluc3BlY3RfZWZmZWN0c19kZWZlcnJlZCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0X2luc3BlY3RfZWZmZWN0c19kZWZlcnJlZCgpIHtcblx0aW5zcGVjdF9lZmZlY3RzX2RlZmVycmVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSB2XG4gKiBAcGFyYW0ge0Vycm9yIHwgbnVsbH0gW3N0YWNrXVxuICogQHJldHVybnMge1NvdXJjZTxWPn1cbiAqL1xuLy8gVE9ETyByZW5hbWUgdGhpcyB0byBgc3RhdGVgIHRocm91Z2hvdXQgdGhlIGNvZGViYXNlXG5leHBvcnQgZnVuY3Rpb24gc291cmNlKHYsIHN0YWNrKSB7XG5cdC8qKiBAdHlwZSB7VmFsdWV9ICovXG5cdHZhciBzaWduYWwgPSB7XG5cdFx0ZjogMCwgLy8gVE9ETyBpZGVhbGx5IHdlIGNvdWxkIHNraXAgdGhpcyBhbHRvZ2V0aGVyLCBidXQgaXQgY2F1c2VzIHR5cGUgZXJyb3JzXG5cdFx0dixcblx0XHRyZWFjdGlvbnM6IG51bGwsXG5cdFx0ZXF1YWxzLFxuXHRcdHJ2OiAwLFxuXHRcdHd2OiAwXG5cdH07XG5cblx0aWYgKERFViAmJiB0cmFjaW5nX21vZGVfZmxhZykge1xuXHRcdHNpZ25hbC5jcmVhdGVkID0gc3RhY2sgPz8gZ2V0X3N0YWNrKCdDcmVhdGVkQXQnKTtcblx0XHRzaWduYWwudXBkYXRlZCA9IG51bGw7XG5cdFx0c2lnbmFsLnNldF9kdXJpbmdfZWZmZWN0ID0gZmFsc2U7XG5cdFx0c2lnbmFsLnRyYWNlID0gbnVsbDtcblx0fVxuXG5cdHJldHVybiBzaWduYWw7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Vn0gdlxuICogQHBhcmFtIHtFcnJvciB8IG51bGx9IFtzdGFja11cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gc3RhdGUodiwgc3RhY2spIHtcblx0Y29uc3QgcyA9IHNvdXJjZSh2LCBzdGFjayk7XG5cblx0cHVzaF9yZWFjdGlvbl92YWx1ZShzKTtcblxuXHRyZXR1cm4gcztcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWfSBpbml0aWFsX3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbW11dGFibGVdXG4gKiBAcmV0dXJucyB7U291cmNlPFY+fVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBtdXRhYmxlX3NvdXJjZShpbml0aWFsX3ZhbHVlLCBpbW11dGFibGUgPSBmYWxzZSwgdHJhY2thYmxlID0gdHJ1ZSkge1xuXHRjb25zdCBzID0gc291cmNlKGluaXRpYWxfdmFsdWUpO1xuXHRpZiAoIWltbXV0YWJsZSkge1xuXHRcdHMuZXF1YWxzID0gc2FmZV9lcXVhbHM7XG5cdH1cblxuXHQvLyBiaW5kIHRoZSBzaWduYWwgdG8gdGhlIGNvbXBvbmVudCBjb250ZXh0LCBpbiBjYXNlIHdlIG5lZWQgdG9cblx0Ly8gdHJhY2sgdXBkYXRlcyB0byB0cmlnZ2VyIGJlZm9yZVVwZGF0ZS9hZnRlclVwZGF0ZSBjYWxsYmFja3Ncblx0aWYgKGxlZ2FjeV9tb2RlX2ZsYWcgJiYgdHJhY2thYmxlICYmIGNvbXBvbmVudF9jb250ZXh0ICE9PSBudWxsICYmIGNvbXBvbmVudF9jb250ZXh0LmwgIT09IG51bGwpIHtcblx0XHQoY29tcG9uZW50X2NvbnRleHQubC5zID8/PSBbXSkucHVzaChzKTtcblx0fVxuXG5cdHJldHVybiBzO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBzb3VyY2VcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11dGF0ZShzb3VyY2UsIHZhbHVlKSB7XG5cdHNldChcblx0XHRzb3VyY2UsXG5cdFx0dW50cmFjaygoKSA9PiBnZXQoc291cmNlKSlcblx0KTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1NvdXJjZTxWPn0gc291cmNlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzaG91bGRfcHJveHldXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChzb3VyY2UsIHZhbHVlLCBzaG91bGRfcHJveHkgPSBmYWxzZSkge1xuXHRpZiAoXG5cdFx0YWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmXG5cdFx0Ly8gc2luY2Ugd2UgYXJlIHVudHJhY2tpbmcgdGhlIGZ1bmN0aW9uIGluc2lkZSBgJGluc3BlY3Qud2l0aGAgd2UgbmVlZCB0byBhZGQgdGhpcyBjaGVja1xuXHRcdC8vIHRvIGVuc3VyZSB3ZSBlcnJvciBpZiBzdGF0ZSBpcyBzZXQgaW5zaWRlIGFuIGluc3BlY3QgZWZmZWN0XG5cdFx0KCF1bnRyYWNraW5nIHx8IChhY3RpdmVfcmVhY3Rpb24uZiAmIElOU1BFQ1RfRUZGRUNUKSAhPT0gMCkgJiZcblx0XHRpc19ydW5lcygpICYmXG5cdFx0KGFjdGl2ZV9yZWFjdGlvbi5mICYgKERFUklWRUQgfCBCTE9DS19FRkZFQ1QgfCBBU1lOQyB8IElOU1BFQ1RfRUZGRUNUKSkgIT09IDAgJiZcblx0XHQhY3VycmVudF9zb3VyY2VzPy5pbmNsdWRlcyhzb3VyY2UpXG5cdCkge1xuXHRcdGUuc3RhdGVfdW5zYWZlX211dGF0aW9uKCk7XG5cdH1cblxuXHRsZXQgbmV3X3ZhbHVlID0gc2hvdWxkX3Byb3h5ID8gcHJveHkodmFsdWUpIDogdmFsdWU7XG5cblx0aWYgKERFVikge1xuXHRcdHRhZ19wcm94eShuZXdfdmFsdWUsIC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc291cmNlLmxhYmVsKSk7XG5cdH1cblxuXHRyZXR1cm4gaW50ZXJuYWxfc2V0KHNvdXJjZSwgbmV3X3ZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtTb3VyY2U8Vj59IHNvdXJjZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge1Z9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm5hbF9zZXQoc291cmNlLCB2YWx1ZSkge1xuXHRpZiAoIXNvdXJjZS5lcXVhbHModmFsdWUpKSB7XG5cdFx0dmFyIG9sZF92YWx1ZSA9IHNvdXJjZS52O1xuXG5cdFx0aWYgKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0KSB7XG5cdFx0XHRvbGRfdmFsdWVzLnNldChzb3VyY2UsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2xkX3ZhbHVlcy5zZXQoc291cmNlLCBvbGRfdmFsdWUpO1xuXHRcdH1cblxuXHRcdHNvdXJjZS52ID0gdmFsdWU7XG5cblx0XHR2YXIgYmF0Y2ggPSBCYXRjaC5lbnN1cmUoKTtcblx0XHRiYXRjaC5jYXB0dXJlKHNvdXJjZSwgb2xkX3ZhbHVlKTtcblxuXHRcdGlmIChERVYpIHtcblx0XHRcdGlmICh0cmFjaW5nX21vZGVfZmxhZyB8fCBhY3RpdmVfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0X3N0YWNrKCdVcGRhdGVkQXQnKTtcblxuXHRcdFx0XHRpZiAoZXJyb3IgIT09IG51bGwpIHtcblx0XHRcdFx0XHRzb3VyY2UudXBkYXRlZCA/Pz0gbmV3IE1hcCgpO1xuXHRcdFx0XHRcdGxldCBlbnRyeSA9IHNvdXJjZS51cGRhdGVkLmdldChlcnJvci5zdGFjayk7XG5cblx0XHRcdFx0XHRpZiAoIWVudHJ5KSB7XG5cdFx0XHRcdFx0XHRlbnRyeSA9IHsgZXJyb3IsIGNvdW50OiAwIH07XG5cdFx0XHRcdFx0XHRzb3VyY2UudXBkYXRlZC5zZXQoZXJyb3Iuc3RhY2ssIGVudHJ5KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbnRyeS5jb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhY3RpdmVfZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRcdHNvdXJjZS5zZXRfZHVyaW5nX2VmZmVjdCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKChzb3VyY2UuZiAmIERFUklWRUQpICE9PSAwKSB7XG5cdFx0XHQvLyBpZiB3ZSBhcmUgYXNzaWduaW5nIHRvIGEgZGlydHkgZGVyaXZlZCB3ZSBzZXQgaXQgdG8gY2xlYW4vbWF5YmUgZGlydHkgYnV0IHdlIGFsc28gZWFnZXJseSBleGVjdXRlIGl0IHRvIHRyYWNrIHRoZSBkZXBlbmRlbmNpZXNcblx0XHRcdGlmICgoc291cmNlLmYgJiBESVJUWSkgIT09IDApIHtcblx0XHRcdFx0ZXhlY3V0ZV9kZXJpdmVkKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNvdXJjZSkpO1xuXHRcdFx0fVxuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoc291cmNlLCAoc291cmNlLmYgJiBVTk9XTkVEKSA9PT0gMCA/IENMRUFOIDogTUFZQkVfRElSVFkpO1xuXHRcdH1cblxuXHRcdHNvdXJjZS53diA9IGluY3JlbWVudF93cml0ZV92ZXJzaW9uKCk7XG5cblx0XHRtYXJrX3JlYWN0aW9ucyhzb3VyY2UsIERJUlRZKTtcblxuXHRcdC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgY3VycmVudCByZWFjdGlvbiBtaWdodCBub3QgaGF2ZSB1cC10by1kYXRlIGRlcGVuZGVuY2llc1xuXHRcdC8vIHdoaWxzdCBpdCdzIGFjdGl2ZWx5IHJ1bm5pbmcuIFNvIGluIHRoZSBjYXNlIG9mIGVuc3VyaW5nIGl0IHJlZ2lzdGVycyB0aGUgcmVhY3Rpb25cblx0XHQvLyBwcm9wZXJseSBmb3IgaXRzZWxmLCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgY3VycmVudCBlZmZlY3QgYWN0dWFsbHkgZ2V0c1xuXHRcdC8vIHNjaGVkdWxlZC4gaS5lOiBgJGVmZmVjdCgoKSA9PiB4KyspYFxuXHRcdGlmIChcblx0XHRcdGlzX3J1bmVzKCkgJiZcblx0XHRcdGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiZcblx0XHRcdChhY3RpdmVfZWZmZWN0LmYgJiBDTEVBTikgIT09IDAgJiZcblx0XHRcdChhY3RpdmVfZWZmZWN0LmYgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgPT09IDBcblx0XHQpIHtcblx0XHRcdGlmICh1bnRyYWNrZWRfd3JpdGVzID09PSBudWxsKSB7XG5cdFx0XHRcdHNldF91bnRyYWNrZWRfd3JpdGVzKFtzb3VyY2VdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHVudHJhY2tlZF93cml0ZXMucHVzaChzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChERVYgJiYgaW5zcGVjdF9lZmZlY3RzLnNpemUgPiAwICYmICFpbnNwZWN0X2VmZmVjdHNfZGVmZXJyZWQpIHtcblx0XHRcdGZsdXNoX2luc3BlY3RfZWZmZWN0cygpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoX2luc3BlY3RfZWZmZWN0cygpIHtcblx0aW5zcGVjdF9lZmZlY3RzX2RlZmVycmVkID0gZmFsc2U7XG5cblx0Y29uc3QgaW5zcGVjdHMgPSBBcnJheS5mcm9tKGluc3BlY3RfZWZmZWN0cyk7XG5cblx0Zm9yIChjb25zdCBlZmZlY3Qgb2YgaW5zcGVjdHMpIHtcblx0XHQvLyBNYXJrIGNsZWFuIGluc3BlY3QtZWZmZWN0cyBhcyBtYXliZSBkaXJ0eSBhbmQgdGhlbiBjaGVjayB0aGVpciBkaXJ0aW5lc3Ncblx0XHQvLyBpbnN0ZWFkIG9mIGp1c3QgdXBkYXRpbmcgdGhlIGVmZmVjdHMgLSB0aGlzIHdheSB3ZSBhdm9pZCBvdmVyZmlyaW5nLlxuXHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgTUFZQkVfRElSVFkpO1xuXHRcdH1cblxuXHRcdGlmIChpc19kaXJ0eShlZmZlY3QpKSB7XG5cdFx0XHR1cGRhdGVfZWZmZWN0KGVmZmVjdCk7XG5cdFx0fVxuXHR9XG5cblx0aW5zcGVjdF9lZmZlY3RzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtudW1iZXIgfCBiaWdpbnR9IFRcbiAqIEBwYXJhbSB7U291cmNlPFQ+fSBzb3VyY2VcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlKHNvdXJjZSwgZCA9IDEpIHtcblx0dmFyIHZhbHVlID0gZ2V0KHNvdXJjZSk7XG5cdHZhciByZXN1bHQgPSBkID09PSAxID8gdmFsdWUrKyA6IHZhbHVlLS07XG5cblx0c2V0KHNvdXJjZSwgdmFsdWUpO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge251bWJlciB8IGJpZ2ludH0gVFxuICogQHBhcmFtIHtTb3VyY2U8VD59IHNvdXJjZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJlKHNvdXJjZSwgZCA9IDEpIHtcblx0dmFyIHZhbHVlID0gZ2V0KHNvdXJjZSk7XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRyZXR1cm4gc2V0KHNvdXJjZSwgZCA9PT0gMSA/ICsrdmFsdWUgOiAtLXZhbHVlKTtcbn1cblxuLyoqXG4gKiBTaWxlbnRseSAod2l0aG91dCB1c2luZyBgZ2V0YCkgaW5jcmVtZW50IGEgc291cmNlXG4gKiBAcGFyYW0ge1NvdXJjZTxudW1iZXI+fSBzb3VyY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudChzb3VyY2UpIHtcblx0c2V0KHNvdXJjZSwgc291cmNlLnYgKyAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1ZhbHVlfSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXMgc2hvdWxkIGJlIERJUlRZIG9yIE1BWUJFX0RJUlRZXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gbWFya19yZWFjdGlvbnMoc2lnbmFsLCBzdGF0dXMpIHtcblx0dmFyIHJlYWN0aW9ucyA9IHNpZ25hbC5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgPT09IG51bGwpIHJldHVybjtcblxuXHR2YXIgcnVuZXMgPSBpc19ydW5lcygpO1xuXHR2YXIgbGVuZ3RoID0gcmVhY3Rpb25zLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHJlYWN0aW9uID0gcmVhY3Rpb25zW2ldO1xuXHRcdHZhciBmbGFncyA9IHJlYWN0aW9uLmY7XG5cblx0XHQvLyBJbiBsZWdhY3kgbW9kZSwgc2tpcCB0aGUgY3VycmVudCBlZmZlY3QgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdGlmICghcnVuZXMgJiYgcmVhY3Rpb24gPT09IGFjdGl2ZV9lZmZlY3QpIGNvbnRpbnVlO1xuXG5cdFx0Ly8gSW5zcGVjdCBlZmZlY3RzIG5lZWQgdG8gcnVuIGltbWVkaWF0ZWx5LCBzbyB0aGF0IHRoZSBzdGFjayB0cmFjZSBtYWtlcyBzZW5zZVxuXHRcdGlmIChERVYgJiYgKGZsYWdzICYgSU5TUEVDVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRpbnNwZWN0X2VmZmVjdHMuYWRkKHJlYWN0aW9uKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhciBub3RfZGlydHkgPSAoZmxhZ3MgJiBESVJUWSkgPT09IDA7XG5cblx0XHQvLyBkb24ndCBzZXQgYSBESVJUWSByZWFjdGlvbiB0byBNQVlCRV9ESVJUWVxuXHRcdGlmIChub3RfZGlydHkpIHtcblx0XHRcdHNldF9zaWduYWxfc3RhdHVzKHJlYWN0aW9uLCBzdGF0dXMpO1xuXHRcdH1cblxuXHRcdGlmICgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0bWFya19yZWFjdGlvbnMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAocmVhY3Rpb24pLCBNQVlCRV9ESVJUWSk7XG5cdFx0fSBlbHNlIGlmIChub3RfZGlydHkpIHtcblx0XHRcdGlmICgoZmxhZ3MgJiBCTE9DS19FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRcdGlmIChlYWdlcl9ibG9ja19lZmZlY3RzICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZWFnZXJfYmxvY2tfZWZmZWN0cy5wdXNoKC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRzY2hlZHVsZV9lZmZlY3QoLyoqIEB0eXBlIHtFZmZlY3R9ICovIChyZWFjdGlvbikpO1xuXHRcdH1cblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHtcblx0Z2V0LFxuXHRhY3RpdmVfZWZmZWN0LFxuXHR1cGRhdGVfdmVyc2lvbixcblx0YWN0aXZlX3JlYWN0aW9uLFxuXHRzZXRfdXBkYXRlX3ZlcnNpb24sXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi9ydW50aW1lLmpzJztcbmltcG9ydCB7XG5cdGFycmF5X3Byb3RvdHlwZSxcblx0Z2V0X2Rlc2NyaXB0b3IsXG5cdGdldF9wcm90b3R5cGVfb2YsXG5cdGlzX2FycmF5LFxuXHRvYmplY3RfcHJvdG90eXBlXG59IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRzdGF0ZSBhcyBzb3VyY2UsXG5cdHNldCxcblx0aW5jcmVtZW50LFxuXHRmbHVzaF9pbnNwZWN0X2VmZmVjdHMsXG5cdHNldF9pbnNwZWN0X2VmZmVjdHNfZGVmZXJyZWRcbn0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgUFJPWFlfUEFUSF9TWU1CT0wsIFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBnZXRfc3RhY2ssIHRhZyB9IGZyb20gJy4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHsgdHJhY2luZ19tb2RlX2ZsYWcgfSBmcm9tICcuLi9mbGFncy9pbmRleC5qcyc7XG5cbi8vIFRPRE8gbW92ZSBhbGwgcmVnZXhlcyBpbnRvIHNoYXJlZCBtb2R1bGU/XG5jb25zdCByZWdleF9pc192YWxpZF9pZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSB2YWx1ZVxuICogQHJldHVybnMge1R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm94eSh2YWx1ZSkge1xuXHQvLyBpZiBub24tcHJveHlhYmxlLCBvciBpcyBhbHJlYWR5IGEgcHJveHksIHJldHVybiBgdmFsdWVgXG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsIHx8IFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGNvbnN0IHByb3RvdHlwZSA9IGdldF9wcm90b3R5cGVfb2YodmFsdWUpO1xuXG5cdGlmIChwcm90b3R5cGUgIT09IG9iamVjdF9wcm90b3R5cGUgJiYgcHJvdG90eXBlICE9PSBhcnJheV9wcm90b3R5cGUpIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblxuXHQvKiogQHR5cGUge01hcDxhbnksIFNvdXJjZTxhbnk+Pn0gKi9cblx0dmFyIHNvdXJjZXMgPSBuZXcgTWFwKCk7XG5cdHZhciBpc19wcm94aWVkX2FycmF5ID0gaXNfYXJyYXkodmFsdWUpO1xuXHR2YXIgdmVyc2lvbiA9IHNvdXJjZSgwKTtcblxuXHR2YXIgc3RhY2sgPSBERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcgPyBnZXRfc3RhY2soJ0NyZWF0ZWRBdCcpIDogbnVsbDtcblx0dmFyIHBhcmVudF92ZXJzaW9uID0gdXBkYXRlX3ZlcnNpb247XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVzIHRoZSBwcm94eSBpbiB0aGUgY29udGV4dCBvZiB0aGUgcmVhY3Rpb24gaXQgd2FzIG9yaWdpbmFsbHkgY3JlYXRlZCBpbiwgaWYgYW55XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwYXJhbSB7KCkgPT4gVH0gZm5cblx0ICovXG5cdHZhciB3aXRoX3BhcmVudCA9IChmbikgPT4ge1xuXHRcdGlmICh1cGRhdGVfdmVyc2lvbiA9PT0gcGFyZW50X3ZlcnNpb24pIHtcblx0XHRcdHJldHVybiBmbigpO1xuXHRcdH1cblxuXHRcdC8vIGNoaWxkIHNvdXJjZSBpcyBiZWluZyBjcmVhdGVkIGFmdGVyIHRoZSBpbml0aWFsIHByb3h5IFx1MjAxNFxuXHRcdC8vIHByZXZlbnQgaXQgZnJvbSBiZWluZyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcmVhY3Rpb25cblx0XHR2YXIgcmVhY3Rpb24gPSBhY3RpdmVfcmVhY3Rpb247XG5cdFx0dmFyIHZlcnNpb24gPSB1cGRhdGVfdmVyc2lvbjtcblxuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdFx0c2V0X3VwZGF0ZV92ZXJzaW9uKHBhcmVudF92ZXJzaW9uKTtcblxuXHRcdHZhciByZXN1bHQgPSBmbigpO1xuXG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihyZWFjdGlvbik7XG5cdFx0c2V0X3VwZGF0ZV92ZXJzaW9uKHZlcnNpb24pO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRpZiAoaXNfcHJveGllZF9hcnJheSkge1xuXHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIHRoZSBsZW5ndGggc291cmNlIGVhZ2VybHkgdG8gZW5zdXJlIHRoYXRcblx0XHQvLyBtdXRhdGlvbnMgdG8gdGhlIGFycmF5IGFyZSBwcm9wZXJseSBzeW5jZWQgd2l0aCBvdXIgcHJveHlcblx0XHRzb3VyY2VzLnNldCgnbGVuZ3RoJywgc291cmNlKC8qKiBAdHlwZSB7YW55W119ICovICh2YWx1ZSkubGVuZ3RoLCBzdGFjaykpO1xuXHRcdGlmIChERVYpIHtcblx0XHRcdHZhbHVlID0gLyoqIEB0eXBlIHthbnl9ICovIChpbnNwZWN0YWJsZV9hcnJheSgvKiogQHR5cGUge2FueVtdfSAqLyAodmFsdWUpKSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqIFVzZWQgaW4gZGV2IGZvciAkaW5zcGVjdC50cmFjZSgpICovXG5cdHZhciBwYXRoID0gJyc7XG5cdGxldCB1cGRhdGluZyA9IGZhbHNlO1xuXHQvKiogQHBhcmFtIHtzdHJpbmd9IG5ld19wYXRoICovXG5cdGZ1bmN0aW9uIHVwZGF0ZV9wYXRoKG5ld19wYXRoKSB7XG5cdFx0aWYgKHVwZGF0aW5nKSByZXR1cm47XG5cdFx0dXBkYXRpbmcgPSB0cnVlO1xuXHRcdHBhdGggPSBuZXdfcGF0aDtcblxuXHRcdHRhZyh2ZXJzaW9uLCBgJHtwYXRofSB2ZXJzaW9uYCk7XG5cblx0XHQvLyByZW5hbWUgYWxsIGNoaWxkIHNvdXJjZXMgYW5kIGNoaWxkIHByb3hpZXNcblx0XHRmb3IgKGNvbnN0IFtwcm9wLCBzb3VyY2VdIG9mIHNvdXJjZXMpIHtcblx0XHRcdHRhZyhzb3VyY2UsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0fVxuXHRcdHVwZGF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gbmV3IFByb3h5KC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpLCB7XG5cdFx0ZGVmaW5lUHJvcGVydHkoXywgcHJvcCwgZGVzY3JpcHRvcikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQhKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci5jb25maWd1cmFibGUgPT09IGZhbHNlIHx8XG5cdFx0XHRcdGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0ZGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2Vcblx0XHRcdCkge1xuXHRcdFx0XHQvLyB3ZSBkaXNhbGxvdyBub24tYmFzaWMgZGVzY3JpcHRvcnMsIGJlY2F1c2UgdW5sZXNzIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlXG5cdFx0XHRcdC8vIHRhcmdldCBvYmplY3QgXHUyMDE0IHdoaWNoIHdlIGF2b2lkLCBzbyB0aGF0IHN0YXRlIGNhbiBiZSBmb3JrZWQgXHUyMDE0IHdlIHdpbGwgcnVuXG5cdFx0XHRcdC8vIGFmb3VsIG9mIHRoZSB2YXJpb3VzIGludmFyaWFudHNcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvUHJveHkvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yI2ludmFyaWFudHNcblx0XHRcdFx0ZS5zdGF0ZV9kZXNjcmlwdG9yc19maXhlZCgpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHMgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cyA9IHdpdGhfcGFyZW50KCgpID0+IHtcblx0XHRcdFx0XHR2YXIgcyA9IHNvdXJjZShkZXNjcmlwdG9yLnZhbHVlLCBzdGFjayk7XG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdFx0aWYgKERFViAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcztcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXQocywgZGVzY3JpcHRvci52YWx1ZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKHByb3AgaW4gdGFyZ2V0KSB7XG5cdFx0XHRcdFx0Y29uc3QgcyA9IHdpdGhfcGFyZW50KCgpID0+IHNvdXJjZShVTklOSVRJQUxJWkVELCBzdGFjaykpO1xuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHRcdGluY3JlbWVudCh2ZXJzaW9uKTtcblxuXHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0KHMsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRpbmNyZW1lbnQodmVyc2lvbik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuXHRcdFx0aWYgKHByb3AgPT09IFNUQVRFX1NZTUJPTCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChERVYgJiYgcHJvcCA9PT0gUFJPWFlfUEFUSF9TWU1CT0wpIHtcblx0XHRcdFx0cmV0dXJuIHVwZGF0ZV9wYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0dmFyIGV4aXN0cyA9IHByb3AgaW4gdGFyZ2V0O1xuXG5cdFx0XHQvLyBjcmVhdGUgYSBzb3VyY2UsIGJ1dCBvbmx5IGlmIGl0J3MgYW4gb3duIHByb3BlcnR5IGFuZCBub3QgYSBwcm90b3R5cGUgcHJvcGVydHlcblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQgJiYgKCFleGlzdHMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpKSB7XG5cdFx0XHRcdHMgPSB3aXRoX3BhcmVudCgoKSA9PiB7XG5cdFx0XHRcdFx0dmFyIHAgPSBwcm94eShleGlzdHMgPyB0YXJnZXRbcHJvcF0gOiBVTklOSVRJQUxJWkVEKTtcblx0XHRcdFx0XHR2YXIgcyA9IHNvdXJjZShwLCBzdGFjayk7XG5cblx0XHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0XHR0YWcocywgZ2V0X2xhYmVsKHBhdGgsIHByb3ApKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gcztcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIHYgPSBnZXQocyk7XG5cdFx0XHRcdHJldHVybiB2ID09PSBVTklOSVRJQUxJWkVEID8gdW5kZWZpbmVkIDogdjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuXHRcdH0sXG5cblx0XHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG5cdFx0XHR2YXIgZGVzY3JpcHRvciA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdGlmIChkZXNjcmlwdG9yICYmICd2YWx1ZScgaW4gZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgcyA9IHNvdXJjZXMuZ2V0KHByb3ApO1xuXHRcdFx0XHRpZiAocykgZGVzY3JpcHRvci52YWx1ZSA9IGdldChzKTtcblx0XHRcdH0gZWxzZSBpZiAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHZhciBzb3VyY2UgPSBzb3VyY2VzLmdldChwcm9wKTtcblx0XHRcdFx0dmFyIHZhbHVlID0gc291cmNlPy52O1xuXG5cdFx0XHRcdGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRlc2NyaXB0b3I7XG5cdFx0fSxcblxuXHRcdGhhcyh0YXJnZXQsIHByb3ApIHtcblx0XHRcdGlmIChwcm9wID09PSBTVEFURV9TWU1CT0wpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgaGFzID0gKHMgIT09IHVuZGVmaW5lZCAmJiBzLnYgIT09IFVOSU5JVElBTElaRUQpIHx8IFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0cyAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdChhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICghaGFzIHx8IGdldF9kZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk/LndyaXRhYmxlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRpZiAocyA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cyA9IHdpdGhfcGFyZW50KCgpID0+IHtcblx0XHRcdFx0XHRcdHZhciBwID0gaGFzID8gcHJveHkodGFyZ2V0W3Byb3BdKSA6IFVOSU5JVElBTElaRUQ7XG5cdFx0XHRcdFx0XHR2YXIgcyA9IHNvdXJjZShwLCBzdGFjayk7XG5cblx0XHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdFx0dGFnKHMsIGdldF9sYWJlbChwYXRoLCBwcm9wKSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBzO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0c291cmNlcy5zZXQocHJvcCwgcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBnZXQocyk7XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaGFzO1xuXHRcdH0sXG5cblx0XHRzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcblx0XHRcdHZhciBzID0gc291cmNlcy5nZXQocHJvcCk7XG5cdFx0XHR2YXIgaGFzID0gcHJvcCBpbiB0YXJnZXQ7XG5cblx0XHRcdC8vIHZhcmlhYmxlLmxlbmd0aCA9IHZhbHVlIC0+IGNsZWFyIGFsbCBzaWduYWxzIHdpdGggaW5kZXggPj0gdmFsdWVcblx0XHRcdGlmIChpc19wcm94aWVkX2FycmF5ICYmIHByb3AgPT09ICdsZW5ndGgnKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSB2YWx1ZTsgaSA8IC8qKiBAdHlwZSB7U291cmNlPG51bWJlcj59ICovIChzKS52OyBpICs9IDEpIHtcblx0XHRcdFx0XHR2YXIgb3RoZXJfcyA9IHNvdXJjZXMuZ2V0KGkgKyAnJyk7XG5cdFx0XHRcdFx0aWYgKG90aGVyX3MgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0c2V0KG90aGVyX3MsIFVOSU5JVElBTElaRUQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaSBpbiB0YXJnZXQpIHtcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBpdGVtIGV4aXN0cyBpbiB0aGUgb3JpZ2luYWwsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdW5pbml0aWFsaXplZCBzb3VyY2UsXG5cdFx0XHRcdFx0XHQvLyBlbHNlIGEgbGF0ZXIgcmVhZCBvZiB0aGUgcHJvcGVydHkgd291bGQgcmVzdWx0IGluIGEgc291cmNlIGJlaW5nIGNyZWF0ZWQgd2l0aFxuXHRcdFx0XHRcdFx0Ly8gdGhlIHZhbHVlIG9mIHRoZSBvcmlnaW5hbCBpdGVtIGF0IHRoYXQgaW5kZXguXG5cdFx0XHRcdFx0XHRvdGhlcl9zID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKFVOSU5JVElBTElaRUQsIHN0YWNrKSk7XG5cdFx0XHRcdFx0XHRzb3VyY2VzLnNldChpICsgJycsIG90aGVyX3MpO1xuXG5cdFx0XHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0XHRcdHRhZyhvdGhlcl9zLCBnZXRfbGFiZWwocGF0aCwgaSkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlbid0IHlldCBjcmVhdGVkIGEgc291cmNlIGZvciB0aGlzIHByb3BlcnR5LCB3ZSBuZWVkIHRvIGVuc3VyZVxuXHRcdFx0Ly8gd2UgZG8gc28gb3RoZXJ3aXNlIGlmIHdlIHJlYWQgaXQgbGF0ZXIsIHRoZW4gdGhlIHdyaXRlIHdvbid0IGJlIHRyYWNrZWQgYW5kXG5cdFx0XHQvLyB0aGUgaGV1cmlzdGljcyBvZiBlZmZlY3RzIHdpbGwgYmUgZGlmZmVyZW50IHZzIGlmIHdlIGhhZCByZWFkIHRoZSBwcm94aWVkXG5cdFx0XHQvLyBvYmplY3QgcHJvcGVydHkgYmVmb3JlIHdyaXRpbmcgdG8gdGhhdCBwcm9wZXJ0eS5cblx0XHRcdGlmIChzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0aWYgKCFoYXMgfHwgZ2V0X2Rlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKT8ud3JpdGFibGUpIHtcblx0XHRcdFx0XHRzID0gd2l0aF9wYXJlbnQoKCkgPT4gc291cmNlKHVuZGVmaW5lZCwgc3RhY2spKTtcblxuXHRcdFx0XHRcdGlmIChERVYpIHtcblx0XHRcdFx0XHRcdHRhZyhzLCBnZXRfbGFiZWwocGF0aCwgcHJvcCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZXQocywgcHJveHkodmFsdWUpKTtcblxuXHRcdFx0XHRcdHNvdXJjZXMuc2V0KHByb3AsIHMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYXMgPSBzLnYgIT09IFVOSU5JVElBTElaRUQ7XG5cblx0XHRcdFx0dmFyIHAgPSB3aXRoX3BhcmVudCgoKSA9PiBwcm94eSh2YWx1ZSkpO1xuXHRcdFx0XHRzZXQocywgcCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkZXNjcmlwdG9yID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBuZXcgdmFsdWUgYmVmb3JlIHVwZGF0aW5nIGFueSBzaWduYWxzIHNvIHRoYXQgYW55IGxpc3RlbmVycyBnZXQgdGhlIG5ldyB2YWx1ZVxuXHRcdFx0aWYgKGRlc2NyaXB0b3I/LnNldCkge1xuXHRcdFx0XHRkZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCB2YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaGFzKSB7XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgbXV0YXRlZCBhbiBhcnJheSBkaXJlY3RseSwgd2UgbWlnaHQgbmVlZCB0b1xuXHRcdFx0XHQvLyBzaWduYWwgdGhhdCBsZW5ndGggaGFzIGFsc28gY2hhbmdlZC4gRG8gaXQgYmVmb3JlIHVwZGF0aW5nIG1ldGFkYXRhXG5cdFx0XHRcdC8vIHRvIGVuc3VyZSB0aGF0IGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheSBhcyBhIHJlc3VsdCBvZiBhIG1ldGFkYXRhIHVwZGF0ZVxuXHRcdFx0XHQvLyB3aWxsIG5vdCBjYXVzZSB0aGUgbGVuZ3RoIHRvIGJlIG91dCBvZiBzeW5jLlxuXHRcdFx0XHRpZiAoaXNfcHJveGllZF9hcnJheSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR2YXIgbHMgPSAvKiogQHR5cGUge1NvdXJjZTxudW1iZXI+fSAqLyAoc291cmNlcy5nZXQoJ2xlbmd0aCcpKTtcblx0XHRcdFx0XHR2YXIgbiA9IE51bWJlcihwcm9wKTtcblxuXHRcdFx0XHRcdGlmIChOdW1iZXIuaXNJbnRlZ2VyKG4pICYmIG4gPj0gbHMudikge1xuXHRcdFx0XHRcdFx0c2V0KGxzLCBuICsgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5jcmVtZW50KHZlcnNpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0b3duS2V5cyh0YXJnZXQpIHtcblx0XHRcdGdldCh2ZXJzaW9uKTtcblxuXHRcdFx0dmFyIG93bl9rZXlzID0gUmVmbGVjdC5vd25LZXlzKHRhcmdldCkuZmlsdGVyKChrZXkpID0+IHtcblx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZXMuZ2V0KGtleSk7XG5cdFx0XHRcdHJldHVybiBzb3VyY2UgPT09IHVuZGVmaW5lZCB8fCBzb3VyY2UudiAhPT0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBba2V5LCBzb3VyY2VdIG9mIHNvdXJjZXMpIHtcblx0XHRcdFx0aWYgKHNvdXJjZS52ICE9PSBVTklOSVRJQUxJWkVEICYmICEoa2V5IGluIHRhcmdldCkpIHtcblx0XHRcdFx0XHRvd25fa2V5cy5wdXNoKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG93bl9rZXlzO1xuXHRcdH0sXG5cblx0XHRzZXRQcm90b3R5cGVPZigpIHtcblx0XHRcdGUuc3RhdGVfcHJvdG90eXBlX2ZpeGVkKCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtzdHJpbmcgfCBzeW1ib2x9IHByb3BcbiAqL1xuZnVuY3Rpb24gZ2V0X2xhYmVsKHBhdGgsIHByb3ApIHtcblx0aWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykgcmV0dXJuIGAke3BhdGh9W1N5bWJvbCgke3Byb3AuZGVzY3JpcHRpb24gPz8gJyd9KV1gO1xuXHRpZiAocmVnZXhfaXNfdmFsaWRfaWRlbnRpZmllci50ZXN0KHByb3ApKSByZXR1cm4gYCR7cGF0aH0uJHtwcm9wfWA7XG5cdHJldHVybiAvXlxcZCskLy50ZXN0KHByb3ApID8gYCR7cGF0aH1bJHtwcm9wfV1gIDogYCR7cGF0aH1bJyR7cHJvcH0nXWA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfcHJveGllZF92YWx1ZSh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlW1NUQVRFX1NZTUJPTF07XG5cdFx0fVxuXHR9IGNhdGNoIHtcblx0XHQvLyB0aGUgYWJvdmUgaWYgY2hlY2sgY2FuIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpbiBxdWVzdGlvblxuXHRcdC8vIGlzIHRoZSBjb250ZW50V2luZG93IG9mIGFuIGlmcmFtZSBvbiBhbm90aGVyIGRvbWFpbiwgaW4gd2hpY2hcblx0XHQvLyBjYXNlIHdlIHdhbnQgdG8ganVzdCByZXR1cm4gdGhlIHZhbHVlIChiZWNhdXNlIGl0J3MgZGVmaW5pdGVseVxuXHRcdC8vIG5vdCBhIHByb3hpZWQgdmFsdWUpIHNvIHdlIGRvbid0IGJyZWFrIGFueSBKYXZhU2NyaXB0IGludGVyYWN0aW5nXG5cdFx0Ly8gd2l0aCB0aGF0IGlmcmFtZSAoc3VjaCBhcyB2YXJpb3VzIHBheW1lbnQgY29tcGFuaWVzIGNsaWVudCBzaWRlXG5cdFx0Ly8gSmF2YVNjcmlwdCBsaWJyYXJpZXMgaW50ZXJhY3Rpbmcgd2l0aCB0aGVpciBpZnJhbWVzIG9uIHRoZSBzYW1lXG5cdFx0Ly8gZG9tYWluKVxuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoYSwgYikge1xuXHRyZXR1cm4gT2JqZWN0LmlzKGdldF9wcm94aWVkX3ZhbHVlKGEpLCBnZXRfcHJveGllZF92YWx1ZShiKSk7XG59XG5cbmNvbnN0IEFSUkFZX01VVEFUSU5HX01FVEhPRFMgPSBuZXcgU2V0KFtcblx0J2NvcHlXaXRoaW4nLFxuXHQnZmlsbCcsXG5cdCdwb3AnLFxuXHQncHVzaCcsXG5cdCdyZXZlcnNlJyxcblx0J3NoaWZ0Jyxcblx0J3NvcnQnLFxuXHQnc3BsaWNlJyxcblx0J3Vuc2hpZnQnXG5dKTtcblxuLyoqXG4gKiBXcmFwIGFycmF5IG11dGF0aW5nIG1ldGhvZHMgc28gJGluc3BlY3QgaXMgdHJpZ2dlcmVkIG9ubHkgb25jZSBhbmRcbiAqIHRvIHByZXZlbnQgbG9nZ2luZyBhbiBhcnJheSBpbiBpbnRlcm1lZGlhdGUgc3RhdGUgKGUuZy4gd2l0aCBhbiBlbXB0eSBzbG90KVxuICogQHBhcmFtIHthbnlbXX0gYXJyYXlcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdGFibGVfYXJyYXkoYXJyYXkpIHtcblx0cmV0dXJuIG5ldyBQcm94eShhcnJheSwge1xuXHRcdGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcblx0XHRcdGlmICghQVJSQVlfTVVUQVRJTkdfTUVUSE9EUy5oYXMoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwcm9wKSkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEB0aGlzIHthbnlbXX1cblx0XHRcdCAqIEBwYXJhbSB7YW55W119IGFyZ3Ncblx0XHRcdCAqL1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0XHRcdHNldF9pbnNwZWN0X2VmZmVjdHNfZGVmZXJyZWQoKTtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRmbHVzaF9pbnNwZWN0X2VmZmVjdHMoKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0fVxuXHR9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7IGdldF9wcm94aWVkX3ZhbHVlIH0gZnJvbSAnLi4vcHJveHkuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5pdF9hcnJheV9wcm90b3R5cGVfd2FybmluZ3MoKSB7XG5cdGNvbnN0IGFycmF5X3Byb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblx0Ly8gVGhlIFJFUEwgZW5kcyB1cCBoZXJlIG92ZXIgYW5kIG92ZXIsIGFuZCB0aGlzIHByZXZlbnRzIGl0IGZyb20gYWRkaW5nIG1vcmUgYW5kIG1vcmUgcGF0Y2hlc1xuXHQvLyBvZiB0aGUgc2FtZSBraW5kIHRvIHRoZSBwcm90b3R5cGUsIHdoaWNoIHdvdWxkIHNsb3cgZG93biBldmVyeXRoaW5nIG92ZXIgdGltZS5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBjbGVhbnVwID0gQXJyYXkuX19zdmVsdGVfY2xlYW51cDtcblx0aWYgKGNsZWFudXApIHtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjb25zdCB7IGluZGV4T2YsIGxhc3RJbmRleE9mLCBpbmNsdWRlcyB9ID0gYXJyYXlfcHJvdG90eXBlO1xuXG5cdGFycmF5X3Byb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gKGl0ZW0sIGZyb21faW5kZXgpIHtcblx0XHRjb25zdCBpbmRleCA9IGluZGV4T2YuY2FsbCh0aGlzLCBpdGVtLCBmcm9tX2luZGV4KTtcblxuXHRcdGlmIChpbmRleCA9PT0gLTEpIHtcblx0XHRcdGZvciAobGV0IGkgPSBmcm9tX2luZGV4ID8/IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5LmluZGV4T2YoLi4uKScpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9O1xuXG5cdGFycmF5X3Byb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIChpdGVtLCBmcm9tX2luZGV4KSB7XG5cdFx0Ly8gd2UgbmVlZCB0byBzcGVjaWZ5IHRoaXMubGVuZ3RoIC0gMSBiZWNhdXNlIGl0J3MgcHJvYmFibHkgdXNpbmcgc29tZXRoaW5nIGxpa2Vcblx0XHQvLyBgYXJndW1lbnRzYCBpbnNpZGUgc28gcGFzc2luZyB1bmRlZmluZWQgaXMgZGlmZmVyZW50IGZyb20gbm90IHBhc3NpbmcgYW55dGhpbmdcblx0XHRjb25zdCBpbmRleCA9IGxhc3RJbmRleE9mLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCA/PyB0aGlzLmxlbmd0aCAtIDEpO1xuXG5cdFx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPD0gKGZyb21faW5kZXggPz8gdGhpcy5sZW5ndGggLSAxKTsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5Lmxhc3RJbmRleE9mKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBpbmRleDtcblx0fTtcblxuXHRhcnJheV9wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoaXRlbSwgZnJvbV9pbmRleCkge1xuXHRcdGNvbnN0IGhhcyA9IGluY2x1ZGVzLmNhbGwodGhpcywgaXRlbSwgZnJvbV9pbmRleCk7XG5cblx0XHRpZiAoIWhhcykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdGlmIChnZXRfcHJveGllZF92YWx1ZSh0aGlzW2ldKSA9PT0gaXRlbSkge1xuXHRcdFx0XHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goJ2FycmF5LmluY2x1ZGVzKC4uLiknKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBoYXM7XG5cdH07XG5cblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRBcnJheS5fX3N2ZWx0ZV9jbGVhbnVwID0gKCkgPT4ge1xuXHRcdGFycmF5X3Byb3RvdHlwZS5pbmRleE9mID0gaW5kZXhPZjtcblx0XHRhcnJheV9wcm90b3R5cGUubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcblx0XHRhcnJheV9wcm90b3R5cGUuaW5jbHVkZXMgPSBpbmNsdWRlcztcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXF1YWxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaWN0X2VxdWFscyhhLCBiLCBlcXVhbCA9IHRydWUpIHtcblx0Ly8gdHJ5LWNhdGNoIG5lZWRlZCBiZWNhdXNlIHRoaXMgdHJpZXMgdG8gcmVhZCBwcm9wZXJ0aWVzIG9mIGBhYCBhbmQgYGJgLFxuXHQvLyB3aGljaCBjb3VsZCBiZSBkaXNhbGxvd2VkIGZvciBleGFtcGxlIGluIGEgc2VjdXJlIGNvbnRleHRcblx0dHJ5IHtcblx0XHRpZiAoKGEgPT09IGIpICE9PSAoZ2V0X3Byb3hpZWRfdmFsdWUoYSkgPT09IGdldF9wcm94aWVkX3ZhbHVlKGIpKSkge1xuXHRcdFx0dy5zdGF0ZV9wcm94eV9lcXVhbGl0eV9taXNtYXRjaChlcXVhbCA/ICc9PT0nIDogJyE9PScpO1xuXHRcdH1cblx0fSBjYXRjaCB7fVxuXG5cdHJldHVybiAoYSA9PT0gYikgPT09IGVxdWFsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHBhcmFtIHtib29sZWFufSBlcXVhbFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYiwgZXF1YWwgPSB0cnVlKSB7XG5cdGlmICgoYSA9PSBiKSAhPT0gKGdldF9wcm94aWVkX3ZhbHVlKGEpID09IGdldF9wcm94aWVkX3ZhbHVlKGIpKSkge1xuXHRcdHcuc3RhdGVfcHJveHlfZXF1YWxpdHlfbWlzbWF0Y2goZXF1YWwgPyAnPT0nIDogJyE9Jyk7XG5cdH1cblxuXHRyZXR1cm4gKGEgPT0gYikgPT09IGVxdWFsO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcsIHNldF9oeWRyYXRlX25vZGUgfSBmcm9tICcuL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGluaXRfYXJyYXlfcHJvdG90eXBlX3dhcm5pbmdzIH0gZnJvbSAnLi4vZGV2L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yLCBpc19leHRlbnNpYmxlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGFzeW5jX21vZGVfZmxhZyB9IGZyb20gJy4uLy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IFRFWFRfTk9ERSwgRUZGRUNUX1JBTiB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGVhZ2VyX2Jsb2NrX2VmZmVjdHMgfSBmcm9tICcuLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLy8gZXhwb3J0IHRoZXNlIGZvciByZWZlcmVuY2UgaW4gdGhlIGNvbXBpbGVkIGNvZGUsIG1ha2luZyBnbG9iYWwgbmFtZSBkZWR1cGxpY2F0aW9uIHVubmVjZXNzYXJ5XG4vKiogQHR5cGUge1dpbmRvd30gKi9cbmV4cG9ydCB2YXIgJHdpbmRvdztcblxuLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbmV4cG9ydCB2YXIgJGRvY3VtZW50O1xuXG4vKiogQHR5cGUge2Jvb2xlYW59ICovXG5leHBvcnQgdmFyIGlzX2ZpcmVmb3g7XG5cbi8qKiBAdHlwZSB7KCkgPT4gTm9kZSB8IG51bGx9ICovXG52YXIgZmlyc3RfY2hpbGRfZ2V0dGVyO1xuLyoqIEB0eXBlIHsoKSA9PiBOb2RlIHwgbnVsbH0gKi9cbnZhciBuZXh0X3NpYmxpbmdfZ2V0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlc2UgbGF6aWx5IHRvIGF2b2lkIGlzc3VlcyB3aGVuIHVzaW5nIHRoZSBydW50aW1lIGluIGEgc2VydmVyIGNvbnRleHRcbiAqIHdoZXJlIHRoZXNlIGdsb2JhbHMgYXJlIG5vdCBhdmFpbGFibGUgd2hpbGUgYXZvaWRpbmcgYSBzZXBhcmF0ZSBzZXJ2ZXIgZW50cnkgcG9pbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRfb3BlcmF0aW9ucygpIHtcblx0aWYgKCR3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdCR3aW5kb3cgPSB3aW5kb3c7XG5cdCRkb2N1bWVudCA9IGRvY3VtZW50O1xuXHRpc19maXJlZm94ID0gL0ZpcmVmb3gvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0dmFyIGVsZW1lbnRfcHJvdG90eXBlID0gRWxlbWVudC5wcm90b3R5cGU7XG5cdHZhciBub2RlX3Byb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlO1xuXHR2YXIgdGV4dF9wcm90b3R5cGUgPSBUZXh0LnByb3RvdHlwZTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdGZpcnN0X2NoaWxkX2dldHRlciA9IGdldF9kZXNjcmlwdG9yKG5vZGVfcHJvdG90eXBlLCAnZmlyc3RDaGlsZCcpLmdldDtcblx0Ly8gQHRzLWlnbm9yZVxuXHRuZXh0X3NpYmxpbmdfZ2V0dGVyID0gZ2V0X2Rlc2NyaXB0b3Iobm9kZV9wcm90b3R5cGUsICduZXh0U2libGluZycpLmdldDtcblxuXHRpZiAoaXNfZXh0ZW5zaWJsZShlbGVtZW50X3Byb3RvdHlwZSkpIHtcblx0XHQvLyB0aGUgZm9sbG93aW5nIGFzc2lnbm1lbnRzIGltcHJvdmUgcGVyZiBvZiBsb29rdXBzIG9uIERPTSBub2Rlc1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsaWNrID0gdW5kZWZpbmVkO1xuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50X3Byb3RvdHlwZS5fX2NsYXNzTmFtZSA9IHVuZGVmaW5lZDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19hdHRyaWJ1dGVzID0gbnVsbDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdHlsZSA9IHVuZGVmaW5lZDtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19lID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKGlzX2V4dGVuc2libGUodGV4dF9wcm90b3R5cGUpKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdHRleHRfcHJvdG90eXBlLl9fdCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudF9wcm90b3R5cGUuX19zdmVsdGVfbWV0YSA9IG51bGw7XG5cblx0XHRpbml0X2FycmF5X3Byb3RvdHlwZV93YXJuaW5ncygpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7VGV4dH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZV90ZXh0KHZhbHVlID0gJycpIHtcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG4vKkBfX05PX1NJREVfRUZGRUNUU19fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRfZmlyc3RfY2hpbGQobm9kZSkge1xuXHRyZXR1cm4gZmlyc3RfY2hpbGRfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAqL1xuLypAX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZ2V0X25leHRfc2libGluZyhub2RlKSB7XG5cdHJldHVybiBuZXh0X3NpYmxpbmdfZ2V0dGVyLmNhbGwobm9kZSk7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHRlbXBsYXRlIHtOb2RlfSBOXG4gKiBAcGFyYW0ge059IG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hpbGQobm9kZSwgaXNfdGV4dCkge1xuXHRpZiAoIWh5ZHJhdGluZykge1xuXHRcdHJldHVybiBnZXRfZmlyc3RfY2hpbGQobm9kZSk7XG5cdH1cblxuXHR2YXIgY2hpbGQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChoeWRyYXRlX25vZGUpKTtcblxuXHQvLyBDaGlsZCBjYW4gYmUgbnVsbCBpZiB3ZSBoYXZlIGFuIGVsZW1lbnQgd2l0aCBhIHNpbmdsZSBjaGlsZCwgbGlrZSBgPHA+e3RleHR9PC9wPmAsIHdoZXJlIGB0ZXh0YCBpcyBlbXB0eVxuXHRpZiAoY2hpbGQgPT09IG51bGwpIHtcblx0XHRjaGlsZCA9IGh5ZHJhdGVfbm9kZS5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKTtcblx0fSBlbHNlIGlmIChpc190ZXh0ICYmIGNoaWxkLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcblx0XHR2YXIgdGV4dCA9IGNyZWF0ZV90ZXh0KCk7XG5cdFx0Y2hpbGQ/LmJlZm9yZSh0ZXh0KTtcblx0XHRzZXRfaHlkcmF0ZV9ub2RlKHRleHQpO1xuXHRcdHJldHVybiB0ZXh0O1xuXHR9XG5cblx0c2V0X2h5ZHJhdGVfbm9kZShjaGlsZCk7XG5cdHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBEb24ndCBtYXJrIHRoaXMgYXMgc2lkZS1lZmZlY3QtZnJlZSwgaHlkcmF0aW9uIG5lZWRzIHRvIHdhbGsgYWxsIG5vZGVzXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnQgfCBUZW1wbGF0ZU5vZGVbXX0gZnJhZ21lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNfdGV4dFxuICogQHJldHVybnMge05vZGUgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RfY2hpbGQoZnJhZ21lbnQsIGlzX3RleHQpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHQvLyB3aGVuIG5vdCBoeWRyYXRpbmcsIGBmcmFnbWVudGAgaXMgYSBgRG9jdW1lbnRGcmFnbWVudGAgKHRoZSByZXN1bHQgb2YgY2FsbGluZyBgb3Blbl9mcmFnYClcblx0XHR2YXIgZmlyc3QgPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZnJhZ21lbnQpKSk7XG5cblx0XHQvLyBUT0RPIHByZXZlbnQgdXNlciBjb21tZW50cyB3aXRoIHRoZSBlbXB0eSBzdHJpbmcgd2hlbiBwcmVzZXJ2ZUNvbW1lbnRzIGlzIHRydWVcblx0XHRpZiAoZmlyc3QgaW5zdGFuY2VvZiBDb21tZW50ICYmIGZpcnN0LmRhdGEgPT09ICcnKSByZXR1cm4gZ2V0X25leHRfc2libGluZyhmaXJzdCk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH1cblxuXHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUgXHUyMDE0IHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgaHlkcmF0ZV9ub2RlPy5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXG5cdFx0aHlkcmF0ZV9ub2RlPy5iZWZvcmUodGV4dCk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHJldHVybiBoeWRyYXRlX25vZGU7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtib29sZWFufSBpc190ZXh0XG4gKiBAcmV0dXJucyB7Tm9kZSB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWJsaW5nKG5vZGUsIGNvdW50ID0gMSwgaXNfdGV4dCA9IGZhbHNlKSB7XG5cdGxldCBuZXh0X3NpYmxpbmcgPSBoeWRyYXRpbmcgPyBoeWRyYXRlX25vZGUgOiBub2RlO1xuXHR2YXIgbGFzdF9zaWJsaW5nO1xuXG5cdHdoaWxlIChjb3VudC0tKSB7XG5cdFx0bGFzdF9zaWJsaW5nID0gbmV4dF9zaWJsaW5nO1xuXHRcdG5leHRfc2libGluZyA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhuZXh0X3NpYmxpbmcpKTtcblx0fVxuXG5cdGlmICghaHlkcmF0aW5nKSB7XG5cdFx0cmV0dXJuIG5leHRfc2libGluZztcblx0fVxuXG5cdC8vIGlmIGEgc2libGluZyB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgdGhlcmUgbWlnaHQgYmUgbm9cblx0Ly8gdGV4dCBub2RlIHRvIGh5ZHJhdGUgXHUyMDE0IHdlIG11c3QgdGhlcmVmb3JlIGNyZWF0ZSBvbmVcblx0aWYgKGlzX3RleHQgJiYgbmV4dF9zaWJsaW5nPy5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG5cdFx0dmFyIHRleHQgPSBjcmVhdGVfdGV4dCgpO1xuXHRcdC8vIElmIHRoZSBuZXh0IHNpYmxpbmcgaXMgYG51bGxgIGFuZCB3ZSdyZSBoYW5kbGluZyB0ZXh0IHRoZW4gaXQncyBiZWNhdXNlXG5cdFx0Ly8gdGhlIFNTUiBjb250ZW50IHdhcyBlbXB0eSBmb3IgdGhlIHRleHQsIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgYSBuZXcgdGV4dFxuXHRcdC8vIG5vZGUgYW5kIGluc2VydCBpdCBhZnRlciB0aGUgbGFzdCBzaWJsaW5nXG5cdFx0aWYgKG5leHRfc2libGluZyA9PT0gbnVsbCkge1xuXHRcdFx0bGFzdF9zaWJsaW5nPy5hZnRlcih0ZXh0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV4dF9zaWJsaW5nLmJlZm9yZSh0ZXh0KTtcblx0XHR9XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSh0ZXh0KTtcblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdHNldF9oeWRyYXRlX25vZGUobmV4dF9zaWJsaW5nKTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobmV4dF9zaWJsaW5nKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUge05vZGV9IE5cbiAqIEBwYXJhbSB7Tn0gbm9kZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcl90ZXh0X2NvbnRlbnQobm9kZSkge1xuXHRub2RlLnRleHRDb250ZW50ID0gJyc7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgd2UncmUgdXBkYXRpbmcgdGhlIGN1cnJlbnQgYmxvY2ssIGZvciBleGFtcGxlIGBjb25kaXRpb25gIGluXG4gKiBhbiBgeyNpZiBjb25kaXRpb259YCBibG9jayBqdXN0IGNoYW5nZWQuIEluIHRoaXMgY2FzZSwgdGhlIGJyYW5jaCBzaG91bGQgYmVcbiAqIGFwcGVuZGVkIChvciByZW1vdmVkKSBhdCB0aGUgc2FtZSB0aW1lIGFzIG90aGVyIHVwZGF0ZXMgd2l0aGluIHRoZVxuICogY3VycmVudCBgPHN2ZWx0ZTpib3VuZGFyeT5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRfZGVmZXJfYXBwZW5kKCkge1xuXHRpZiAoIWFzeW5jX21vZGVfZmxhZykgcmV0dXJuIGZhbHNlO1xuXHRpZiAoZWFnZXJfYmxvY2tfZWZmZWN0cyAhPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG5cdHZhciBmbGFncyA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkuZjtcblx0cmV0dXJuIChmbGFncyAmIEVGRkVDVF9SQU4pICE9PSAwO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW25hbWVzcGFjZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaXNdXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2VsZW1lbnQodGFnLCBuYW1lc3BhY2UsIGlzKSB7XG5cdGxldCBvcHRpb25zID0gaXMgPyB7IGlzIH0gOiB1bmRlZmluZWQ7XG5cdGlmIChuYW1lc3BhY2UpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnLCBvcHRpb25zKTtcblx0fVxuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50KCkge1xuXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2NvbW1lbnQoZGF0YSA9ICcnKSB7XG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGRhdGEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlID0gJycpIHtcblx0aWYgKGtleS5zdGFydHNXaXRoKCd4bGluazonKSkge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBrZXksIHZhbHVlKTtcblx0XHRyZXR1cm47XG5cdH1cblx0cmV0dXJuIGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xufVxuIiwgImltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjbGVhcl90ZXh0X2NvbnRlbnQsIGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgcXVldWVfbWljcm9fdGFzayB9IGZyb20gJy4uL3Rhc2suanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvZm9jdXMoZG9tLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUpIHtcblx0XHRjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0XHRkb20uYXV0b2ZvY3VzID0gdHJ1ZTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGJvZHkpIHtcblx0XHRcdFx0ZG9tLmZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgY2hpbGQgb2YgYSB0ZXh0YXJlYSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTFRleHRBcmVhRWxlbWVudH0gZG9tXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV90ZXh0YXJlYV9jaGlsZChkb20pIHtcblx0aWYgKGh5ZHJhdGluZyAmJiBnZXRfZmlyc3RfY2hpbGQoZG9tKSAhPT0gbnVsbCkge1xuXHRcdGNsZWFyX3RleHRfY29udGVudChkb20pO1xuXHR9XG59XG5cbmxldCBsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIoKSB7XG5cdGlmICghbGlzdGVuaW5nX3RvX2Zvcm1fcmVzZXQpIHtcblx0XHRsaXN0ZW5pbmdfdG9fZm9ybV9yZXNldCA9IHRydWU7XG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdCdyZXNldCcsXG5cdFx0XHQoZXZ0KSA9PiB7XG5cdFx0XHRcdC8vIE5lZWRzIHRvIGhhcHBlbiBvbmUgdGljayBsYXRlciBvciBlbHNlIHRoZSBkb20gcHJvcGVydGllcyBvZiB0aGUgZm9ybVxuXHRcdFx0XHQvLyBlbGVtZW50cyBoYXZlIG5vdCB1cGRhdGVkIHRvIHRoZWlyIHJlc2V0IHZhbHVlcyB5ZXRcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCFldnQuZGVmYXVsdFByZXZlbnRlZCkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBlIG9mIC8qKkB0eXBlIHtIVE1MRm9ybUVsZW1lbnR9ICovIChldnQudGFyZ2V0KS5lbGVtZW50cykge1xuXHRcdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHRcdGUuX19vbl9yPy4oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdC8vIEluIHRoZSBjYXB0dXJlIHBoYXNlIHRvIGd1YXJhbnRlZSB3ZSBnZXQgbm90aWNlZCBvZiBpdCAobm8gcG9zc2libGl0eSBvZiBzdG9wUHJvcGFnYXRpb24pXG5cdFx0XHR7IGNhcHR1cmU6IHRydWUgfVxuXHRcdCk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHRzZXRfYWN0aXZlX3JlYWN0aW9uXG59IGZyb20gJy4uLy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgYWRkX2Zvcm1fcmVzZXRfbGlzdGVuZXIgfSBmcm9tICcuLi9taXNjLmpzJztcblxuLyoqXG4gKiBGaXJlcyB0aGUgaGFuZGxlciBvbmNlIGltbWVkaWF0ZWx5ICh1bmxlc3MgY29ycmVzcG9uZGluZyBhcmcgaXMgc2V0IHRvIGBmYWxzZWApLFxuICogdGhlbiBsaXN0ZW5zIHRvIHRoZSBnaXZlbiBldmVudHMgdW50aWwgdGhlIHJlbmRlciBlZmZlY3QgY29udGV4dCBpcyBkZXN0cm95ZWRcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBldmVudHNcbiAqIEBwYXJhbSB7KGV2ZW50PzogRXZlbnQpID0+IHZvaWR9IGhhbmRsZXJcbiAqIEBwYXJhbSB7YW55fSBjYWxsX2hhbmRsZXJfaW1tZWRpYXRlbHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50cywgaGFuZGxlciwgY2FsbF9oYW5kbGVyX2ltbWVkaWF0ZWx5ID0gdHJ1ZSkge1xuXHRpZiAoY2FsbF9oYW5kbGVyX2ltbWVkaWF0ZWx5KSB7XG5cdFx0aGFuZGxlcigpO1xuXHR9XG5cblx0Zm9yICh2YXIgbmFtZSBvZiBldmVudHMpIHtcblx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcblx0fVxuXG5cdHRlYXJkb3duKCgpID0+IHtcblx0XHRmb3IgKHZhciBuYW1lIG9mIGV2ZW50cykge1xuXHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KGZuKSB7XG5cdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXHR0cnkge1xuXHRcdHJldHVybiBmbigpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBMaXN0ZW4gdG8gdGhlIGdpdmVuIGV2ZW50LCBhbmQgdGhlbiBpbnN0YW50aWF0ZSBhIGdsb2JhbCBmb3JtIHJlc2V0IGxpc3RlbmVyIGlmIG5vdCBhbHJlYWR5IGRvbmUsXG4gKiB0byBub3RpZnkgYWxsIGJpbmRpbmdzIHdoZW4gdGhlIGZvcm0gaXMgcmVzZXRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICogQHBhcmFtIHsoaXNfcmVzZXQ/OiB0cnVlKSA9PiB2b2lkfSBoYW5kbGVyXG4gKiBAcGFyYW0geyhpc19yZXNldD86IHRydWUpID0+IHZvaWR9IFtvbl9yZXNldF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9uX3Jlc2V0ID0gaGFuZGxlcikge1xuXHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsICgpID0+IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dChoYW5kbGVyKSk7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0Y29uc3QgcHJldiA9IGVsZW1lbnQuX19vbl9yO1xuXHRpZiAocHJldikge1xuXHRcdC8vIHNwZWNpYWwgY2FzZSBmb3IgY2hlY2tib3ggdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZSBiaW5kcyAoZ3JvdXAgJiBjaGVja2VkKVxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRlbGVtZW50Ll9fb25fciA9ICgpID0+IHtcblx0XHRcdHByZXYoKTtcblx0XHRcdG9uX3Jlc2V0KHRydWUpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnQuX19vbl9yID0gKCkgPT4gb25fcmVzZXQodHJ1ZSk7XG5cdH1cblxuXHRhZGRfZm9ybV9yZXNldF9saXN0ZW5lcigpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgQ29tcG9uZW50Q29udGV4dExlZ2FjeSwgRGVyaXZlZCwgRWZmZWN0LCBUZW1wbGF0ZU5vZGUsIFRyYW5zaXRpb25NYW5hZ2VyIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7XG5cdGlzX2RpcnR5LFxuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdHVwZGF0ZV9lZmZlY3QsXG5cdGdldCxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHJlbW92ZV9yZWFjdGlvbnMsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24sXG5cdHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCxcblx0c2V0X3NpZ25hbF9zdGF0dXMsXG5cdHVudHJhY2ssXG5cdHVudHJhY2tpbmdcbn0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQge1xuXHRESVJUWSxcblx0QlJBTkNIX0VGRkVDVCxcblx0UkVOREVSX0VGRkVDVCxcblx0RUZGRUNULFxuXHRERVNUUk9ZRUQsXG5cdElORVJULFxuXHRFRkZFQ1RfUkFOLFxuXHRCTE9DS19FRkZFQ1QsXG5cdFJPT1RfRUZGRUNULFxuXHRFRkZFQ1RfVFJBTlNQQVJFTlQsXG5cdERFUklWRUQsXG5cdFVOT1dORUQsXG5cdENMRUFOLFxuXHRJTlNQRUNUX0VGRkVDVCxcblx0SEVBRF9FRkZFQ1QsXG5cdE1BWUJFX0RJUlRZLFxuXHRFRkZFQ1RfUFJFU0VSVkVELFxuXHRTVEFMRV9SRUFDVElPTixcblx0VVNFUl9FRkZFQ1QsXG5cdEFTWU5DXG59IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5IH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9kb20vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLCBkZXZfc3RhY2sgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IEJhdGNoLCBzY2hlZHVsZV9lZmZlY3QgfSBmcm9tICcuL2JhdGNoLmpzJztcbmltcG9ydCB7IGZsYXR0ZW4gfSBmcm9tICcuL2FzeW5jLmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4uL2RvbS9lbGVtZW50cy9iaW5kaW5ncy9zaGFyZWQuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7JyRlZmZlY3QnIHwgJyRlZmZlY3QucHJlJyB8ICckaW5zcGVjdCd9IHJ1bmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2VmZmVjdChydW5lKSB7XG5cdGlmIChhY3RpdmVfZWZmZWN0ID09PSBudWxsICYmIGFjdGl2ZV9yZWFjdGlvbiA9PT0gbnVsbCkge1xuXHRcdGUuZWZmZWN0X29ycGhhbihydW5lKTtcblx0fVxuXG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKGFjdGl2ZV9yZWFjdGlvbi5mICYgVU5PV05FRCkgIT09IDAgJiYgYWN0aXZlX2VmZmVjdCA9PT0gbnVsbCkge1xuXHRcdGUuZWZmZWN0X2luX3Vub3duZWRfZGVyaXZlZCgpO1xuXHR9XG5cblx0aWYgKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0KSB7XG5cdFx0ZS5lZmZlY3RfaW5fdGVhcmRvd24ocnVuZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge0VmZmVjdH0gcGFyZW50X2VmZmVjdFxuICovXG5mdW5jdGlvbiBwdXNoX2VmZmVjdChlZmZlY3QsIHBhcmVudF9lZmZlY3QpIHtcblx0dmFyIHBhcmVudF9sYXN0ID0gcGFyZW50X2VmZmVjdC5sYXN0O1xuXHRpZiAocGFyZW50X2xhc3QgPT09IG51bGwpIHtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBwYXJlbnRfZWZmZWN0LmZpcnN0ID0gZWZmZWN0O1xuXHR9IGVsc2Uge1xuXHRcdHBhcmVudF9sYXN0Lm5leHQgPSBlZmZlY3Q7XG5cdFx0ZWZmZWN0LnByZXYgPSBwYXJlbnRfbGFzdDtcblx0XHRwYXJlbnRfZWZmZWN0Lmxhc3QgPSBlZmZlY3Q7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHBhcmFtIHtudWxsIHwgKCgpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCkpfSBmblxuICogQHBhcmFtIHtib29sZWFufSBzeW5jXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHB1c2hcbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9lZmZlY3QodHlwZSwgZm4sIHN5bmMsIHB1c2ggPSB0cnVlKSB7XG5cdHZhciBwYXJlbnQgPSBhY3RpdmVfZWZmZWN0O1xuXG5cdGlmIChERVYpIHtcblx0XHQvLyBFbnN1cmUgdGhlIHBhcmVudCBpcyBuZXZlciBhbiBpbnNwZWN0IGVmZmVjdFxuXHRcdHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudC5mICYgSU5TUEVDVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdGlmIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudC5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0dHlwZSB8PSBJTkVSVDtcblx0fVxuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgZWZmZWN0ID0ge1xuXHRcdGN0eDogY29tcG9uZW50X2NvbnRleHQsXG5cdFx0ZGVwczogbnVsbCxcblx0XHRub2Rlc19zdGFydDogbnVsbCxcblx0XHRub2Rlc19lbmQ6IG51bGwsXG5cdFx0ZjogdHlwZSB8IERJUlRZLFxuXHRcdGZpcnN0OiBudWxsLFxuXHRcdGZuLFxuXHRcdGxhc3Q6IG51bGwsXG5cdFx0bmV4dDogbnVsbCxcblx0XHRwYXJlbnQsXG5cdFx0YjogcGFyZW50ICYmIHBhcmVudC5iLFxuXHRcdHByZXY6IG51bGwsXG5cdFx0dGVhcmRvd246IG51bGwsXG5cdFx0dHJhbnNpdGlvbnM6IG51bGwsXG5cdFx0d3Y6IDAsXG5cdFx0YWM6IG51bGxcblx0fTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbiA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbjtcblx0fVxuXG5cdGlmIChzeW5jKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdGVmZmVjdC5mIHw9IEVGRkVDVF9SQU47XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKGZuICE9PSBudWxsKSB7XG5cdFx0c2NoZWR1bGVfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHRpZiAocHVzaCkge1xuXHRcdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0XHR2YXIgZSA9IGVmZmVjdDtcblxuXHRcdC8vIGlmIGFuIGVmZmVjdCBoYXMgYWxyZWFkeSByYW4gYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBrZXB0IGluIHRoZSB0cmVlXG5cdFx0Ly8gKGJlY2F1c2UgaXQgd29uJ3QgcmUtcnVuLCBoYXMgbm8gRE9NLCBhbmQgaGFzIG5vIHRlYXJkb3duIGV0Yylcblx0XHQvLyB0aGVuIHdlIHNraXAgaXQgYW5kIGdvIHRvIGl0cyBjaGlsZCAoaWYgYW55KVxuXHRcdGlmIChcblx0XHRcdHN5bmMgJiZcblx0XHRcdGUuZGVwcyA9PT0gbnVsbCAmJlxuXHRcdFx0ZS50ZWFyZG93biA9PT0gbnVsbCAmJlxuXHRcdFx0ZS5ub2Rlc19zdGFydCA9PT0gbnVsbCAmJlxuXHRcdFx0ZS5maXJzdCA9PT0gZS5sYXN0ICYmIC8vIGVpdGhlciBgbnVsbGAsIG9yIGEgc2luZ3VsYXIgY2hpbGRcblx0XHRcdChlLmYgJiBFRkZFQ1RfUFJFU0VSVkVEKSA9PT0gMFxuXHRcdCkge1xuXHRcdFx0ZSA9IGUuZmlyc3Q7XG5cdFx0fVxuXG5cdFx0aWYgKGUgIT09IG51bGwpIHtcblx0XHRcdGUucGFyZW50ID0gcGFyZW50O1xuXG5cdFx0XHRpZiAocGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRcdHB1c2hfZWZmZWN0KGUsIHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIHdlJ3JlIGluIGEgZGVyaXZlZCwgYWRkIHRoZSBlZmZlY3QgdGhlcmUgdG9vXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdFx0XHQoYWN0aXZlX3JlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdFx0XHQodHlwZSAmIFJPT1RfRUZGRUNUKSA9PT0gMFxuXHRcdFx0KSB7XG5cdFx0XHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoYWN0aXZlX3JlYWN0aW9uKTtcblx0XHRcdFx0KGRlcml2ZWQuZWZmZWN0cyA/Pz0gW10pLnB1c2goZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdC50cmFja2luZygpYFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3RfdHJhY2tpbmcoKSB7XG5cdHJldHVybiBhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgIXVudHJhY2tpbmc7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVhcmRvd24oZm4pIHtcblx0Y29uc3QgZWZmZWN0ID0gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNULCBudWxsLCBmYWxzZSk7XG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXHRlZmZlY3QudGVhcmRvd24gPSBmbjtcblx0cmV0dXJuIGVmZmVjdDtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgJGVmZmVjdCguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlcl9lZmZlY3QoZm4pIHtcblx0dmFsaWRhdGVfZWZmZWN0KCckZWZmZWN0Jyk7XG5cblx0aWYgKERFVikge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG5cdFx0XHR2YWx1ZTogJyRlZmZlY3QnXG5cdFx0fSk7XG5cdH1cblxuXHQvLyBOb24tbmVzdGVkIGAkZWZmZWN0KC4uLilgIGluIGEgY29tcG9uZW50IHNob3VsZCBiZSBkZWZlcnJlZFxuXHQvLyB1bnRpbCB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWRcblx0dmFyIGZsYWdzID0gLyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5mO1xuXHR2YXIgZGVmZXIgPSAhYWN0aXZlX3JlYWN0aW9uICYmIChmbGFncyAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwICYmIChmbGFncyAmIEVGRkVDVF9SQU4pID09PSAwO1xuXG5cdGlmIChkZWZlcikge1xuXHRcdC8vIFRvcC1sZXZlbCBgJGVmZmVjdCguLi4pYCBpbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50IFx1MjAxNCBkZWZlciB1bnRpbCBtb3VudFxuXHRcdHZhciBjb250ZXh0ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdChjb250ZXh0LmUgPz89IFtdKS5wdXNoKGZuKTtcblx0fSBlbHNlIHtcblx0XHQvLyBFdmVyeXRoaW5nIGVsc2UgXHUyMDE0IGNyZWF0ZSBpbW1lZGlhdGVseVxuXHRcdHJldHVybiBjcmVhdGVfdXNlcl9lZmZlY3QoZm4pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX3VzZXJfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEVGRkVDVCB8IFVTRVJfRUZGRUNULCBmbiwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnByZSguLi4pYFxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge0VmZmVjdH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZXJfcHJlX2VmZmVjdChmbikge1xuXHR2YWxpZGF0ZV9lZmZlY3QoJyRlZmZlY3QucHJlJyk7XG5cdGlmIChERVYpIHtcblx0XHRkZWZpbmVfcHJvcGVydHkoZm4sICduYW1lJywge1xuXHRcdFx0dmFsdWU6ICckZWZmZWN0LnByZSdcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChSRU5ERVJfRUZGRUNUIHwgVVNFUl9FRkZFQ1QsIGZuLCB0cnVlKTtcbn1cblxuLyoqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNwZWN0X2VmZmVjdChmbikge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChJTlNQRUNUX0VGRkVDVCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkZWZmZWN0LnJvb3QoLi4uKWBcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWZmZWN0X3Jvb3QoZm4pIHtcblx0QmF0Y2guZW5zdXJlKCk7XG5cdGNvbnN0IGVmZmVjdCA9IGNyZWF0ZV9lZmZlY3QoUk9PVF9FRkZFQ1QgfCBFRkZFQ1RfUFJFU0VSVkVELCBmbiwgdHJ1ZSk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHR9O1xufVxuXG4vKipcbiAqIEFuIGVmZmVjdCByb290IHdob3NlIGNoaWxkcmVuIGNhbiB0cmFuc2l0aW9uIG91dFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhvcHRpb25zPzogeyBvdXRybz86IGJvb2xlYW4gfSkgPT4gUHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudF9yb290KGZuKSB7XG5cdEJhdGNoLmVuc3VyZSgpO1xuXHRjb25zdCBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KFJPT1RfRUZGRUNUIHwgRUZGRUNUX1BSRVNFUlZFRCwgZm4sIHRydWUpO1xuXG5cdHJldHVybiAob3B0aW9ucyA9IHt9KSA9PiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWwpID0+IHtcblx0XHRcdGlmIChvcHRpb25zLm91dHJvKSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRkZXN0cm95X2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0XHRcdGZ1bGZpbCh1bmRlZmluZWQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRcdGZ1bGZpbCh1bmRlZmluZWQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZmZlY3QoZm4pIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoRUZGRUNULCBmbiwgZmFsc2UpO1xufVxuXG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGAkOiAuLmBcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBkZXBzXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcHJlX2VmZmVjdChkZXBzLCBmbikge1xuXHR2YXIgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHQvKiogQHR5cGUge3sgZWZmZWN0OiBudWxsIHwgRWZmZWN0LCByYW46IGJvb2xlYW4sIGRlcHM6ICgpID0+IGFueSB9fSAqL1xuXHR2YXIgdG9rZW4gPSB7IGVmZmVjdDogbnVsbCwgcmFuOiBmYWxzZSwgZGVwcyB9O1xuXG5cdGNvbnRleHQubC4kLnB1c2godG9rZW4pO1xuXG5cdHRva2VuLmVmZmVjdCA9IHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGRlcHMoKTtcblxuXHRcdC8vIElmIHRoaXMgbGVnYWN5IHByZSBlZmZlY3QgaGFzIGFscmVhZHkgcnVuIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSByZXNldCwgdGhlblxuXHRcdC8vIGJhaWwgb3V0IHRvIGVtdWxhdGUgdGhlIHNhbWUgYmVoYXZpb3IuXG5cdFx0aWYgKHRva2VuLnJhbikgcmV0dXJuO1xuXG5cdFx0dG9rZW4ucmFuID0gdHJ1ZTtcblx0XHR1bnRyYWNrKGZuKTtcblx0fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcHJlX2VmZmVjdF9yZXNldCgpIHtcblx0dmFyIGNvbnRleHQgPSAvKiogQHR5cGUge0NvbXBvbmVudENvbnRleHRMZWdhY3l9ICovIChjb21wb25lbnRfY29udGV4dCk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0Ly8gUnVuIGRpcnR5IGAkOmAgc3RhdGVtZW50c1xuXHRcdGZvciAodmFyIHRva2VuIG9mIGNvbnRleHQubC4kKSB7XG5cdFx0XHR0b2tlbi5kZXBzKCk7XG5cblx0XHRcdHZhciBlZmZlY3QgPSB0b2tlbi5lZmZlY3Q7XG5cblx0XHRcdC8vIElmIHRoZSBlZmZlY3QgaXMgQ0xFQU4sIHRoZW4gbWFrZSBpdCBNQVlCRV9ESVJUWS4gVGhpcyBlbnN1cmVzIHdlIHRyYXZlcnNlIHRocm91Z2hcblx0XHRcdC8vIHRoZSBlZmZlY3RzIGRlcGVuZGVuY2llcyBhbmQgY29ycmVjdGx5IGVuc3VyZSBlYWNoIGRlcGVuZGVuY3kgaXMgdXAtdG8tZGF0ZS5cblx0XHRcdGlmICgoZWZmZWN0LmYgJiBDTEVBTikgIT09IDApIHtcblx0XHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc19kaXJ0eShlZmZlY3QpKSB7XG5cdFx0XHRcdHVwZGF0ZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH1cblxuXHRcdFx0dG9rZW4ucmFuID0gZmFsc2U7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWQgfCAoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcmV0dXJucyB7RWZmZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXN5bmNfZWZmZWN0KGZuKSB7XG5cdHJldHVybiBjcmVhdGVfZWZmZWN0KEFTWU5DIHwgRUZGRUNUX1BSRVNFUlZFRCwgZm4sIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEByZXR1cm5zIHtFZmZlY3R9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJfZWZmZWN0KGZuLCBmbGFncyA9IDApIHtcblx0cmV0dXJuIGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCB8IGZsYWdzLCBmbiwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoLi4uZXhwcmVzc2lvbnM6IGFueSkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKX0gZm5cbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gYW55Pn0gc3luY1xuICogQHBhcmFtIHtBcnJheTwoKSA9PiBQcm9taXNlPGFueT4+fSBhc3luY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVfZWZmZWN0KGZuLCBzeW5jID0gW10sIGFzeW5jID0gW10pIHtcblx0ZmxhdHRlbihzeW5jLCBhc3luYywgKHZhbHVlcykgPT4ge1xuXHRcdGNyZWF0ZV9lZmZlY3QoUkVOREVSX0VGRkVDVCwgKCkgPT4gZm4oLi4udmFsdWVzLm1hcChnZXQpKSwgdHJ1ZSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBmblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBibG9jayhmbiwgZmxhZ3MgPSAwKSB7XG5cdHZhciBlZmZlY3QgPSBjcmVhdGVfZWZmZWN0KEJMT0NLX0VGRkVDVCB8IGZsYWdzLCBmbiwgdHJ1ZSk7XG5cdGlmIChERVYpIHtcblx0XHRlZmZlY3QuZGV2X3N0YWNrID0gZGV2X3N0YWNrO1xuXHR9XG5cdHJldHVybiBlZmZlY3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKCkgPT4gdm9pZCl9IGZuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwdXNoXVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoKGZuLCBwdXNoID0gdHJ1ZSkge1xuXHRyZXR1cm4gY3JlYXRlX2VmZmVjdChCUkFOQ0hfRUZGRUNUIHwgRUZGRUNUX1BSRVNFUlZFRCwgZm4sIHRydWUsIHB1c2gpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVfZWZmZWN0X3RlYXJkb3duKGVmZmVjdCkge1xuXHR2YXIgdGVhcmRvd24gPSBlZmZlY3QudGVhcmRvd247XG5cdGlmICh0ZWFyZG93biAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QgPSBpc19kZXN0cm95aW5nX2VmZmVjdDtcblx0XHRjb25zdCBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0XHRzZXRfaXNfZGVzdHJveWluZ19lZmZlY3QodHJ1ZSk7XG5cdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihudWxsKTtcblx0XHR0cnkge1xuXHRcdFx0dGVhcmRvd24uY2FsbChudWxsKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2lzX2Rlc3Ryb3lpbmdfZWZmZWN0KHByZXZpb3VzbHlfZGVzdHJveWluZ19lZmZlY3QpO1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihwcmV2aW91c19yZWFjdGlvbik7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHBhcmFtIHtib29sZWFufSByZW1vdmVfZG9tXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKHNpZ25hbCwgcmVtb3ZlX2RvbSA9IGZhbHNlKSB7XG5cdHZhciBlZmZlY3QgPSBzaWduYWwuZmlyc3Q7XG5cdHNpZ25hbC5maXJzdCA9IHNpZ25hbC5sYXN0ID0gbnVsbDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IGVmZmVjdC5hYztcblxuXHRcdGlmIChjb250cm9sbGVyICE9PSBudWxsKSB7XG5cdFx0XHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmFib3J0KFNUQUxFX1JFQUNUSU9OKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZhciBuZXh0ID0gZWZmZWN0Lm5leHQ7XG5cblx0XHRpZiAoKGVmZmVjdC5mICYgUk9PVF9FRkZFQ1QpICE9PSAwKSB7XG5cdFx0XHQvLyB0aGlzIGlzIG5vdyBhbiBpbmRlcGVuZGVudCByb290XG5cdFx0XHRlZmZlY3QucGFyZW50ID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0LCByZW1vdmVfZG9tKTtcblx0XHR9XG5cblx0XHRlZmZlY3QgPSBuZXh0O1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IHNpZ25hbFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2Jsb2NrX2VmZmVjdF9jaGlsZHJlbihzaWduYWwpIHtcblx0dmFyIGVmZmVjdCA9IHNpZ25hbC5maXJzdDtcblxuXHR3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG5cdFx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblx0XHRpZiAoKGVmZmVjdC5mICYgQlJBTkNIX0VGRkVDVCkgPT09IDApIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0fVxuXHRcdGVmZmVjdCA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVfZG9tXVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95X2VmZmVjdChlZmZlY3QsIHJlbW92ZV9kb20gPSB0cnVlKSB7XG5cdHZhciByZW1vdmVkID0gZmFsc2U7XG5cblx0aWYgKFxuXHRcdChyZW1vdmVfZG9tIHx8IChlZmZlY3QuZiAmIEhFQURfRUZGRUNUKSAhPT0gMCkgJiZcblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgIT09IG51bGwgJiZcblx0XHRlZmZlY3Qubm9kZXNfZW5kICE9PSBudWxsXG5cdCkge1xuXHRcdHJlbW92ZV9lZmZlY3RfZG9tKGVmZmVjdC5ub2Rlc19zdGFydCwgLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChlZmZlY3Qubm9kZXNfZW5kKSk7XG5cdFx0cmVtb3ZlZCA9IHRydWU7XG5cdH1cblxuXHRkZXN0cm95X2VmZmVjdF9jaGlsZHJlbihlZmZlY3QsIHJlbW92ZV9kb20gJiYgIXJlbW92ZWQpO1xuXHRyZW1vdmVfcmVhY3Rpb25zKGVmZmVjdCwgMCk7XG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgREVTVFJPWUVEKTtcblxuXHR2YXIgdHJhbnNpdGlvbnMgPSBlZmZlY3QudHJhbnNpdGlvbnM7XG5cblx0aWYgKHRyYW5zaXRpb25zICE9PSBudWxsKSB7XG5cdFx0Zm9yIChjb25zdCB0cmFuc2l0aW9uIG9mIHRyYW5zaXRpb25zKSB7XG5cdFx0XHR0cmFuc2l0aW9uLnN0b3AoKTtcblx0XHR9XG5cdH1cblxuXHRleGVjdXRlX2VmZmVjdF90ZWFyZG93bihlZmZlY3QpO1xuXG5cdHZhciBwYXJlbnQgPSBlZmZlY3QucGFyZW50O1xuXG5cdC8vIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbiwgdGhlbiBza2lwIHRoaXMgd29yayBhbHRvZ2V0aGVyXG5cdGlmIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmZpcnN0ICE9PSBudWxsKSB7XG5cdFx0dW5saW5rX2VmZmVjdChlZmZlY3QpO1xuXHR9XG5cblx0aWYgKERFVikge1xuXHRcdGVmZmVjdC5jb21wb25lbnRfZnVuY3Rpb24gPSBudWxsO1xuXHR9XG5cblx0Ly8gYGZpcnN0YCBhbmQgYGNoaWxkYCBhcmUgbnVsbGVkIG91dCBpbiBkZXN0cm95X2VmZmVjdF9jaGlsZHJlblxuXHQvLyB3ZSBkb24ndCBudWxsIG91dCBgcGFyZW50YCBzbyB0aGF0IGVycm9yIHByb3BhZ2F0aW9uIGNhbiB3b3JrIGNvcnJlY3RseVxuXHRlZmZlY3QubmV4dCA9XG5cdFx0ZWZmZWN0LnByZXYgPVxuXHRcdGVmZmVjdC50ZWFyZG93biA9XG5cdFx0ZWZmZWN0LmN0eCA9XG5cdFx0ZWZmZWN0LmRlcHMgPVxuXHRcdGVmZmVjdC5mbiA9XG5cdFx0ZWZmZWN0Lm5vZGVzX3N0YXJ0ID1cblx0XHRlZmZlY3Qubm9kZXNfZW5kID1cblx0XHRlZmZlY3QuYWMgPVxuXHRcdFx0bnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGUgfCBudWxsfSBub2RlXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gZW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVfZWZmZWN0X2RvbShub2RlLCBlbmQpIHtcblx0d2hpbGUgKG5vZGUgIT09IG51bGwpIHtcblx0XHQvKiogQHR5cGUge1RlbXBsYXRlTm9kZSB8IG51bGx9ICovXG5cdFx0dmFyIG5leHQgPSBub2RlID09PSBlbmQgPyBudWxsIDogLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKG5vZGUpKTtcblxuXHRcdG5vZGUucmVtb3ZlKCk7XG5cdFx0bm9kZSA9IG5leHQ7XG5cdH1cbn1cblxuLyoqXG4gKiBEZXRhY2ggYW4gZWZmZWN0IGZyb20gdGhlIGVmZmVjdCB0cmVlLCBmcmVlaW5nIHVwIG1lbW9yeSBhbmRcbiAqIHJlZHVjaW5nIHRoZSBhbW91bnQgb2Ygd29yayB0aGF0IGhhcHBlbnMgb24gc3Vic2VxdWVudCB0cmF2ZXJzYWxzXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmxpbmtfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgcGFyZW50ID0gZWZmZWN0LnBhcmVudDtcblx0dmFyIHByZXYgPSBlZmZlY3QucHJldjtcblx0dmFyIG5leHQgPSBlZmZlY3QubmV4dDtcblxuXHRpZiAocHJldiAhPT0gbnVsbCkgcHJldi5uZXh0ID0gbmV4dDtcblx0aWYgKG5leHQgIT09IG51bGwpIG5leHQucHJldiA9IHByZXY7XG5cblx0aWYgKHBhcmVudCAhPT0gbnVsbCkge1xuXHRcdGlmIChwYXJlbnQuZmlyc3QgPT09IGVmZmVjdCkgcGFyZW50LmZpcnN0ID0gbmV4dDtcblx0XHRpZiAocGFyZW50Lmxhc3QgPT09IGVmZmVjdCkgcGFyZW50Lmxhc3QgPSBwcmV2O1xuXHR9XG59XG5cbi8qKlxuICogV2hlbiBhIGJsb2NrIGVmZmVjdCBpcyByZW1vdmVkLCB3ZSBkb24ndCBpbW1lZGlhdGVseSBkZXN0cm95IGl0IG9yIHlhbmsgaXRcbiAqIG91dCBvZiB0aGUgRE9NLCBiZWNhdXNlIGl0IG1pZ2h0IGhhdmUgdHJhbnNpdGlvbnMuIEluc3RlYWQsIHdlICdwYXVzZScgaXQuXG4gKiBJdCBzdGF5cyBhcm91bmQgKGluIG1lbW9yeSwgYW5kIGluIHRoZSBET00pIHVudGlsIG91dHJvIHRyYW5zaXRpb25zIGhhdmVcbiAqIGNvbXBsZXRlZCwgYW5kIGlmIHRoZSBzdGF0ZSBjaGFuZ2UgaXMgcmV2ZXJzZWQgdGhlbiB3ZSBfcmVzdW1lXyBpdC5cbiAqIEEgcGF1c2VkIGVmZmVjdCBkb2VzIG5vdCB1cGRhdGUsIGFuZCB0aGUgRE9NIHN1YnRyZWUgYmVjb21lcyBpbmVydC5cbiAqIEBwYXJhbSB7RWZmZWN0fSBlZmZlY3RcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF1c2VfZWZmZWN0KGVmZmVjdCwgY2FsbGJhY2spIHtcblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblxuXHRwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCB0cnVlKTtcblxuXHRydW5fb3V0X3RyYW5zaXRpb25zKHRyYW5zaXRpb25zLCAoKSA9PiB7XG5cdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNpdGlvbk1hbmFnZXJbXX0gdHJhbnNpdGlvbnNcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsIGZuKSB7XG5cdHZhciByZW1haW5pbmcgPSB0cmFuc2l0aW9ucy5sZW5ndGg7XG5cdGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdFx0dmFyIGNoZWNrID0gKCkgPT4gLS1yZW1haW5pbmcgfHwgZm4oKTtcblx0XHRmb3IgKHZhciB0cmFuc2l0aW9uIG9mIHRyYW5zaXRpb25zKSB7XG5cdFx0XHR0cmFuc2l0aW9uLm91dChjaGVjayk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZuKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge1RyYW5zaXRpb25NYW5hZ2VyW119IHRyYW5zaXRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXVzZV9jaGlsZHJlbihlZmZlY3QsIHRyYW5zaXRpb25zLCBsb2NhbCkge1xuXHRpZiAoKGVmZmVjdC5mICYgSU5FUlQpICE9PSAwKSByZXR1cm47XG5cdGVmZmVjdC5mIF49IElORVJUO1xuXG5cdGlmIChlZmZlY3QudHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgZWZmZWN0LnRyYW5zaXRpb25zKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvbi5pc19nbG9iYWwgfHwgbG9jYWwpIHtcblx0XHRcdFx0dHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0d2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0dmFyIHNpYmxpbmcgPSBjaGlsZC5uZXh0O1xuXHRcdHZhciB0cmFuc3BhcmVudCA9IChjaGlsZC5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCB8fCAoY2hpbGQuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdC8vIFRPRE8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHBhdXNlX2NoaWxkcmVuIHJlY3Vyc2l2ZWx5IHdpdGggYSBsaW5rZWQgbGlzdCBpbiBwbGFjZVxuXHRcdC8vIGl0J3Mgc2xpZ2h0bHkgbW9yZSBpbnZvbHZlZCB0aG91Z2ggYXMgd2UgaGF2ZSB0byBhY2NvdW50IGZvciBgdHJhbnNwYXJlbnRgIGNoYW5naW5nXG5cdFx0Ly8gdGhyb3VnaCB0aGUgdHJlZS5cblx0XHRwYXVzZV9jaGlsZHJlbihjaGlsZCwgdHJhbnNpdGlvbnMsIHRyYW5zcGFyZW50ID8gbG9jYWwgOiBmYWxzZSk7XG5cdFx0Y2hpbGQgPSBzaWJsaW5nO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBwYXVzZV9lZmZlY3RgLiBXZSBjYWxsIHRoaXMgaWYgKGZvciBleGFtcGxlKVxuICogYHhgIGJlY29tZXMgZmFsc3kgdGhlbiB0cnV0aHk6IGB7I2lmIHh9Li4uey9pZn1gXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN1bWVfZWZmZWN0KGVmZmVjdCkge1xuXHRyZXN1bWVfY2hpbGRyZW4oZWZmZWN0LCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZV9jaGlsZHJlbihlZmZlY3QsIGxvY2FsKSB7XG5cdGlmICgoZWZmZWN0LmYgJiBJTkVSVCkgPT09IDApIHJldHVybjtcblx0ZWZmZWN0LmYgXj0gSU5FUlQ7XG5cblx0Ly8gSWYgYSBkZXBlbmRlbmN5IG9mIHRoaXMgZWZmZWN0IGNoYW5nZWQgd2hpbGUgaXQgd2FzIHBhdXNlZCxcblx0Ly8gc2NoZWR1bGUgdGhlIGVmZmVjdCB0byB1cGRhdGUuIHdlIGRvbid0IHVzZSBgaXNfZGlydHlgXG5cdC8vIGhlcmUgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGVhZ2VybHkgcmVjb21wdXRlIGEgZGVyaXZlZCBsaWtlXG5cdC8vIGB7I2lmIGZvb317Zm9vLmJhcigpfXsvaWZ9YCBpZiBgZm9vYCBpcyBub3cgYHVuZGVmaW5lZFxuXHRpZiAoKGVmZmVjdC5mICYgQ0xFQU4pID09PSAwKSB7XG5cdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBESVJUWSk7XG5cdFx0c2NoZWR1bGVfZWZmZWN0KGVmZmVjdCk7XG5cdH1cblxuXHR2YXIgY2hpbGQgPSBlZmZlY3QuZmlyc3Q7XG5cblx0d2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG5cdFx0dmFyIHNpYmxpbmcgPSBjaGlsZC5uZXh0O1xuXHRcdHZhciB0cmFuc3BhcmVudCA9IChjaGlsZC5mICYgRUZGRUNUX1RSQU5TUEFSRU5UKSAhPT0gMCB8fCAoY2hpbGQuZiAmIEJSQU5DSF9FRkZFQ1QpICE9PSAwO1xuXHRcdC8vIFRPRE8gd2UgZG9uJ3QgbmVlZCB0byBjYWxsIHJlc3VtZV9jaGlsZHJlbiByZWN1cnNpdmVseSB3aXRoIGEgbGlua2VkIGxpc3QgaW4gcGxhY2Vcblx0XHQvLyBpdCdzIHNsaWdodGx5IG1vcmUgaW52b2x2ZWQgdGhvdWdoIGFzIHdlIGhhdmUgdG8gYWNjb3VudCBmb3IgYHRyYW5zcGFyZW50YCBjaGFuZ2luZ1xuXHRcdC8vIHRocm91Z2ggdGhlIHRyZWUuXG5cdFx0cmVzdW1lX2NoaWxkcmVuKGNoaWxkLCB0cmFuc3BhcmVudCA/IGxvY2FsIDogZmFsc2UpO1xuXHRcdGNoaWxkID0gc2libGluZztcblx0fVxuXG5cdGlmIChlZmZlY3QudHJhbnNpdGlvbnMgIT09IG51bGwpIHtcblx0XHRmb3IgKGNvbnN0IHRyYW5zaXRpb24gb2YgZWZmZWN0LnRyYW5zaXRpb25zKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvbi5pc19nbG9iYWwgfHwgbG9jYWwpIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5pbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRlZChlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpKSB7XG5cdHJldHVybiAoZWZmZWN0LmYgJiBERVNUUk9ZRUQpICE9PSAwO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgVmFsdWUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgaW50ZXJuYWxfc2V0IH0gZnJvbSAnLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4vcnVudGltZS5qcyc7XG5cbi8qKlxuICogQHR5cGUge1NldDxWYWx1ZT4gfCBudWxsfVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGxldCBjYXB0dXJlZF9zaWduYWxzID0gbnVsbDtcblxuLyoqXG4gKiBDYXB0dXJlIGFuIGFycmF5IG9mIGFsbCB0aGUgc2lnbmFscyB0aGF0IGFyZSByZWFkIHdoZW4gYGZuYCBpcyBjYWxsZWRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVfc2lnbmFscyhmbikge1xuXHR2YXIgcHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscyA9IGNhcHR1cmVkX3NpZ25hbHM7XG5cblx0dHJ5IHtcblx0XHRjYXB0dXJlZF9zaWduYWxzID0gbmV3IFNldCgpO1xuXG5cdFx0dW50cmFjayhmbik7XG5cblx0XHRpZiAocHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscyAhPT0gbnVsbCkge1xuXHRcdFx0Zm9yICh2YXIgc2lnbmFsIG9mIGNhcHR1cmVkX3NpZ25hbHMpIHtcblx0XHRcdFx0cHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscy5hZGQoc2lnbmFsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2FwdHVyZWRfc2lnbmFscztcblx0fSBmaW5hbGx5IHtcblx0XHRjYXB0dXJlZF9zaWduYWxzID0gcHJldmlvdXNfY2FwdHVyZWRfc2lnbmFscztcblx0fVxufVxuXG4vKipcbiAqIEludm9rZXMgYSBmdW5jdGlvbiBhbmQgY2FwdHVyZXMgYWxsIHNpZ25hbHMgdGhhdCBhcmUgcmVhZCBkdXJpbmcgdGhlIGludm9jYXRpb24sXG4gKiB0aGVuIGludmFsaWRhdGVzIHRoZW0uXG4gKiBAcGFyYW0geygpID0+IGFueX0gZm5cbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlX2lubmVyX3NpZ25hbHMoZm4pIHtcblx0Zm9yICh2YXIgc2lnbmFsIG9mIGNhcHR1cmVfc2lnbmFscyhmbikpIHtcblx0XHRpbnRlcm5hbF9zZXQoc2lnbmFsLCBzaWduYWwudik7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IERlcml2ZWQsIEVmZmVjdCwgUmVhY3Rpb24sIFNpZ25hbCwgU291cmNlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGdldF9kZXNjcmlwdG9ycywgZ2V0X3Byb3RvdHlwZV9vZiwgaW5kZXhfb2YgfSBmcm9tICcuLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHtcblx0ZGVzdHJveV9ibG9ja19lZmZlY3RfY2hpbGRyZW4sXG5cdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuLFxuXHRleGVjdXRlX2VmZmVjdF90ZWFyZG93blxufSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQge1xuXHRESVJUWSxcblx0TUFZQkVfRElSVFksXG5cdENMRUFOLFxuXHRERVJJVkVELFxuXHRVTk9XTkVELFxuXHRERVNUUk9ZRUQsXG5cdEJSQU5DSF9FRkZFQ1QsXG5cdFNUQVRFX1NZTUJPTCxcblx0QkxPQ0tfRUZGRUNULFxuXHRST09UX0VGRkVDVCxcblx0RElTQ09OTkVDVEVELFxuXHRSRUFDVElPTl9JU19VUERBVElORyxcblx0U1RBTEVfUkVBQ1RJT04sXG5cdEVSUk9SX1ZBTFVFXG59IGZyb20gJy4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG9sZF92YWx1ZXMgfSBmcm9tICcuL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQge1xuXHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cyxcblx0ZXhlY3V0ZV9kZXJpdmVkLFxuXHRjdXJyZW50X2FzeW5jX2VmZmVjdCxcblx0cmVjZW50X2FzeW5jX2Rlcml2ZWRzLFxuXHR1cGRhdGVfZGVyaXZlZFxufSBmcm9tICcuL3JlYWN0aXZpdHkvZGVyaXZlZHMuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnLCB0cmFjaW5nX21vZGVfZmxhZyB9IGZyb20gJy4uL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IHRyYWNpbmdfZXhwcmVzc2lvbnMsIGdldF9zdGFjayB9IGZyb20gJy4vZGV2L3RyYWNpbmcuanMnO1xuaW1wb3J0IHtcblx0Y29tcG9uZW50X2NvbnRleHQsXG5cdGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbixcblx0ZGV2X3N0YWNrLFxuXHRpc19ydW5lcyxcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0LFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X3N0YWNrXG59IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgQmF0Y2gsIGJhdGNoX2Rlcml2ZWRzLCBmbHVzaFN5bmMsIHNjaGVkdWxlX2VmZmVjdCB9IGZyb20gJy4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQgeyBoYW5kbGVfZXJyb3IgfSBmcm9tICcuL2Vycm9yLWhhbmRsaW5nLmpzJztcbmltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY2FwdHVyZWRfc2lnbmFscyB9IGZyb20gJy4vbGVnYWN5LmpzJztcbmltcG9ydCB7IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCB9IGZyb20gJy4vZG9tL2VsZW1lbnRzL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbmV4cG9ydCBsZXQgaXNfdXBkYXRpbmdfZWZmZWN0ID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2lzX3VwZGF0aW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc191cGRhdGluZ19lZmZlY3QgPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGxldCBpc19kZXN0cm95aW5nX2VmZmVjdCA9IGZhbHNlO1xuXG4vKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9pc19kZXN0cm95aW5nX2VmZmVjdCh2YWx1ZSkge1xuXHRpc19kZXN0cm95aW5nX2VmZmVjdCA9IHZhbHVlO1xufVxuXG4vKiogQHR5cGUge251bGwgfCBSZWFjdGlvbn0gKi9cbmV4cG9ydCBsZXQgYWN0aXZlX3JlYWN0aW9uID0gbnVsbDtcblxuZXhwb3J0IGxldCB1bnRyYWNraW5nID0gZmFsc2U7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBSZWFjdGlvbn0gcmVhY3Rpb24gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYWN0aXZlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdGFjdGl2ZV9yZWFjdGlvbiA9IHJlYWN0aW9uO1xufVxuXG4vKiogQHR5cGUge251bGwgfCBFZmZlY3R9ICovXG5leHBvcnQgbGV0IGFjdGl2ZV9lZmZlY3QgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtudWxsIHwgRWZmZWN0fSBlZmZlY3QgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfYWN0aXZlX2VmZmVjdChlZmZlY3QpIHtcblx0YWN0aXZlX2VmZmVjdCA9IGVmZmVjdDtcbn1cblxuLyoqXG4gKiBXaGVuIHNvdXJjZXMgYXJlIGNyZWF0ZWQgd2l0aGluIGEgcmVhY3Rpb24sIHJlYWRpbmcgYW5kIHdyaXRpbmdcbiAqIHRoZW0gd2l0aGluIHRoYXQgcmVhY3Rpb24gc2hvdWxkIG5vdCBjYXVzZSBhIHJlLXJ1blxuICogQHR5cGUge251bGwgfCBTb3VyY2VbXX1cbiAqL1xuZXhwb3J0IGxldCBjdXJyZW50X3NvdXJjZXMgPSBudWxsO1xuXG4vKiogQHBhcmFtIHtWYWx1ZX0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoX3JlYWN0aW9uX3ZhbHVlKHZhbHVlKSB7XG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gIT09IG51bGwgJiYgKCFhc3luY19tb2RlX2ZsYWcgfHwgKGFjdGl2ZV9yZWFjdGlvbi5mICYgREVSSVZFRCkgIT09IDApKSB7XG5cdFx0aWYgKGN1cnJlbnRfc291cmNlcyA9PT0gbnVsbCkge1xuXHRcdFx0Y3VycmVudF9zb3VyY2VzID0gW3ZhbHVlXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VycmVudF9zb3VyY2VzLnB1c2godmFsdWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIHJlYWN0aW9uIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkLiBJbiBtYW55IGNhc2VzLFxuICogdGhlIGRlcGVuZGVuY2llcyBhcmUgdW5jaGFuZ2VkIGJldHdlZW4gcnVucywgYW5kIHNvIHRoaXMgd2lsbCBiZSBgbnVsbGAgdW5sZXNzXG4gKiBhbmQgdW50aWwgYSBuZXcgZGVwZW5kZW5jeSBpcyBhY2Nlc3NlZCBcdTIwMTQgd2UgdHJhY2sgdGhpcyB2aWEgYHNraXBwZWRfZGVwc2BcbiAqIEB0eXBlIHtudWxsIHwgVmFsdWVbXX1cbiAqL1xubGV0IG5ld19kZXBzID0gbnVsbDtcblxubGV0IHNraXBwZWRfZGVwcyA9IDA7XG5cbi8qKlxuICogVHJhY2tzIHdyaXRlcyB0aGF0IHRoZSBlZmZlY3QgaXQncyBleGVjdXRlZCBpbiBkb2Vzbid0IGxpc3RlbiB0byB5ZXQsXG4gKiBzbyB0aGF0IHRoZSBkZXBlbmRlbmN5IGNhbiBiZSBhZGRlZCB0byB0aGUgZWZmZWN0IGxhdGVyIG9uIGlmIGl0IHRoZW4gcmVhZHMgaXRcbiAqIEB0eXBlIHtudWxsIHwgU291cmNlW119XG4gKi9cbmV4cG9ydCBsZXQgdW50cmFja2VkX3dyaXRlcyA9IG51bGw7XG5cbi8qKiBAcGFyYW0ge251bGwgfCBTb3VyY2VbXX0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdW50cmFja2VkX3dyaXRlcyh2YWx1ZSkge1xuXHR1bnRyYWNrZWRfd3JpdGVzID0gdmFsdWU7XG59XG5cbi8qKlxuICogQHR5cGUge251bWJlcn0gVXNlZCBieSBzb3VyY2VzIGFuZCBkZXJpdmVkcyBmb3IgaGFuZGxpbmcgdXBkYXRlcy5cbiAqIFZlcnNpb24gc3RhcnRzIGZyb20gMSBzbyB0aGF0IHVub3duZWQgZGVyaXZlZHMgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIGEgY3JlYXRlZCBlZmZlY3QgYW5kIGEgcnVuIG9uZSBmb3IgdHJhY2luZ1xuICoqL1xuZXhwb3J0IGxldCB3cml0ZV92ZXJzaW9uID0gMTtcblxuLyoqIEB0eXBlIHtudW1iZXJ9IFVzZWQgdG8gdmVyc2lvbiBlYWNoIHJlYWQgb2YgYSBzb3VyY2Ugb2YgZGVyaXZlZCB0byBhdm9pZCBkdXBsaWNhdGluZyBkZXBlZGVuY2llcyBpbnNpZGUgYSByZWFjdGlvbiAqL1xubGV0IHJlYWRfdmVyc2lvbiA9IDA7XG5cbmV4cG9ydCBsZXQgdXBkYXRlX3ZlcnNpb24gPSByZWFkX3ZlcnNpb247XG5cbi8qKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdXBkYXRlX3ZlcnNpb24odmFsdWUpIHtcblx0dXBkYXRlX3ZlcnNpb24gPSB2YWx1ZTtcbn1cblxuLy8gSWYgd2UgYXJlIHdvcmtpbmcgd2l0aCBhIGdldCgpIGNoYWluIHRoYXQgaGFzIG5vIGFjdGl2ZSBjb250YWluZXIsXG4vLyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcywgd2Ugc2tpcCBhZGRpbmcgdGhlIHJlYWN0aW9uLlxuZXhwb3J0IGxldCBza2lwX3JlYWN0aW9uID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmNyZW1lbnRfd3JpdGVfdmVyc2lvbigpIHtcblx0cmV0dXJuICsrd3JpdGVfdmVyc2lvbjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBkZXJpdmVkIG9yIGVmZmVjdCBpcyBkaXJ0eS5cbiAqIElmIGl0IGlzIE1BWUJFX0RJUlRZLCB3aWxsIHNldCB0aGUgc3RhdHVzIHRvIENMRUFOXG4gKiBAcGFyYW0ge1JlYWN0aW9ufSByZWFjdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kaXJ0eShyZWFjdGlvbikge1xuXHR2YXIgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdGlmICgoZmxhZ3MgJiBESVJUWSkgIT09IDApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICgoZmxhZ3MgJiBNQVlCRV9ESVJUWSkgIT09IDApIHtcblx0XHR2YXIgZGVwZW5kZW5jaWVzID0gcmVhY3Rpb24uZGVwcztcblx0XHR2YXIgaXNfdW5vd25lZCA9IChmbGFncyAmIFVOT1dORUQpICE9PSAwO1xuXG5cdFx0aWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHR2YXIgZGVwZW5kZW5jeTtcblx0XHRcdHZhciBpc19kaXNjb25uZWN0ZWQgPSAoZmxhZ3MgJiBESVNDT05ORUNURUQpICE9PSAwO1xuXHRcdFx0dmFyIGlzX3Vub3duZWRfY29ubmVjdGVkID0gaXNfdW5vd25lZCAmJiBhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICFza2lwX3JlYWN0aW9uO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG5cblx0XHRcdC8vIElmIHdlIGFyZSB3b3JraW5nIHdpdGggYSBkaXNjb25uZWN0ZWQgb3IgYW4gdW5vd25lZCBzaWduYWwgdGhhdCBpcyBub3cgY29ubmVjdGVkIChkdWUgdG8gYW4gYWN0aXZlIGVmZmVjdClcblx0XHRcdC8vIHRoZW4gd2UgbmVlZCB0byByZS1jb25uZWN0IHRoZSByZWFjdGlvbiB0byB0aGUgZGVwZW5kZW5jeSwgdW5sZXNzIHRoZSBlZmZlY3QgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcblx0XHRcdC8vICh3aGljaCBjYW4gaGFwcGVuIGlmIHRoZSBkZXJpdmVkIGlzIHJlYWQgYnkgYW4gYXN5bmMgZGVyaXZlZClcblx0XHRcdGlmIChcblx0XHRcdFx0KGlzX2Rpc2Nvbm5lY3RlZCB8fCBpc191bm93bmVkX2Nvbm5lY3RlZCkgJiZcblx0XHRcdFx0KGFjdGl2ZV9lZmZlY3QgPT09IG51bGwgfHwgKGFjdGl2ZV9lZmZlY3QuZiAmIERFU1RST1lFRCkgPT09IDApXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChyZWFjdGlvbik7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBkZXJpdmVkLnBhcmVudDtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuXG5cdFx0XHRcdFx0Ly8gV2UgYWx3YXlzIHJlLWFkZCBhbGwgcmVhY3Rpb25zIChldmVuIGR1cGxpY2F0ZXMpIGlmIHRoZSBkZXJpdmVkIHdhc1xuXHRcdFx0XHRcdC8vIHByZXZpb3VzbHkgZGlzY29ubmVjdGVkLCBob3dldmVyIHdlIGRvbid0IGlmIGl0IHdhcyB1bm93bmVkIGFzIHdlXG5cdFx0XHRcdFx0Ly8gZGUtZHVwbGljYXRlIGRlcGVuZGVuY2llcyBpbiB0aGF0IGNhc2Vcblx0XHRcdFx0XHRpZiAoaXNfZGlzY29ubmVjdGVkIHx8ICFkZXBlbmRlbmN5Py5yZWFjdGlvbnM/LmluY2x1ZGVzKGRlcml2ZWQpKSB7XG5cdFx0XHRcdFx0XHQoZGVwZW5kZW5jeS5yZWFjdGlvbnMgPz89IFtdKS5wdXNoKGRlcml2ZWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc19kaXNjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRkZXJpdmVkLmYgXj0gRElTQ09OTkVDVEVEO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSB1bm93bmVkIGRlcml2ZWQgaXMgbm93IGZ1bGx5IGNvbm5lY3RlZCB0byB0aGUgZ3JhcGggYWdhaW4gKGl0J3MgdW5vd25lZCBhbmQgcmVjb25uZWN0ZWQsIGhhcyBhIHBhcmVudFxuXHRcdFx0XHQvLyBhbmQgdGhlIHBhcmVudCBpcyBub3QgdW5vd25lZCksIHRoZW4gd2UgY2FuIG1hcmsgaXQgYXMgY29ubmVjdGVkIGFnYWluLCByZW1vdmluZyB0aGUgbmVlZCBmb3IgdGhlIHVub3duZWRcblx0XHRcdFx0Ly8gZmxhZ1xuXHRcdFx0XHRpZiAoaXNfdW5vd25lZF9jb25uZWN0ZWQgJiYgcGFyZW50ICE9PSBudWxsICYmIChwYXJlbnQuZiAmIFVOT1dORUQpID09PSAwKSB7XG5cdFx0XHRcdFx0ZGVyaXZlZC5mIF49IFVOT1dORUQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG5cblx0XHRcdFx0aWYgKGlzX2RpcnR5KC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcGVuZGVuY3kpKSkge1xuXHRcdFx0XHRcdHVwZGF0ZV9kZXJpdmVkKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKGRlcGVuZGVuY3kpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkZXBlbmRlbmN5Lnd2ID4gcmVhY3Rpb24ud3YpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFVub3duZWQgc2lnbmFscyBzaG91bGQgbmV2ZXIgYmUgbWFya2VkIGFzIGNsZWFuIHVubGVzcyB0aGV5XG5cdFx0Ly8gYXJlIHVzZWQgd2l0aGluIGFuIGFjdGl2ZV9lZmZlY3Qgd2l0aG91dCBza2lwX3JlYWN0aW9uXG5cdFx0aWYgKCFpc191bm93bmVkIHx8IChhY3RpdmVfZWZmZWN0ICE9PSBudWxsICYmICFza2lwX3JlYWN0aW9uKSkge1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMocmVhY3Rpb24sIENMRUFOKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtWYWx1ZX0gc2lnbmFsXG4gKiBAcGFyYW0ge0VmZmVjdH0gZWZmZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyb290XVxuICovXG5mdW5jdGlvbiBzY2hlZHVsZV9wb3NzaWJsZV9lZmZlY3Rfc2VsZl9pbnZhbGlkYXRpb24oc2lnbmFsLCBlZmZlY3QsIHJvb3QgPSB0cnVlKSB7XG5cdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXHRpZiAocmVhY3Rpb25zID09PSBudWxsKSByZXR1cm47XG5cblx0aWYgKCFhc3luY19tb2RlX2ZsYWcgJiYgY3VycmVudF9zb3VyY2VzPy5pbmNsdWRlcyhzaWduYWwpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCByZWFjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgcmVhY3Rpb24gPSByZWFjdGlvbnNbaV07XG5cblx0XHRpZiAoKHJlYWN0aW9uLmYgJiBERVJJVkVEKSAhPT0gMCkge1xuXHRcdFx0c2NoZWR1bGVfcG9zc2libGVfZWZmZWN0X3NlbGZfaW52YWxpZGF0aW9uKC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHJlYWN0aW9uKSwgZWZmZWN0LCBmYWxzZSk7XG5cdFx0fSBlbHNlIGlmIChlZmZlY3QgPT09IHJlYWN0aW9uKSB7XG5cdFx0XHRpZiAocm9vdCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgRElSVFkpO1xuXHRcdFx0fSBlbHNlIGlmICgocmVhY3Rpb24uZiAmIENMRUFOKSAhPT0gMCkge1xuXHRcdFx0XHRzZXRfc2lnbmFsX3N0YXR1cyhyZWFjdGlvbiwgTUFZQkVfRElSVFkpO1xuXHRcdFx0fVxuXHRcdFx0c2NoZWR1bGVfZWZmZWN0KC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIEBwYXJhbSB7UmVhY3Rpb259IHJlYWN0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlX3JlYWN0aW9uKHJlYWN0aW9uKSB7XG5cdHZhciBwcmV2aW91c19kZXBzID0gbmV3X2RlcHM7XG5cdHZhciBwcmV2aW91c19za2lwcGVkX2RlcHMgPSBza2lwcGVkX2RlcHM7XG5cdHZhciBwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID0gdW50cmFja2VkX3dyaXRlcztcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfc2tpcF9yZWFjdGlvbiA9IHNraXBfcmVhY3Rpb247XG5cdHZhciBwcmV2aW91c19zb3VyY2VzID0gY3VycmVudF9zb3VyY2VzO1xuXHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0dmFyIHByZXZpb3VzX3VudHJhY2tpbmcgPSB1bnRyYWNraW5nO1xuXHR2YXIgcHJldmlvdXNfdXBkYXRlX3ZlcnNpb24gPSB1cGRhdGVfdmVyc2lvbjtcblxuXHR2YXIgZmxhZ3MgPSByZWFjdGlvbi5mO1xuXG5cdG5ld19kZXBzID0gLyoqIEB0eXBlIHtudWxsIHwgVmFsdWVbXX0gKi8gKG51bGwpO1xuXHRza2lwcGVkX2RlcHMgPSAwO1xuXHR1bnRyYWNrZWRfd3JpdGVzID0gbnVsbDtcblx0c2tpcF9yZWFjdGlvbiA9XG5cdFx0KGZsYWdzICYgVU5PV05FRCkgIT09IDAgJiYgKHVudHJhY2tpbmcgfHwgIWlzX3VwZGF0aW5nX2VmZmVjdCB8fCBhY3RpdmVfcmVhY3Rpb24gPT09IG51bGwpO1xuXHRhY3RpdmVfcmVhY3Rpb24gPSAoZmxhZ3MgJiAoQlJBTkNIX0VGRkVDVCB8IFJPT1RfRUZGRUNUKSkgPT09IDAgPyByZWFjdGlvbiA6IG51bGw7XG5cblx0Y3VycmVudF9zb3VyY2VzID0gbnVsbDtcblx0c2V0X2NvbXBvbmVudF9jb250ZXh0KHJlYWN0aW9uLmN0eCk7XG5cdHVudHJhY2tpbmcgPSBmYWxzZTtcblx0dXBkYXRlX3ZlcnNpb24gPSArK3JlYWRfdmVyc2lvbjtcblxuXHRpZiAocmVhY3Rpb24uYWMgIT09IG51bGwpIHtcblx0XHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdFx0LyoqIEB0eXBlIHtBYm9ydENvbnRyb2xsZXJ9ICovIChyZWFjdGlvbi5hYykuYWJvcnQoU1RBTEVfUkVBQ1RJT04pO1xuXHRcdH0pO1xuXG5cdFx0cmVhY3Rpb24uYWMgPSBudWxsO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRyZWFjdGlvbi5mIHw9IFJFQUNUSU9OX0lTX1VQREFUSU5HO1xuXHRcdHZhciBmbiA9IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChyZWFjdGlvbi5mbik7XG5cdFx0dmFyIHJlc3VsdCA9IGZuKCk7XG5cdFx0dmFyIGRlcHMgPSByZWFjdGlvbi5kZXBzO1xuXG5cdFx0aWYgKG5ld19kZXBzICE9PSBudWxsKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0cmVtb3ZlX3JlYWN0aW9ucyhyZWFjdGlvbiwgc2tpcHBlZF9kZXBzKTtcblxuXHRcdFx0aWYgKGRlcHMgIT09IG51bGwgJiYgc2tpcHBlZF9kZXBzID4gMCkge1xuXHRcdFx0XHRkZXBzLmxlbmd0aCA9IHNraXBwZWRfZGVwcyArIG5ld19kZXBzLmxlbmd0aDtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG5ld19kZXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0ZGVwc1tza2lwcGVkX2RlcHMgKyBpXSA9IG5ld19kZXBzW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZWFjdGlvbi5kZXBzID0gZGVwcyA9IG5ld19kZXBzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFza2lwX3JlYWN0aW9uIHx8XG5cdFx0XHRcdC8vIERlcml2ZWRzIHRoYXQgYWxyZWFkeSBoYXZlIHJlYWN0aW9ucyBjYW4gY2xlYW51cCwgc28gd2Ugc3RpbGwgYWRkIHRoZW0gYXMgcmVhY3Rpb25zXG5cdFx0XHRcdCgoZmxhZ3MgJiBERVJJVkVEKSAhPT0gMCAmJlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcjY2xpZW50JykuRGVyaXZlZH0gKi8gKHJlYWN0aW9uKS5yZWFjdGlvbnMgIT09IG51bGwpXG5cdFx0XHQpIHtcblx0XHRcdFx0Zm9yIChpID0gc2tpcHBlZF9kZXBzOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdChkZXBzW2ldLnJlYWN0aW9ucyA/Pz0gW10pLnB1c2gocmVhY3Rpb24pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkZXBzICE9PSBudWxsICYmIHNraXBwZWRfZGVwcyA8IGRlcHMubGVuZ3RoKSB7XG5cdFx0XHRyZW1vdmVfcmVhY3Rpb25zKHJlYWN0aW9uLCBza2lwcGVkX2RlcHMpO1xuXHRcdFx0ZGVwcy5sZW5ndGggPSBza2lwcGVkX2RlcHM7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgaW5zaWRlIGFuIGVmZmVjdCBhbmQgd2UgaGF2ZSB1bnRyYWNrZWQgd3JpdGVzLCB0aGVuIHdlIG5lZWQgdG9cblx0XHQvLyBlbnN1cmUgdGhhdCBpZiBhbnkgb2YgdGhvc2UgdW50cmFja2VkIHdyaXRlcyByZXN1bHQgaW4gcmUtaW52YWxpZGF0aW9uXG5cdFx0Ly8gb2YgdGhlIGN1cnJlbnQgZWZmZWN0LCB0aGVuIHRoYXQgaGFwcGVucyBhY2NvcmRpbmdseVxuXHRcdGlmIChcblx0XHRcdGlzX3J1bmVzKCkgJiZcblx0XHRcdHVudHJhY2tlZF93cml0ZXMgIT09IG51bGwgJiZcblx0XHRcdCF1bnRyYWNraW5nICYmXG5cdFx0XHRkZXBzICE9PSBudWxsICYmXG5cdFx0XHQocmVhY3Rpb24uZiAmIChERVJJVkVEIHwgTUFZQkVfRElSVFkgfCBESVJUWSkpID09PSAwXG5cdFx0KSB7XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgLyoqIEB0eXBlIHtTb3VyY2VbXX0gKi8gKHVudHJhY2tlZF93cml0ZXMpLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNjaGVkdWxlX3Bvc3NpYmxlX2VmZmVjdF9zZWxmX2ludmFsaWRhdGlvbihcblx0XHRcdFx0XHR1bnRyYWNrZWRfd3JpdGVzW2ldLFxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAocmVhY3Rpb24pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgYXJlIHJldHVybmluZyB0byBhbiBwcmV2aW91cyByZWFjdGlvbiB0aGVuXG5cdFx0Ly8gd2UgbmVlZCB0byBpbmNyZW1lbnQgdGhlIHJlYWQgdmVyc2lvbiB0byBlbnN1cmUgdGhhdFxuXHRcdC8vIGFueSBkZXBlbmRlbmNpZXMgaW4gdGhpcyByZWFjdGlvbiBhcmVuJ3QgbWFya2VkIHdpdGhcblx0XHQvLyB0aGUgc2FtZSB2ZXJzaW9uXG5cdFx0aWYgKHByZXZpb3VzX3JlYWN0aW9uICE9PSBudWxsICYmIHByZXZpb3VzX3JlYWN0aW9uICE9PSByZWFjdGlvbikge1xuXHRcdFx0cmVhZF92ZXJzaW9uKys7XG5cblx0XHRcdGlmICh1bnRyYWNrZWRfd3JpdGVzICE9PSBudWxsKSB7XG5cdFx0XHRcdGlmIChwcmV2aW91c191bnRyYWNrZWRfd3JpdGVzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cHJldmlvdXNfdW50cmFja2VkX3dyaXRlcyA9IHVudHJhY2tlZF93cml0ZXM7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHJldmlvdXNfdW50cmFja2VkX3dyaXRlcy5wdXNoKC4uLi8qKiBAdHlwZSB7U291cmNlW119ICovICh1bnRyYWNrZWRfd3JpdGVzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoKHJlYWN0aW9uLmYgJiBFUlJPUl9WQUxVRSkgIT09IDApIHtcblx0XHRcdHJlYWN0aW9uLmYgXj0gRVJST1JfVkFMVUU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gaGFuZGxlX2Vycm9yKGVycm9yKTtcblx0fSBmaW5hbGx5IHtcblx0XHRyZWFjdGlvbi5mIF49IFJFQUNUSU9OX0lTX1VQREFUSU5HO1xuXHRcdG5ld19kZXBzID0gcHJldmlvdXNfZGVwcztcblx0XHRza2lwcGVkX2RlcHMgPSBwcmV2aW91c19za2lwcGVkX2RlcHM7XG5cdFx0dW50cmFja2VkX3dyaXRlcyA9IHByZXZpb3VzX3VudHJhY2tlZF93cml0ZXM7XG5cdFx0YWN0aXZlX3JlYWN0aW9uID0gcHJldmlvdXNfcmVhY3Rpb247XG5cdFx0c2tpcF9yZWFjdGlvbiA9IHByZXZpb3VzX3NraXBfcmVhY3Rpb247XG5cdFx0Y3VycmVudF9zb3VyY2VzID0gcHJldmlvdXNfc291cmNlcztcblx0XHRzZXRfY29tcG9uZW50X2NvbnRleHQocHJldmlvdXNfY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdHVudHJhY2tpbmcgPSBwcmV2aW91c191bnRyYWNraW5nO1xuXHRcdHVwZGF0ZV92ZXJzaW9uID0gcHJldmlvdXNfdXBkYXRlX3ZlcnNpb247XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWFjdGlvbn0gc2lnbmFsXG4gKiBAcGFyYW0ge1ZhbHVlPFY+fSBkZXBlbmRlbmN5XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlX3JlYWN0aW9uKHNpZ25hbCwgZGVwZW5kZW5jeSkge1xuXHRsZXQgcmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnM7XG5cdGlmIChyZWFjdGlvbnMgIT09IG51bGwpIHtcblx0XHR2YXIgaW5kZXggPSBpbmRleF9vZi5jYWxsKHJlYWN0aW9ucywgc2lnbmFsKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR2YXIgbmV3X2xlbmd0aCA9IHJlYWN0aW9ucy5sZW5ndGggLSAxO1xuXHRcdFx0aWYgKG5ld19sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmVhY3Rpb25zID0gZGVwZW5kZW5jeS5yZWFjdGlvbnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU3dhcCB3aXRoIGxhc3QgZWxlbWVudCBhbmQgdGhlbiByZW1vdmUuXG5cdFx0XHRcdHJlYWN0aW9uc1tpbmRleF0gPSByZWFjdGlvbnNbbmV3X2xlbmd0aF07XG5cdFx0XHRcdHJlYWN0aW9ucy5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBJZiB0aGUgZGVyaXZlZCBoYXMgbm8gcmVhY3Rpb25zLCB0aGVuIHdlIGNhbiBkaXNjb25uZWN0IGl0IGZyb20gdGhlIGdyYXBoLFxuXHQvLyBhbGxvd2luZyBpdCB0byBlaXRoZXIgcmVjb25uZWN0IGluIHRoZSBmdXR1cmUsIG9yIGJlIEdDJ2QgYnkgdGhlIFZNLlxuXHRpZiAoXG5cdFx0cmVhY3Rpb25zID09PSBudWxsICYmXG5cdFx0KGRlcGVuZGVuY3kuZiAmIERFUklWRUQpICE9PSAwICYmXG5cdFx0Ly8gRGVzdHJveWluZyBhIGNoaWxkIGVmZmVjdCB3aGlsZSB1cGRhdGluZyBhIHBhcmVudCBlZmZlY3QgY2FuIGNhdXNlIGEgZGVwZW5kZW5jeSB0byBhcHBlYXJcblx0XHQvLyB0byBiZSB1bnVzZWQsIHdoZW4gaW4gZmFjdCBpdCBpcyB1c2VkIGJ5IHRoZSBjdXJyZW50bHktdXBkYXRpbmcgcGFyZW50LiBDaGVja2luZyBgbmV3X2RlcHNgXG5cdFx0Ly8gYWxsb3dzIHVzIHRvIHNraXAgdGhlIGV4cGVuc2l2ZSB3b3JrIG9mIGRpc2Nvbm5lY3RpbmcgYW5kIGltbWVkaWF0ZWx5IHJlY29ubmVjdGluZyBpdFxuXHRcdChuZXdfZGVwcyA9PT0gbnVsbCB8fCAhbmV3X2RlcHMuaW5jbHVkZXMoZGVwZW5kZW5jeSkpXG5cdCkge1xuXHRcdHNldF9zaWduYWxfc3RhdHVzKGRlcGVuZGVuY3ksIE1BWUJFX0RJUlRZKTtcblx0XHQvLyBJZiB3ZSBhcmUgd29ya2luZyB3aXRoIGEgZGVyaXZlZCB0aGF0IGlzIG93bmVkIGJ5IGFuIGVmZmVjdCwgdGhlbiBtYXJrIGl0IGFzIGJlaW5nXG5cdFx0Ly8gZGlzY29ubmVjdGVkLlxuXHRcdGlmICgoZGVwZW5kZW5jeS5mICYgKFVOT1dORUQgfCBESVNDT05ORUNURUQpKSA9PT0gMCkge1xuXHRcdFx0ZGVwZW5kZW5jeS5mIF49IERJU0NPTk5FQ1RFRDtcblx0XHR9XG5cdFx0Ly8gRGlzY29ubmVjdCBhbnkgcmVhY3Rpb25zIG93bmVkIGJ5IHRoaXMgcmVhY3Rpb25cblx0XHRkZXN0cm95X2Rlcml2ZWRfZWZmZWN0cygvKiogQHR5cGUge0Rlcml2ZWR9ICoqLyAoZGVwZW5kZW5jeSkpO1xuXHRcdHJlbW92ZV9yZWFjdGlvbnMoLyoqIEB0eXBlIHtEZXJpdmVkfSAqKi8gKGRlcGVuZGVuY3kpLCAwKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3Rpb259IHNpZ25hbFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0X2luZGV4XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZV9yZWFjdGlvbnMoc2lnbmFsLCBzdGFydF9pbmRleCkge1xuXHR2YXIgZGVwZW5kZW5jaWVzID0gc2lnbmFsLmRlcHM7XG5cdGlmIChkZXBlbmRlbmNpZXMgPT09IG51bGwpIHJldHVybjtcblxuXHRmb3IgKHZhciBpID0gc3RhcnRfaW5kZXg7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRyZW1vdmVfcmVhY3Rpb24oc2lnbmFsLCBkZXBlbmRlbmNpZXNbaV0pO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFZmZlY3R9IGVmZmVjdFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZWZmZWN0KGVmZmVjdCkge1xuXHR2YXIgZmxhZ3MgPSBlZmZlY3QuZjtcblxuXHRpZiAoKGZsYWdzICYgREVTVFJPWUVEKSAhPT0gMCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHNldF9zaWduYWxfc3RhdHVzKGVmZmVjdCwgQ0xFQU4pO1xuXG5cdHZhciBwcmV2aW91c19lZmZlY3QgPSBhY3RpdmVfZWZmZWN0O1xuXHR2YXIgd2FzX3VwZGF0aW5nX2VmZmVjdCA9IGlzX3VwZGF0aW5nX2VmZmVjdDtcblxuXHRhY3RpdmVfZWZmZWN0ID0gZWZmZWN0O1xuXHRpc191cGRhdGluZ19lZmZlY3QgPSB0cnVlO1xuXG5cdGlmIChERVYpIHtcblx0XHR2YXIgcHJldmlvdXNfY29tcG9uZW50X2ZuID0gZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uO1xuXHRcdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24oZWZmZWN0LmNvbXBvbmVudF9mdW5jdGlvbik7XG5cdFx0dmFyIHByZXZpb3VzX3N0YWNrID0gLyoqIEB0eXBlIHthbnl9ICovIChkZXZfc3RhY2spO1xuXHRcdC8vIG9ubHkgYmxvY2sgZWZmZWN0cyBoYXZlIGEgZGV2IHN0YWNrLCBrZWVwIHRoZSBjdXJyZW50IG9uZSBvdGhlcndpc2Vcblx0XHRzZXRfZGV2X3N0YWNrKGVmZmVjdC5kZXZfc3RhY2sgPz8gZGV2X3N0YWNrKTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKChmbGFncyAmIEJMT0NLX0VGRkVDVCkgIT09IDApIHtcblx0XHRcdGRlc3Ryb3lfYmxvY2tfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0X2NoaWxkcmVuKGVmZmVjdCk7XG5cdFx0fVxuXG5cdFx0ZXhlY3V0ZV9lZmZlY3RfdGVhcmRvd24oZWZmZWN0KTtcblx0XHR2YXIgdGVhcmRvd24gPSB1cGRhdGVfcmVhY3Rpb24oZWZmZWN0KTtcblx0XHRlZmZlY3QudGVhcmRvd24gPSB0eXBlb2YgdGVhcmRvd24gPT09ICdmdW5jdGlvbicgPyB0ZWFyZG93biA6IG51bGw7XG5cdFx0ZWZmZWN0Lnd2ID0gd3JpdGVfdmVyc2lvbjtcblxuXHRcdC8vIEluIERFViwgaW5jcmVtZW50IHZlcnNpb25zIG9mIGFueSBzb3VyY2VzIHRoYXQgd2VyZSB3cml0dGVuIHRvIGR1cmluZyB0aGUgZWZmZWN0LFxuXHRcdC8vIHNvIHRoYXQgdGhleSBhcmUgY29ycmVjdGx5IG1hcmtlZCBhcyBkaXJ0eSB3aGVuIHRoZSBlZmZlY3QgcmUtcnVuc1xuXHRcdGlmIChERVYgJiYgdHJhY2luZ19tb2RlX2ZsYWcgJiYgKGVmZmVjdC5mICYgRElSVFkpICE9PSAwICYmIGVmZmVjdC5kZXBzICE9PSBudWxsKSB7XG5cdFx0XHRmb3IgKHZhciBkZXAgb2YgZWZmZWN0LmRlcHMpIHtcblx0XHRcdFx0aWYgKGRlcC5zZXRfZHVyaW5nX2VmZmVjdCkge1xuXHRcdFx0XHRcdGRlcC53diA9IGluY3JlbWVudF93cml0ZV92ZXJzaW9uKCk7XG5cdFx0XHRcdFx0ZGVwLnNldF9kdXJpbmdfZWZmZWN0ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0gZmluYWxseSB7XG5cdFx0aXNfdXBkYXRpbmdfZWZmZWN0ID0gd2FzX3VwZGF0aW5nX2VmZmVjdDtcblx0XHRhY3RpdmVfZWZmZWN0ID0gcHJldmlvdXNfZWZmZWN0O1xuXG5cdFx0aWYgKERFVikge1xuXHRcdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihwcmV2aW91c19jb21wb25lbnRfZm4pO1xuXHRcdFx0c2V0X2Rldl9zdGFjayhwcmV2aW91c19zdGFjayk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRpY2soKSB7XG5cdGlmIChhc3luY19tb2RlX2ZsYWcpIHtcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKGYpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBmKCkpKTtcblx0fVxuXG5cdGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdC8vIEJ5IGNhbGxpbmcgZmx1c2hTeW5jIHdlIGd1YXJhbnRlZSB0aGF0IGFueSBwZW5kaW5nIHN0YXRlIGNoYW5nZXMgYXJlIGFwcGxpZWQgYWZ0ZXIgb25lIHRpY2suXG5cdC8vIFRPRE8gbG9vayBpbnRvIHdoZXRoZXIgd2UgY2FuIG1ha2UgZmx1c2hpbmcgc3Vic2VxdWVudCB1cGRhdGVzIHN5bmNocm9ub3VzbHkgaW4gdGhlIGZ1dHVyZS5cblx0Zmx1c2hTeW5jKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIGFueSBzdGF0ZSBjaGFuZ2VzLCBhbmQgYXN5bmNocm9ub3VzIHdvcmsgcmVzdWx0aW5nIGZyb20gdGhlbSxcbiAqIGhhdmUgcmVzb2x2ZWQgYW5kIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZFxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKiBAc2luY2UgNS4zNlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dGxlZCgpIHtcblx0cmV0dXJuIEJhdGNoLmVuc3VyZSgpLnNldHRsZWQoKTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtWYWx1ZTxWPn0gc2lnbmFsXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChzaWduYWwpIHtcblx0dmFyIGZsYWdzID0gc2lnbmFsLmY7XG5cdHZhciBpc19kZXJpdmVkID0gKGZsYWdzICYgREVSSVZFRCkgIT09IDA7XG5cblx0Y2FwdHVyZWRfc2lnbmFscz8uYWRkKHNpZ25hbCk7XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGRlcGVuZGVuY3kgb24gdGhlIGN1cnJlbnQgcmVhY3Rpb24gc2lnbmFsLlxuXHRpZiAoYWN0aXZlX3JlYWN0aW9uICE9PSBudWxsICYmICF1bnRyYWNraW5nKSB7XG5cdFx0Ly8gaWYgd2UncmUgaW4gYSBkZXJpdmVkIHRoYXQgaXMgYmVpbmcgcmVhZCBpbnNpZGUgYW4gX2FzeW5jXyBkZXJpdmVkLFxuXHRcdC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgZWZmZWN0IHdhcyBhbHJlYWR5IGRlc3Ryb3llZC4gSW4gdGhpcyBjYXNlLFxuXHRcdC8vIHdlIGRvbid0IGFkZCB0aGUgZGVwZW5kZW5jeSwgYmVjYXVzZSB0aGF0IHdvdWxkIGNyZWF0ZSBhIG1lbW9yeSBsZWFrXG5cdFx0dmFyIGRlc3Ryb3llZCA9IGFjdGl2ZV9lZmZlY3QgIT09IG51bGwgJiYgKGFjdGl2ZV9lZmZlY3QuZiAmIERFU1RST1lFRCkgIT09IDA7XG5cblx0XHRpZiAoIWRlc3Ryb3llZCAmJiAhY3VycmVudF9zb3VyY2VzPy5pbmNsdWRlcyhzaWduYWwpKSB7XG5cdFx0XHR2YXIgZGVwcyA9IGFjdGl2ZV9yZWFjdGlvbi5kZXBzO1xuXG5cdFx0XHRpZiAoKGFjdGl2ZV9yZWFjdGlvbi5mICYgUkVBQ1RJT05fSVNfVVBEQVRJTkcpICE9PSAwKSB7XG5cdFx0XHRcdC8vIHdlJ3JlIGluIHRoZSBlZmZlY3QgaW5pdC91cGRhdGUgY3ljbGVcblx0XHRcdFx0aWYgKHNpZ25hbC5ydiA8IHJlYWRfdmVyc2lvbikge1xuXHRcdFx0XHRcdHNpZ25hbC5ydiA9IHJlYWRfdmVyc2lvbjtcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBzaWduYWwgaXMgYWNjZXNzaW5nIHRoZSBzYW1lIGRlcGVuZGVuY2llcyBpbiB0aGUgc2FtZVxuXHRcdFx0XHRcdC8vIG9yZGVyIGFzIGl0IGRpZCBsYXN0IHRpbWUsIGluY3JlbWVudCBgc2tpcHBlZF9kZXBzYFxuXHRcdFx0XHRcdC8vIHJhdGhlciB0aGFuIHVwZGF0aW5nIGBuZXdfZGVwc2AsIHdoaWNoIGNyZWF0ZXMgR0MgY29zdFxuXHRcdFx0XHRcdGlmIChuZXdfZGVwcyA9PT0gbnVsbCAmJiBkZXBzICE9PSBudWxsICYmIGRlcHNbc2tpcHBlZF9kZXBzXSA9PT0gc2lnbmFsKSB7XG5cdFx0XHRcdFx0XHRza2lwcGVkX2RlcHMrKztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5ld19kZXBzID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRuZXdfZGVwcyA9IFtzaWduYWxdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIXNraXBfcmVhY3Rpb24gfHwgIW5ld19kZXBzLmluY2x1ZGVzKHNpZ25hbCkpIHtcblx0XHRcdFx0XHRcdC8vIE5vcm1hbGx5IHdlIGNhbiBwdXNoIGR1cGxpY2F0ZWQgZGVwZW5kZW5jaWVzIHRvIGBuZXdfZGVwc2AsIGJ1dCBpZiB3ZSdyZSBpbnNpZGVcblx0XHRcdFx0XHRcdC8vIGFuIHVub3duZWQgZGVyaXZlZCBiZWNhdXNlIHNraXBfcmVhY3Rpb24gaXMgdHJ1ZSwgdGhlbiB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0XG5cdFx0XHRcdFx0XHQvLyB3ZSBkb24ndCBoYXZlIGR1cGxpY2F0ZXNcblx0XHRcdFx0XHRcdG5ld19kZXBzLnB1c2goc2lnbmFsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHdlJ3JlIGFkZGluZyBhIGRlcGVuZGVuY3kgb3V0c2lkZSB0aGUgaW5pdC91cGRhdGUgY3ljbGVcblx0XHRcdFx0Ly8gKGkuZS4gYWZ0ZXIgYW4gYGF3YWl0YClcblx0XHRcdFx0KGFjdGl2ZV9yZWFjdGlvbi5kZXBzID8/PSBbXSkucHVzaChzaWduYWwpO1xuXG5cdFx0XHRcdHZhciByZWFjdGlvbnMgPSBzaWduYWwucmVhY3Rpb25zO1xuXG5cdFx0XHRcdGlmIChyZWFjdGlvbnMgPT09IG51bGwpIHtcblx0XHRcdFx0XHRzaWduYWwucmVhY3Rpb25zID0gW2FjdGl2ZV9yZWFjdGlvbl07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIXJlYWN0aW9ucy5pbmNsdWRlcyhhY3RpdmVfcmVhY3Rpb24pKSB7XG5cdFx0XHRcdFx0cmVhY3Rpb25zLnB1c2goYWN0aXZlX3JlYWN0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChcblx0XHRpc19kZXJpdmVkICYmXG5cdFx0LyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKS5kZXBzID09PSBudWxsICYmXG5cdFx0LyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKS5lZmZlY3RzID09PSBudWxsXG5cdCkge1xuXHRcdHZhciBkZXJpdmVkID0gLyoqIEB0eXBlIHtEZXJpdmVkfSAqLyAoc2lnbmFsKTtcblx0XHR2YXIgcGFyZW50ID0gZGVyaXZlZC5wYXJlbnQ7XG5cblx0XHRpZiAocGFyZW50ICE9PSBudWxsICYmIChwYXJlbnQuZiAmIFVOT1dORUQpID09PSAwKSB7XG5cdFx0XHQvLyBJZiB0aGUgZGVyaXZlZCBpcyBvd25lZCBieSBhbm90aGVyIGRlcml2ZWQgdGhlbiBtYXJrIGl0IGFzIHVub3duZWRcblx0XHRcdC8vIGFzIHRoZSBkZXJpdmVkIHZhbHVlIG1pZ2h0IGhhdmUgYmVlbiByZWZlcmVuY2VkIGluIGEgZGlmZmVyZW50IGNvbnRleHRcblx0XHRcdC8vIHNpbmNlIGFuZCB0aHVzIGl0cyBwYXJlbnQgbWlnaHQgbm90IGJlIGl0cyB0cnVlIG93bmVyIGFueW1vcmVcblx0XHRcdGRlcml2ZWQuZiBePSBVTk9XTkVEO1xuXHRcdH1cblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHRpZiAoY3VycmVudF9hc3luY19lZmZlY3QpIHtcblx0XHRcdHZhciB0cmFja2luZyA9IChjdXJyZW50X2FzeW5jX2VmZmVjdC5mICYgUkVBQ1RJT05fSVNfVVBEQVRJTkcpICE9PSAwO1xuXHRcdFx0dmFyIHdhc19yZWFkID0gY3VycmVudF9hc3luY19lZmZlY3QuZGVwcz8uaW5jbHVkZXMoc2lnbmFsKTtcblxuXHRcdFx0aWYgKCF0cmFja2luZyAmJiAhdW50cmFja2luZyAmJiAhd2FzX3JlYWQpIHtcblx0XHRcdFx0dy5hd2FpdF9yZWFjdGl2aXR5X2xvc3MoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChzaWduYWwubGFiZWwpKTtcblxuXHRcdFx0XHR2YXIgdHJhY2UgPSBnZXRfc3RhY2soJ1RyYWNlZEF0Jyk7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdGlmICh0cmFjZSkgY29uc29sZS53YXJuKHRyYWNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZWNlbnRfYXN5bmNfZGVyaXZlZHMuZGVsZXRlKHNpZ25hbCk7XG5cblx0XHRpZiAoXG5cdFx0XHR0cmFjaW5nX21vZGVfZmxhZyAmJlxuXHRcdFx0IXVudHJhY2tpbmcgJiZcblx0XHRcdHRyYWNpbmdfZXhwcmVzc2lvbnMgIT09IG51bGwgJiZcblx0XHRcdGFjdGl2ZV9yZWFjdGlvbiAhPT0gbnVsbCAmJlxuXHRcdFx0dHJhY2luZ19leHByZXNzaW9ucy5yZWFjdGlvbiA9PT0gYWN0aXZlX3JlYWN0aW9uXG5cdFx0KSB7XG5cdFx0XHQvLyBVc2VkIHdoZW4gbWFwcGluZyBzdGF0ZSBiZXR3ZWVuIHNwZWNpYWwgYmxvY2tzIGxpa2UgYGVhY2hgXG5cdFx0XHRpZiAoc2lnbmFsLnRyYWNlKSB7XG5cdFx0XHRcdHNpZ25hbC50cmFjZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHJhY2UgPSBnZXRfc3RhY2soJ1RyYWNlZEF0Jyk7XG5cblx0XHRcdFx0aWYgKHRyYWNlKSB7XG5cdFx0XHRcdFx0dmFyIGVudHJ5ID0gdHJhY2luZ19leHByZXNzaW9ucy5lbnRyaWVzLmdldChzaWduYWwpO1xuXG5cdFx0XHRcdFx0aWYgKGVudHJ5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGVudHJ5ID0geyB0cmFjZXM6IFtdIH07XG5cdFx0XHRcdFx0XHR0cmFjaW5nX2V4cHJlc3Npb25zLmVudHJpZXMuc2V0KHNpZ25hbCwgZW50cnkpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBsYXN0ID0gZW50cnkudHJhY2VzW2VudHJ5LnRyYWNlcy5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdC8vIHRyYWNlcyBjYW4gYmUgZHVwbGljYXRlZCwgZS5nLiBieSBgc25hcHNob3RgIGludm9raW5nIGJvdGhcblx0XHRcdFx0XHQvLyBib3RoIGBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIGFuZCBgZ2V0YCB0cmFwcyBhdCBvbmNlXG5cdFx0XHRcdFx0aWYgKHRyYWNlLnN0YWNrICE9PSBsYXN0Py5zdGFjaykge1xuXHRcdFx0XHRcdFx0ZW50cnkudHJhY2VzLnB1c2godHJhY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChpc19kZXN0cm95aW5nX2VmZmVjdCkge1xuXHRcdGlmIChvbGRfdmFsdWVzLmhhcyhzaWduYWwpKSB7XG5cdFx0XHRyZXR1cm4gb2xkX3ZhbHVlcy5nZXQoc2lnbmFsKTtcblx0XHR9XG5cblx0XHRpZiAoaXNfZGVyaXZlZCkge1xuXHRcdFx0ZGVyaXZlZCA9IC8qKiBAdHlwZSB7RGVyaXZlZH0gKi8gKHNpZ25hbCk7XG5cblx0XHRcdHZhciB2YWx1ZSA9IGRlcml2ZWQudjtcblxuXHRcdFx0Ly8gaWYgdGhlIGRlcml2ZWQgaXMgZGlydHkgYW5kIGhhcyByZWFjdGlvbnMsIG9yIGRlcGVuZHMgb24gdGhlIHZhbHVlcyB0aGF0IGp1c3QgY2hhbmdlZCwgcmUtZXhlY3V0ZVxuXHRcdFx0Ly8gKGEgZGVyaXZlZCBjYW4gYmUgbWF5YmVfZGlydHkgZHVlIHRvIHRoZSBlZmZlY3QgZGVzdHJveSByZW1vdmluZyBpdHMgbGFzdCByZWFjdGlvbilcblx0XHRcdGlmIChcblx0XHRcdFx0KChkZXJpdmVkLmYgJiBDTEVBTikgPT09IDAgJiYgZGVyaXZlZC5yZWFjdGlvbnMgIT09IG51bGwpIHx8XG5cdFx0XHRcdGRlcGVuZHNfb25fb2xkX3ZhbHVlcyhkZXJpdmVkKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHZhbHVlID0gZXhlY3V0ZV9kZXJpdmVkKGRlcml2ZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRfdmFsdWVzLnNldChkZXJpdmVkLCB2YWx1ZSk7XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoaXNfZGVyaXZlZCkge1xuXHRcdGRlcml2ZWQgPSAvKiogQHR5cGUge0Rlcml2ZWR9ICovIChzaWduYWwpO1xuXG5cdFx0aWYgKGJhdGNoX2Rlcml2ZWRzPy5oYXMoZGVyaXZlZCkpIHtcblx0XHRcdHJldHVybiBiYXRjaF9kZXJpdmVkcy5nZXQoZGVyaXZlZCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzX2RpcnR5KGRlcml2ZWQpKSB7XG5cdFx0XHR1cGRhdGVfZGVyaXZlZChkZXJpdmVkKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoKHNpZ25hbC5mICYgRVJST1JfVkFMVUUpICE9PSAwKSB7XG5cdFx0dGhyb3cgc2lnbmFsLnY7XG5cdH1cblxuXHRyZXR1cm4gc2lnbmFsLnY7XG59XG5cbi8qKiBAcGFyYW0ge0Rlcml2ZWR9IGRlcml2ZWQgKi9cbmZ1bmN0aW9uIGRlcGVuZHNfb25fb2xkX3ZhbHVlcyhkZXJpdmVkKSB7XG5cdGlmIChkZXJpdmVkLnYgPT09IFVOSU5JVElBTElaRUQpIHJldHVybiB0cnVlOyAvLyB3ZSBkb24ndCBrbm93LCBzbyBhc3N1bWUgdGhlIHdvcnN0XG5cdGlmIChkZXJpdmVkLmRlcHMgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblxuXHRmb3IgKGNvbnN0IGRlcCBvZiBkZXJpdmVkLmRlcHMpIHtcblx0XHRpZiAob2xkX3ZhbHVlcy5oYXMoZGVwKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKChkZXAuZiAmIERFUklWRUQpICE9PSAwICYmIGRlcGVuZHNfb25fb2xkX3ZhbHVlcygvKiogQHR5cGUge0Rlcml2ZWR9ICovIChkZXApKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIExpa2UgYGdldGAsIGJ1dCBjaGVja3MgZm9yIGB1bmRlZmluZWRgLiBVc2VkIGZvciBgdmFyYCBkZWNsYXJhdGlvbnMgYmVjYXVzZSB0aGV5IGNhbiBiZSBhY2Nlc3NlZCBiZWZvcmUgYmVpbmcgZGVjbGFyZWRcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1ZhbHVlPFY+IHwgdW5kZWZpbmVkfSBzaWduYWxcbiAqIEByZXR1cm5zIHtWIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FmZV9nZXQoc2lnbmFsKSB7XG5cdHJldHVybiBzaWduYWwgJiYgZ2V0KHNpZ25hbCk7XG59XG5cbi8qKlxuICogV2hlbiB1c2VkIGluc2lkZSBhIFtgJGRlcml2ZWRgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGRlcml2ZWQpIG9yIFtgJGVmZmVjdGBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSxcbiAqIGFueSBzdGF0ZSByZWFkIGluc2lkZSBgZm5gIHdpbGwgbm90IGJlIHRyZWF0ZWQgYXMgYSBkZXBlbmRlbmN5LlxuICpcbiAqIGBgYHRzXG4gKiAkZWZmZWN0KCgpID0+IHtcbiAqICAgLy8gdGhpcyB3aWxsIHJ1biB3aGVuIGBkYXRhYCBjaGFuZ2VzLCBidXQgbm90IHdoZW4gYHRpbWVgIGNoYW5nZXNcbiAqICAgc2F2ZShkYXRhLCB7XG4gKiAgICAgdGltZXN0YW1wOiB1bnRyYWNrKCgpID0+IHRpbWUpXG4gKiAgIH0pO1xuICogfSk7XG4gKiBgYGBcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0geygpID0+IFR9IGZuXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVudHJhY2soZm4pIHtcblx0dmFyIHByZXZpb3VzX3VudHJhY2tpbmcgPSB1bnRyYWNraW5nO1xuXHR0cnkge1xuXHRcdHVudHJhY2tpbmcgPSB0cnVlO1xuXHRcdHJldHVybiBmbigpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHVudHJhY2tpbmcgPSBwcmV2aW91c191bnRyYWNraW5nO1xuXHR9XG59XG5cbmNvbnN0IFNUQVRVU19NQVNLID0gfihESVJUWSB8IE1BWUJFX0RJUlRZIHwgQ0xFQU4pO1xuXG4vKipcbiAqIEBwYXJhbSB7U2lnbmFsfSBzaWduYWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGF0dXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NpZ25hbF9zdGF0dXMoc2lnbmFsLCBzdGF0dXMpIHtcblx0c2lnbmFsLmYgPSAoc2lnbmFsLmYgJiBTVEFUVVNfTUFTSykgfCBzdGF0dXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBrZXlzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGNsdWRlX2Zyb21fb2JqZWN0KG9iaiwga2V5cykge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAqL1xuXHR2YXIgcmVzdWx0ID0ge307XG5cblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IG9ialtrZXldO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUG9zc2libHkgdHJhdmVyc2UgYW4gb2JqZWN0IGFuZCByZWFkIGFsbCBpdHMgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkncmUgYWxsIHJlYWN0aXZlIGluIGNhc2UgdGhpcyBpcyBgJHN0YXRlYC5cbiAqIERvZXMgb25seSBjaGVjayBmaXJzdCBsZXZlbCBvZiBhbiBvYmplY3QgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKGhldXJpc3RpYyBzaG91bGQgYmUgZ29vZCBmb3IgOTklIG9mIGFsbCBjYXNlcykuXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkX3N0YXRlKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8ICF2YWx1ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKFNUQVRFX1NZTUJPTCBpbiB2YWx1ZSkge1xuXHRcdGRlZXBfcmVhZCh2YWx1ZSk7XG5cdH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0Zm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRjb25zdCBwcm9wID0gdmFsdWVba2V5XTtcblx0XHRcdGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAmJiBTVEFURV9TWU1CT0wgaW4gcHJvcCkge1xuXHRcdFx0XHRkZWVwX3JlYWQocHJvcCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogRGVlcGx5IHRyYXZlcnNlIGFuIG9iamVjdCBhbmQgcmVhZCBhbGwgaXRzIHByb3BlcnRpZXNcbiAqIHNvIHRoYXQgdGhleSdyZSBhbGwgcmVhY3RpdmUgaW4gY2FzZSB0aGlzIGlzIGAkc3RhdGVgXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U2V0PGFueT59IHZpc2l0ZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcF9yZWFkKHZhbHVlLCB2aXNpdGVkID0gbmV3IFNldCgpKSB7XG5cdGlmIChcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dmFsdWUgIT09IG51bGwgJiZcblx0XHQvLyBXZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlIERPTSBlbGVtZW50c1xuXHRcdCEodmFsdWUgaW5zdGFuY2VvZiBFdmVudFRhcmdldCkgJiZcblx0XHQhdmlzaXRlZC5oYXModmFsdWUpXG5cdCkge1xuXHRcdHZpc2l0ZWQuYWRkKHZhbHVlKTtcblx0XHQvLyBXaGVuIHdvcmtpbmcgd2l0aCBhIHBvc3NpYmxlIFN2ZWx0ZURhdGUsIHRoaXNcblx0XHQvLyB3aWxsIGVuc3VyZSB3ZSBjYXB0dXJlIGNoYW5nZXMgdG8gaXQuXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdFx0dmFsdWUuZ2V0VGltZSgpO1xuXHRcdH1cblx0XHRmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRlZXBfcmVhZCh2YWx1ZVtrZXldLCB2aXNpdGVkKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29uc3QgcHJvdG8gPSBnZXRfcHJvdG90eXBlX29mKHZhbHVlKTtcblx0XHRpZiAoXG5cdFx0XHRwcm90byAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IEFycmF5LnByb3RvdHlwZSAmJlxuXHRcdFx0cHJvdG8gIT09IE1hcC5wcm90b3R5cGUgJiZcblx0XHRcdHByb3RvICE9PSBTZXQucHJvdG90eXBlICYmXG5cdFx0XHRwcm90byAhPT0gRGF0ZS5wcm90b3R5cGVcblx0XHQpIHtcblx0XHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gZ2V0X2Rlc2NyaXB0b3JzKHByb3RvKTtcblx0XHRcdGZvciAobGV0IGtleSBpbiBkZXNjcmlwdG9ycykge1xuXHRcdFx0XHRjb25zdCBnZXQgPSBkZXNjcmlwdG9yc1trZXldLmdldDtcblx0XHRcdFx0aWYgKGdldCkge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRnZXQuY2FsbCh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gY29udGludWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cbiIsICJpbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHksIGlzX2FycmF5IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBGSUxFTkFNRSB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQgfSBmcm9tICcuL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbi8qKiBAdHlwZSB7U2V0PHN0cmluZz59ICovXG5leHBvcnQgY29uc3QgYWxsX3JlZ2lzdGVyZWRfZXZlbnRzID0gbmV3IFNldCgpO1xuXG4vKiogQHR5cGUge1NldDwoZXZlbnRzOiBBcnJheTxzdHJpbmc+KSA9PiB2b2lkPn0gKi9cbmV4cG9ydCBjb25zdCByb290X2V2ZW50X2hhbmRsZXMgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogU1NSIGFkZHMgb25sb2FkIGFuZCBvbmVycm9yIGF0dHJpYnV0ZXMgdG8gY2F0Y2ggdGhvc2UgZXZlbnRzIGJlZm9yZSB0aGUgaHlkcmF0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHRob3NlIGNhc2VzLCByZW1vdmVzIHRoZSBhdHRyaWJ1dGVzIGFuZCByZXBsYXlzIHRoZSBldmVudHMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxheV9ldmVudHMoZG9tKSB7XG5cdGlmICghaHlkcmF0aW5nKSByZXR1cm47XG5cblx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnb25sb2FkJyk7XG5cdGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ29uZXJyb3InKTtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRjb25zdCBldmVudCA9IGRvbS5fX2U7XG5cdGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGRvbS5fX2UgPSB1bmRlZmluZWQ7XG5cdFx0cXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKGRvbS5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0XHRkb20uZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZG9tXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IFtoYW5kbGVyXVxuICogQHBhcmFtIHtBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBvcHRpb25zID0ge30pIHtcblx0LyoqXG5cdCAqIEB0aGlzIHtFdmVudFRhcmdldH1cblx0ICovXG5cdGZ1bmN0aW9uIHRhcmdldF9oYW5kbGVyKC8qKiBAdHlwZSB7RXZlbnR9ICovIGV2ZW50KSB7XG5cdFx0aWYgKCFvcHRpb25zLmNhcHR1cmUpIHtcblx0XHRcdC8vIE9ubHkgY2FsbCBpbiB0aGUgYnViYmxlIHBoYXNlLCBlbHNlIGRlbGVnYXRlZCBldmVudHMgd291bGQgYmUgY2FsbGVkIGJlZm9yZSB0aGUgY2FwdHVyaW5nIGV2ZW50c1xuXHRcdFx0aGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uLmNhbGwoZG9tLCBldmVudCk7XG5cdFx0fVxuXHRcdGlmICghZXZlbnQuY2FuY2VsQnViYmxlKSB7XG5cdFx0XHRyZXR1cm4gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KCgpID0+IHtcblx0XHRcdFx0cmV0dXJuIGhhbmRsZXI/LmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hyb21lIGhhcyBhIGJ1ZyB3aGVyZSBwb2ludGVyIGV2ZW50cyBkb24ndCB3b3JrIHdoZW4gYXR0YWNoZWQgdG8gYSBET00gZWxlbWVudCB0aGF0IGhhcyBiZWVuIGNsb25lZFxuXHQvLyB3aXRoIGNsb25lTm9kZSgpIGFuZCB0aGUgRE9NIGVsZW1lbnQgaXMgZGlzY29ubmVjdGVkIGZyb20gdGhlIGRvY3VtZW50LiBUbyBlbnN1cmUgdGhlIGV2ZW50IHdvcmtzLCB3ZVxuXHQvLyBkZWZlciB0aGUgYXR0YWNobWVudCB0aWxsIGFmdGVyIGl0J3MgYmVlbiBhcHBlbmRlZCB0byB0aGUgZG9jdW1lbnQuIFRPRE86IHJlbW92ZSB0aGlzIG9uY2UgQ2hyb21lIGZpeGVzXG5cdC8vIHRoaXMgYnVnLiBUaGUgc2FtZSBhcHBsaWVzIHRvIHdoZWVsIGV2ZW50cyBhbmQgdG91Y2ggZXZlbnRzLlxuXHRpZiAoXG5cdFx0ZXZlbnRfbmFtZS5zdGFydHNXaXRoKCdwb2ludGVyJykgfHxcblx0XHRldmVudF9uYW1lLnN0YXJ0c1dpdGgoJ3RvdWNoJykgfHxcblx0XHRldmVudF9uYW1lID09PSAnd2hlZWwnXG5cdCkge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgdGFyZ2V0X2hhbmRsZXIsIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50X25hbWUsIHRhcmdldF9oYW5kbGVyLCBvcHRpb25zKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXRfaGFuZGxlcjtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGhhbmRsZXIuIFVzaW5nIHRoaXNcbiAqIHJhdGhlciB0aGFuIGBhZGRFdmVudExpc3RlbmVyYCB3aWxsIHByZXNlcnZlIHRoZSBjb3JyZWN0IG9yZGVyIHJlbGF0aXZlIHRvIGhhbmRsZXJzIGFkZGVkIGRlY2xhcmF0aXZlbHlcbiAqICh3aXRoIGF0dHJpYnV0ZXMgbGlrZSBgb25jbGlja2ApLCB3aGljaCB1c2UgZXZlbnQgZGVsZWdhdGlvbiBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICpcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAqIEBwYXJhbSB7QWRkRXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXVxuICovXG5leHBvcnQgZnVuY3Rpb24gb24oZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG5cdHZhciB0YXJnZXRfaGFuZGxlciA9IGNyZWF0ZV9ldmVudCh0eXBlLCBlbGVtZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IFtoYW5kbGVyXVxuICogQHBhcmFtIHtib29sZWFufSBbY2FwdHVyZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Bhc3NpdmVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50KGV2ZW50X25hbWUsIGRvbSwgaGFuZGxlciwgY2FwdHVyZSwgcGFzc2l2ZSkge1xuXHR2YXIgb3B0aW9ucyA9IHsgY2FwdHVyZSwgcGFzc2l2ZSB9O1xuXHR2YXIgdGFyZ2V0X2hhbmRsZXIgPSBjcmVhdGVfZXZlbnQoZXZlbnRfbmFtZSwgZG9tLCBoYW5kbGVyLCBvcHRpb25zKTtcblxuXHRpZiAoXG5cdFx0ZG9tID09PSBkb2N1bWVudC5ib2R5IHx8XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGRvbSA9PT0gd2luZG93IHx8XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGRvbSA9PT0gZG9jdW1lbnQgfHxcblx0XHQvLyBGaXJlZm94IGhhcyBxdWlya3kgYmVoYXZpb3IsIGl0IGNhbiBoYXBwZW4gdGhhdCB3ZSBzdGlsbCBnZXQgXCJjYW5wbGF5XCIgZXZlbnRzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSByZW1vdmVkXG5cdFx0ZG9tIGluc3RhbmNlb2YgSFRNTE1lZGlhRWxlbWVudFxuXHQpIHtcblx0XHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0XHRkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCB0YXJnZXRfaGFuZGxlciwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGV2ZW50c1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxlZ2F0ZShldmVudHMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhbGxfcmVnaXN0ZXJlZF9ldmVudHMuYWRkKGV2ZW50c1tpXSk7XG5cdH1cblxuXHRmb3IgKHZhciBmbiBvZiByb290X2V2ZW50X2hhbmRsZXMpIHtcblx0XHRmbihldmVudHMpO1xuXHR9XG59XG5cbi8vIHVzZWQgdG8gc3RvcmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudGx5IHByb3BhZ2F0ZWQgZXZlbnRcbi8vIHRvIHByZXZlbnQgZ2FyYmFnZSBjb2xsZWN0aW9uIGJldHdlZW4gbWljcm90YXNrcyBpbiBGaXJlZm94XG4vLyBJZiB0aGUgZXZlbnQgb2JqZWN0IGlzIEdDZWQgdG9vIGVhcmx5LCB0aGUgZXhwYW5kbyBfX3Jvb3QgcHJvcGVydHlcbi8vIHNldCBvbiB0aGUgZXZlbnQgb2JqZWN0IGlzIGxvc3QsIGNhdXNpbmcgdGhlIGV2ZW50IGRlbGVnYXRpb25cbi8vIHRvIHByb2Nlc3MgdGhlIGV2ZW50IHR3aWNlXG5sZXQgbGFzdF9wcm9wYWdhdGVkX2V2ZW50ID0gbnVsbDtcblxuLyoqXG4gKiBAdGhpcyB7RXZlbnRUYXJnZXR9XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24oZXZlbnQpIHtcblx0dmFyIGhhbmRsZXJfZWxlbWVudCA9IHRoaXM7XG5cdHZhciBvd25lcl9kb2N1bWVudCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGhhbmRsZXJfZWxlbWVudCkub3duZXJEb2N1bWVudDtcblx0dmFyIGV2ZW50X25hbWUgPSBldmVudC50eXBlO1xuXHR2YXIgcGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aD8uKCkgfHwgW107XG5cdHZhciBjdXJyZW50X3RhcmdldCA9IC8qKiBAdHlwZSB7bnVsbCB8IEVsZW1lbnR9ICovIChwYXRoWzBdIHx8IGV2ZW50LnRhcmdldCk7XG5cblx0bGFzdF9wcm9wYWdhdGVkX2V2ZW50ID0gZXZlbnQ7XG5cblx0Ly8gY29tcG9zZWRQYXRoIGNvbnRhaW5zIGxpc3Qgb2Ygbm9kZXMgdGhlIGV2ZW50IGhhcyBwcm9wYWdhdGVkIHRocm91Z2guXG5cdC8vIFdlIGNoZWNrIF9fcm9vdCB0byBza2lwIGFsbCBub2RlcyBiZWxvdyBpdCBpbiBjYXNlIHRoaXMgaXMgYVxuXHQvLyBwYXJlbnQgb2YgdGhlIF9fcm9vdCBub2RlLCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSdzIG5lc3RlZFxuXHQvLyBtb3VudGVkIGFwcHMuIEluIHRoaXMgY2FzZSB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgZXZlbnRzIG11bHRpcGxlIHRpbWVzLlxuXHR2YXIgcGF0aF9pZHggPSAwO1xuXG5cdC8vIHRoZSBgbGFzdF9wcm9wYWdhdGVkX2V2ZW50ID09PSBldmVudGAgY2hlY2sgaXMgcmVkdW5kYW50LCBidXRcblx0Ly8gd2l0aG91dCBpdCB0aGUgdmFyaWFibGUgd2lsbCBiZSBEQ0UnZCBhbmQgdGhpbmdzIHdpbGxcblx0Ly8gZmFpbCBteXN0ZXJpb3VzbHkgaW4gRmlyZWZveFxuXHQvLyBAdHMtZXhwZWN0LWVycm9yIGlzIGFkZGVkIGJlbG93XG5cdHZhciBoYW5kbGVkX2F0ID0gbGFzdF9wcm9wYWdhdGVkX2V2ZW50ID09PSBldmVudCAmJiBldmVudC5fX3Jvb3Q7XG5cblx0aWYgKGhhbmRsZWRfYXQpIHtcblx0XHR2YXIgYXRfaWR4ID0gcGF0aC5pbmRleE9mKGhhbmRsZWRfYXQpO1xuXHRcdGlmIChcblx0XHRcdGF0X2lkeCAhPT0gLTEgJiZcblx0XHRcdChoYW5kbGVyX2VsZW1lbnQgPT09IGRvY3VtZW50IHx8IGhhbmRsZXJfZWxlbWVudCA9PT0gLyoqIEB0eXBlIHthbnl9ICovICh3aW5kb3cpKVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhpcyBpcyB0aGUgZmFsbGJhY2sgZG9jdW1lbnQgbGlzdGVuZXIgb3IgYSB3aW5kb3cgbGlzdGVuZXIsIGJ1dCB0aGUgZXZlbnQgd2FzIGFscmVhZHkgaGFuZGxlZFxuXHRcdFx0Ly8gLT4gaWdub3JlLCBidXQgc2V0IGhhbmRsZV9hdCB0byBkb2N1bWVudC93aW5kb3cgc28gdGhhdCB3ZSdyZSByZXNldHRpbmcgdGhlIGV2ZW50XG5cdFx0XHQvLyBjaGFpbiBpbiBjYXNlIHNvbWVvbmUgbWFudWFsbHkgZGlzcGF0Y2hlcyB0aGUgc2FtZSBldmVudCBvYmplY3QgYWdhaW4uXG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRldmVudC5fX3Jvb3QgPSBoYW5kbGVyX2VsZW1lbnQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gV2UncmUgZGVsaWJlcmF0ZWx5IG5vdCBza2lwcGluZyBpZiB0aGUgaW5kZXggaXMgaGlnaGVyLCBiZWNhdXNlXG5cdFx0Ly8gc29tZW9uZSBjb3VsZCBjcmVhdGUgYW4gZXZlbnQgcHJvZ3JhbW1hdGljYWxseSBhbmQgZW1pdCBpdCBtdWx0aXBsZSB0aW1lcyxcblx0XHQvLyBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gaGFuZGxlIHRoZSB3aG9sZSBwcm9wYWdhdGlvbiBjaGFpbiBwcm9wZXJseSBlYWNoIHRpbWUuXG5cdFx0Ly8gKHRoaXMgd2lsbCBvbmx5IGJlIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQgbXVsdGlwbGUgdGltZXMgYW5kXG5cdFx0Ly8gdGhlIGZhbGxiYWNrIGRvY3VtZW50IGxpc3RlbmVyIGlzbid0IHJlYWNoZWQgaW4gYmV0d2VlbiwgYnV0IHRoYXQncyBzdXBlciByYXJlKVxuXHRcdHZhciBoYW5kbGVyX2lkeCA9IHBhdGguaW5kZXhPZihoYW5kbGVyX2VsZW1lbnQpO1xuXHRcdGlmIChoYW5kbGVyX2lkeCA9PT0gLTEpIHtcblx0XHRcdC8vIGhhbmRsZV9pZHggY2FuIHRoZW9yZXRpY2FsbHkgYmUgLTEgKGhhcHBlbmVkIGluIHNvbWUgSlNET00gdGVzdGluZyBzY2VuYXJpb3Mgd2l0aCBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgd2luZG93IG9iamVjdClcblx0XHRcdC8vIHNvIGd1YXJkIGFnYWluc3QgdGhhdCwgdG9vLCBhbmQgYXNzdW1lIHRoYXQgZXZlcnl0aGluZyB3YXMgaGFuZGxlZCBhdCB0aGlzIHBvaW50LlxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChhdF9pZHggPD0gaGFuZGxlcl9pZHgpIHtcblx0XHRcdHBhdGhfaWR4ID0gYXRfaWR4O1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnRfdGFyZ2V0ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAocGF0aFtwYXRoX2lkeF0gfHwgZXZlbnQudGFyZ2V0KTtcblx0Ly8gdGhlcmUgY2FuIG9ubHkgYmUgb25lIGRlbGVnYXRlZCBldmVudCBwZXIgZWxlbWVudCwgYW5kIHdlIGVpdGhlciBhbHJlYWR5IGhhbmRsZWQgdGhlIGN1cnJlbnQgdGFyZ2V0LFxuXHQvLyBvciB0aGlzIGlzIHRoZSB2ZXJ5IGZpcnN0IHRhcmdldCBpbiB0aGUgY2hhaW4gd2hpY2ggaGFzIGEgbm9uLWRlbGVnYXRlZCBsaXN0ZW5lciwgaW4gd2hpY2ggY2FzZSBpdCdzIHNhZmVcblx0Ly8gdG8gaGFuZGxlIGEgcG9zc2libGUgZGVsZWdhdGVkIGV2ZW50IG9uIGl0IGxhdGVyICh0aHJvdWdoIHRoZSByb290IGRlbGVnYXRpb24gbGlzdGVuZXIgZm9yIGV4YW1wbGUpLlxuXHRpZiAoY3VycmVudF90YXJnZXQgPT09IGhhbmRsZXJfZWxlbWVudCkgcmV0dXJuO1xuXG5cdC8vIFByb3h5IGN1cnJlbnRUYXJnZXQgdG8gY29ycmVjdCB0YXJnZXRcblx0ZGVmaW5lX3Byb3BlcnR5KGV2ZW50LCAnY3VycmVudFRhcmdldCcsIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIGN1cnJlbnRfdGFyZ2V0IHx8IG93bmVyX2RvY3VtZW50O1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gVGhpcyBzdGFydGVkIGJlY2F1c2Ugb2YgQ2hyb21pdW0gaXNzdWUgaHR0cHM6Ly9jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmUvNTEyODY5NjgyMzU0NTg1Nixcblx0Ly8gd2hlcmUgcmVtb3ZhbCBvciBtb3Zpbmcgb2Ygb2YgdGhlIERPTSBjYW4gY2F1c2Ugc3luYyBgYmx1cmAgZXZlbnRzIHRvIGZpcmUsIHdoaWNoIGNhbiBjYXVzZSBsb2dpY1xuXHQvLyB0byBydW4gaW5zaWRlIHRoZSBjdXJyZW50IGBhY3RpdmVfcmVhY3Rpb25gLCB3aGljaCBpc24ndCB3aGF0IHdlIHdhbnQgYXQgYWxsLiBIb3dldmVyLCBvbiByZWZsZWN0aW9uLFxuXHQvLyBpdCdzIHByb2JhYmx5IGJlc3QgdGhhdCBhbGwgZXZlbnQgaGFuZGxlZCBieSBTdmVsdGUgaGF2ZSB0aGlzIGJlaGF2aW91ciwgYXMgd2UgZG9uJ3QgcmVhbGx5IHdhbnRcblx0Ly8gYW4gZXZlbnQgaGFuZGxlciB0byBydW4gaW4gdGhlIGNvbnRleHQgb2YgYW5vdGhlciByZWFjdGlvbiBvciBlZmZlY3QuXG5cdHZhciBwcmV2aW91c19yZWFjdGlvbiA9IGFjdGl2ZV9yZWFjdGlvbjtcblx0dmFyIHByZXZpb3VzX2VmZmVjdCA9IGFjdGl2ZV9lZmZlY3Q7XG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXG5cdHRyeSB7XG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3Vua25vd259XG5cdFx0ICovXG5cdFx0dmFyIHRocm93X2Vycm9yO1xuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHt1bmtub3duW119XG5cdFx0ICovXG5cdFx0dmFyIG90aGVyX2Vycm9ycyA9IFtdO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnRfdGFyZ2V0ICE9PSBudWxsKSB7XG5cdFx0XHQvKiogQHR5cGUge251bGwgfCBFbGVtZW50fSAqL1xuXHRcdFx0dmFyIHBhcmVudF9lbGVtZW50ID1cblx0XHRcdFx0Y3VycmVudF90YXJnZXQuYXNzaWduZWRTbG90IHx8XG5cdFx0XHRcdGN1cnJlbnRfdGFyZ2V0LnBhcmVudE5vZGUgfHxcblx0XHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChjdXJyZW50X3RhcmdldCkuaG9zdCB8fFxuXHRcdFx0XHRudWxsO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdHZhciBkZWxlZ2F0ZWQgPSBjdXJyZW50X3RhcmdldFsnX18nICsgZXZlbnRfbmFtZV07XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGRlbGVnYXRlZCAhPSBudWxsICYmXG5cdFx0XHRcdFx0KCEoLyoqIEB0eXBlIHthbnl9ICovIChjdXJyZW50X3RhcmdldCkuZGlzYWJsZWQpIHx8XG5cdFx0XHRcdFx0XHQvLyBET00gY291bGQndmUgYmVlbiB1cGRhdGVkIGFscmVhZHkgYnkgdGhlIHRpbWUgdGhpcyBpcyByZWFjaGVkLCBzbyB3ZSBjaGVjayB0aGlzIGFzIHdlbGxcblx0XHRcdFx0XHRcdC8vIC0+IHRoZSB0YXJnZXQgY291bGQgbm90IGhhdmUgYmVlbiBkaXNhYmxlZCBiZWNhdXNlIGl0IGVtaXRzIHRoZSBldmVudCBpbiB0aGUgZmlyc3QgcGxhY2Vcblx0XHRcdFx0XHRcdGV2ZW50LnRhcmdldCA9PT0gY3VycmVudF90YXJnZXQpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGlmIChpc19hcnJheShkZWxlZ2F0ZWQpKSB7XG5cdFx0XHRcdFx0XHR2YXIgW2ZuLCAuLi5kYXRhXSA9IGRlbGVnYXRlZDtcblx0XHRcdFx0XHRcdGZuLmFwcGx5KGN1cnJlbnRfdGFyZ2V0LCBbZXZlbnQsIC4uLmRhdGFdKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGVsZWdhdGVkLmNhbGwoY3VycmVudF90YXJnZXQsIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGlmICh0aHJvd19lcnJvcikge1xuXHRcdFx0XHRcdG90aGVyX2Vycm9ycy5wdXNoKGVycm9yKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvd19lcnJvciA9IGVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXZlbnQuY2FuY2VsQnViYmxlIHx8IHBhcmVudF9lbGVtZW50ID09PSBoYW5kbGVyX2VsZW1lbnQgfHwgcGFyZW50X2VsZW1lbnQgPT09IG51bGwpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRjdXJyZW50X3RhcmdldCA9IHBhcmVudF9lbGVtZW50O1xuXHRcdH1cblxuXHRcdGlmICh0aHJvd19lcnJvcikge1xuXHRcdFx0Zm9yIChsZXQgZXJyb3Igb2Ygb3RoZXJfZXJyb3JzKSB7XG5cdFx0XHRcdC8vIFRocm93IHRoZSByZXN0IG9mIHRoZSBlcnJvcnMsIG9uZS1ieS1vbmUgb24gYSBtaWNyb3Rhc2tcblx0XHRcdFx0cXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHRocm93IHRocm93X2Vycm9yO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIGlzIHVzZWQgYWJvdmVcblx0XHRldmVudC5fX3Jvb3QgPSBoYW5kbGVyX2VsZW1lbnQ7XG5cdFx0Ly8gQHRzLWlnbm9yZSByZW1vdmUgcHJveHkgb24gY3VycmVudFRhcmdldFxuXHRcdGRlbGV0ZSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXHRcdHNldF9hY3RpdmVfcmVhY3Rpb24ocHJldmlvdXNfcmVhY3Rpb24pO1xuXHRcdHNldF9hY3RpdmVfZWZmZWN0KHByZXZpb3VzX2VmZmVjdCk7XG5cdH1cbn1cblxuLyoqXG4gKiBJbiBkZXYsIHdhcm4gaWYgYW4gZXZlbnQgaGFuZGxlciBpcyBub3QgYSBmdW5jdGlvbiwgYXMgaXQgbWVhbnMgdGhlXG4gKiB1c2VyIHByb2JhYmx5IGNhbGxlZCB0aGUgaGFuZGxlciBvciBmb3Jnb3QgdG8gYWRkIGEgYCgpID0+YFxuICogQHBhcmFtIHsoKSA9PiAoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBhbnkpID0+IHZvaWR9IHRodW5rXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbGVtZW50XG4gKiBAcGFyYW0ge1tFdmVudCwgLi4uYW55XX0gYXJnc1xuICogQHBhcmFtIHthbnl9IGNvbXBvbmVudFxuICogQHBhcmFtIHtbbnVtYmVyLCBudW1iZXJdfSBbbG9jXVxuICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlX3BhcmVuc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5KFxuXHR0aHVuayxcblx0ZWxlbWVudCxcblx0YXJncyxcblx0Y29tcG9uZW50LFxuXHRsb2MsXG5cdGhhc19zaWRlX2VmZmVjdHMgPSBmYWxzZSxcblx0cmVtb3ZlX3BhcmVucyA9IGZhbHNlXG4pIHtcblx0bGV0IGhhbmRsZXI7XG5cdGxldCBlcnJvcjtcblxuXHR0cnkge1xuXHRcdGhhbmRsZXIgPSB0aHVuaygpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0ZXJyb3IgPSBlO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nICYmIChoYXNfc2lkZV9lZmZlY3RzIHx8IGhhbmRsZXIgIT0gbnVsbCB8fCBlcnJvcikpIHtcblx0XHRjb25zdCBmaWxlbmFtZSA9IGNvbXBvbmVudD8uW0ZJTEVOQU1FXTtcblx0XHRjb25zdCBsb2NhdGlvbiA9IGxvYyA/IGAgYXQgJHtmaWxlbmFtZX06JHtsb2NbMF19OiR7bG9jWzFdfWAgOiBgIGluICR7ZmlsZW5hbWV9YDtcblx0XHRjb25zdCBwaGFzZSA9IGFyZ3NbMF0/LmV2ZW50UGhhc2UgPCBFdmVudC5CVUJCTElOR19QSEFTRSA/ICdjYXB0dXJlJyA6ICcnO1xuXHRcdGNvbnN0IGV2ZW50X25hbWUgPSBhcmdzWzBdPy50eXBlICsgcGhhc2U7XG5cdFx0Y29uc3QgZGVzY3JpcHRpb24gPSBgXFxgJHtldmVudF9uYW1lfVxcYCBoYW5kbGVyJHtsb2NhdGlvbn1gO1xuXHRcdGNvbnN0IHN1Z2dlc3Rpb24gPSByZW1vdmVfcGFyZW5zID8gJ3JlbW92ZSB0aGUgdHJhaWxpbmcgYCgpYCcgOiAnYWRkIGEgbGVhZGluZyBgKCkgPT5gJztcblxuXHRcdHcuZXZlbnRfaGFuZGxlcl9pbnZhbGlkKGRlc2NyaXB0aW9uLCBzdWdnZXN0aW9uKTtcblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdGhhbmRsZXI/LmFwcGx5KGVsZW1lbnQsIGFyZ3MpO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlLCBzZXRfaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV90ZXh0LCBnZXRfZmlyc3RfY2hpbGQsIGdldF9uZXh0X3NpYmxpbmcgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGJsb2NrIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IENPTU1FTlRfTk9ERSwgSEVBRF9FRkZFQ1QgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBIWURSQVRJT05fU1RBUlQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIEB0eXBlIHtOb2RlIHwgdW5kZWZpbmVkfVxuICovXG5sZXQgaGVhZF9hbmNob3I7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldF9oZWFkX2FuY2hvcigpIHtcblx0aGVhZF9hbmNob3IgPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlKSA9PiB2b2lkfSByZW5kZXJfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVhZChyZW5kZXJfZm4pIHtcblx0Ly8gVGhlIGhlYWQgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciB0aGUgZmlyc3QgaHlkcmF0aW9uIHBhc3MgYW5kIHNzciBjb21tZW50IG5vZGVzIG1heSBzdGlsbCBiZSBwcmVzZW50LFxuXHQvLyB0aGVyZWZvcmUgd2UgbmVlZCB0byBza2lwIHRoYXQgd2hlbiB3ZSBkZXRlY3QgdGhhdCB3ZSdyZSBub3QgaW4gaHlkcmF0aW9uIG1vZGUuXG5cdGxldCBwcmV2aW91c19oeWRyYXRlX25vZGUgPSBudWxsO1xuXHRsZXQgd2FzX2h5ZHJhdGluZyA9IGh5ZHJhdGluZztcblxuXHQvKiogQHR5cGUge0NvbW1lbnQgfCBUZXh0fSAqL1xuXHR2YXIgYW5jaG9yO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRwcmV2aW91c19oeWRyYXRlX25vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0XHQvLyBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSBoZWFkIGJsb2NrcyBpbiBvdXIgYXBwLCBzbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGVhY2ggb25lIG5lZWRpbmcgaW5kZXBlbmRlbnQgaHlkcmF0aW9uLlxuXHRcdGlmIChoZWFkX2FuY2hvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRoZWFkX2FuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGRvY3VtZW50LmhlYWQpKTtcblx0XHR9XG5cblx0XHR3aGlsZSAoXG5cdFx0XHRoZWFkX2FuY2hvciAhPT0gbnVsbCAmJlxuXHRcdFx0KGhlYWRfYW5jaG9yLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHxcblx0XHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaGVhZF9hbmNob3IpLmRhdGEgIT09IEhZRFJBVElPTl9TVEFSVClcblx0XHQpIHtcblx0XHRcdGhlYWRfYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfbmV4dF9zaWJsaW5nKGhlYWRfYW5jaG9yKSk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgY2FuJ3QgZmluZCBhbiBvcGVuaW5nIGh5ZHJhdGlvbiBtYXJrZXIsIHNraXAgaHlkcmF0aW9uICh0aGlzIGNhbiBoYXBwZW5cblx0XHQvLyBpZiBhIGZyYW1ld29yayByZW5kZXJlZCBib2R5IGJ1dCBub3QgaGVhZCBjb250ZW50KVxuXHRcdGlmIChoZWFkX2FuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhlYWRfYW5jaG9yID0gc2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoaGVhZF9hbmNob3IpKSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRibG9jaygoKSA9PiByZW5kZXJfZm4oYW5jaG9yKSwgSEVBRF9FRkZFQ1QpO1xuXHR9IGZpbmFsbHkge1xuXHRcdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdFx0aGVhZF9hbmNob3IgPSBoeWRyYXRlX25vZGU7IC8vIHNvIHRoYXQgbmV4dCBoZWFkIGJsb2NrIHN0YXJ0cyBmcm9tIHRoZSBjb3JyZWN0IG5vZGVcblx0XHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChwcmV2aW91c19oeWRyYXRlX25vZGUpKTtcblx0XHR9XG5cdH1cbn1cbiIsICIvKiogQHBhcmFtIHtzdHJpbmd9IGh0bWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKGh0bWwpIHtcblx0dmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXHRlbGVtLmlubmVySFRNTCA9IGh0bWwucmVwbGFjZUFsbCgnPCE+JywgJzwhLS0tLT4nKTsgLy8gWEhUTUwgY29tcGxpYW5jZVxuXHRyZXR1cm4gZWxlbS5jb250ZW50O1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZVN0cnVjdHVyZSB9IGZyb20gJy4vdHlwZXMnICovXG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHtcblx0Y3JlYXRlX3RleHQsXG5cdGdldF9maXJzdF9jaGlsZCxcblx0aXNfZmlyZWZveCxcblx0Y3JlYXRlX2VsZW1lbnQsXG5cdGNyZWF0ZV9mcmFnbWVudCxcblx0Y3JlYXRlX2NvbW1lbnQsXG5cdHNldF9hdHRyaWJ1dGVcbn0gZnJvbSAnLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuL3JlY29uY2lsZXIuanMnO1xuaW1wb3J0IHsgYWN0aXZlX2VmZmVjdCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHtcblx0TkFNRVNQQUNFX01BVEhNTCxcblx0TkFNRVNQQUNFX1NWRyxcblx0VEVNUExBVEVfRlJBR01FTlQsXG5cdFRFTVBMQVRFX1VTRV9JTVBPUlRfTk9ERSxcblx0VEVNUExBVEVfVVNFX01BVEhNTCxcblx0VEVNUExBVEVfVVNFX1NWR1xufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFLCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFLCBURVhUX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IHN0YXJ0XG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZSB8IG51bGx9IGVuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpIHtcblx0dmFyIGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cdGlmIChlZmZlY3Qubm9kZXNfc3RhcnQgPT09IG51bGwpIHtcblx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBzdGFydDtcblx0XHRlZmZlY3Qubm9kZXNfZW5kID0gZW5kO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHJldHVybnMgeygpID0+IE5vZGUgfCBOb2RlW119XG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21faHRtbChjb250ZW50LCBmbGFncykge1xuXHR2YXIgaXNfZnJhZ21lbnQgPSAoZmxhZ3MgJiBURU1QTEFURV9GUkFHTUVOVCkgIT09IDA7XG5cdHZhciB1c2VfaW1wb3J0X25vZGUgPSAoZmxhZ3MgJiBURU1QTEFURV9VU0VfSU1QT1JUX05PREUpICE9PSAwO1xuXG5cdC8qKiBAdHlwZSB7Tm9kZX0gKi9cblx0dmFyIG5vZGU7XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgb3Igbm90IHRoZSBmaXJzdCBpdGVtIGlzIGEgdGV4dC9lbGVtZW50IG5vZGUuIElmIG5vdCwgd2UgbmVlZCB0b1xuXHQgKiBjcmVhdGUgYW4gYWRkaXRpb25hbCBjb21tZW50IG5vZGUgdG8gYWN0IGFzIGBlZmZlY3Qubm9kZXMuc3RhcnRgXG5cdCAqL1xuXHR2YXIgaGFzX3N0YXJ0ID0gIWNvbnRlbnQuc3RhcnRzV2l0aCgnPCE+Jyk7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bm9kZSA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaGFzX3N0YXJ0ID8gY29udGVudCA6ICc8IT4nICsgY29udGVudCk7XG5cdFx0XHRpZiAoIWlzX2ZyYWdtZW50KSBub2RlID0gLyoqIEB0eXBlIHtOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKG5vZGUpKTtcblx0XHR9XG5cblx0XHR2YXIgY2xvbmUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKFxuXHRcdFx0dXNlX2ltcG9ydF9ub2RlIHx8IGlzX2ZpcmVmb3ggPyBkb2N1bWVudC5pbXBvcnROb2RlKG5vZGUsIHRydWUpIDogbm9kZS5jbG9uZU5vZGUodHJ1ZSlcblx0XHQpO1xuXG5cdFx0aWYgKGlzX2ZyYWdtZW50KSB7XG5cdFx0XHR2YXIgc3RhcnQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChjbG9uZSkpO1xuXHRcdFx0dmFyIGVuZCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoY2xvbmUubGFzdENoaWxkKTtcblxuXHRcdFx0YXNzaWduX25vZGVzKHN0YXJ0LCBlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoY2xvbmUsIGNsb25lKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHsnc3ZnJyB8ICdtYXRoJ30gbnNcbiAqIEByZXR1cm5zIHsoKSA9PiBOb2RlIHwgTm9kZVtdfVxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIGZyb21fbmFtZXNwYWNlKGNvbnRlbnQsIGZsYWdzLCBucyA9ICdzdmcnKSB7XG5cdC8qKlxuXHQgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZmlyc3QgaXRlbSBpcyBhIHRleHQvZWxlbWVudCBub2RlLiBJZiBub3QsIHdlIG5lZWQgdG9cblx0ICogY3JlYXRlIGFuIGFkZGl0aW9uYWwgY29tbWVudCBub2RlIHRvIGFjdCBhcyBgZWZmZWN0Lm5vZGVzLnN0YXJ0YFxuXHQgKi9cblx0dmFyIGhhc19zdGFydCA9ICFjb250ZW50LnN0YXJ0c1dpdGgoJzwhPicpO1xuXG5cdHZhciBpc19mcmFnbWVudCA9IChmbGFncyAmIFRFTVBMQVRFX0ZSQUdNRU5UKSAhPT0gMDtcblx0dmFyIHdyYXBwZWQgPSBgPCR7bnN9PiR7aGFzX3N0YXJ0ID8gY29udGVudCA6ICc8IT4nICsgY29udGVudH08LyR7bnN9PmA7XG5cblx0LyoqIEB0eXBlIHtFbGVtZW50IHwgRG9jdW1lbnRGcmFnbWVudH0gKi9cblx0dmFyIG5vZGU7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBudWxsKTtcblx0XHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdFx0fVxuXG5cdFx0aWYgKCFub2RlKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnQgPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovIChjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sKHdyYXBwZWQpKTtcblx0XHRcdHZhciByb290ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGZyYWdtZW50KSk7XG5cblx0XHRcdGlmIChpc19mcmFnbWVudCkge1xuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR3aGlsZSAoZ2V0X2ZpcnN0X2NoaWxkKHJvb3QpKSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZCgvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQocm9vdCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChyb290KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNsb25lID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChub2RlLmNsb25lTm9kZSh0cnVlKSk7XG5cblx0XHRpZiAoaXNfZnJhZ21lbnQpIHtcblx0XHRcdHZhciBzdGFydCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKGNsb25lKSk7XG5cdFx0XHR2YXIgZW5kID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjbG9uZS5sYXN0Q2hpbGQpO1xuXG5cdFx0XHRhc3NpZ25fbm9kZXMoc3RhcnQsIGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFzc2lnbl9ub2RlcyhjbG9uZSwgY2xvbmUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjbG9uZTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21fc3ZnKGNvbnRlbnQsIGZsYWdzKSB7XG5cdHJldHVybiBmcm9tX25hbWVzcGFjZShjb250ZW50LCBmbGFncywgJ3N2ZycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZnJvbV9tYXRobWwoY29udGVudCwgZmxhZ3MpIHtcblx0cmV0dXJuIGZyb21fbmFtZXNwYWNlKGNvbnRlbnQsIGZsYWdzLCAnbWF0aCcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGVtcGxhdGVTdHJ1Y3R1cmVbXX0gc3RydWN0dXJlXG4gKiBAcGFyYW0ge3R5cGVvZiBOQU1FU1BBQ0VfU1ZHIHwgdHlwZW9mIE5BTUVTUEFDRV9NQVRITUwgfCB1bmRlZmluZWR9IFtuc11cbiAqL1xuZnVuY3Rpb24gZnJhZ21lbnRfZnJvbV90cmVlKHN0cnVjdHVyZSwgbnMpIHtcblx0dmFyIGZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50KCk7XG5cblx0Zm9yICh2YXIgaXRlbSBvZiBzdHJ1Y3R1cmUpIHtcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRmcmFnbWVudC5hcHBlbmQoY3JlYXRlX3RleHQoaXRlbSkpO1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgYHByZXNlcnZlQ29tbWVudHMgPT09IHRydWVgLCBjb21tZW50cyBhcmUgcmVwcmVzZW50ZWQgYXMgYFsnLy8gPGRhdGE+J11gXG5cdFx0aWYgKGl0ZW0gPT09IHVuZGVmaW5lZCB8fCBpdGVtWzBdWzBdID09PSAnLycpIHtcblx0XHRcdGZyYWdtZW50LmFwcGVuZChjcmVhdGVfY29tbWVudChpdGVtID8gaXRlbVswXS5zbGljZSgzKSA6ICcnKSk7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb25zdCBbbmFtZSwgYXR0cmlidXRlcywgLi4uY2hpbGRyZW5dID0gaXRlbTtcblxuXHRcdGNvbnN0IG5hbWVzcGFjZSA9IG5hbWUgPT09ICdzdmcnID8gTkFNRVNQQUNFX1NWRyA6IG5hbWUgPT09ICdtYXRoJyA/IE5BTUVTUEFDRV9NQVRITUwgOiBucztcblxuXHRcdHZhciBlbGVtZW50ID0gY3JlYXRlX2VsZW1lbnQobmFtZSwgbmFtZXNwYWNlLCBhdHRyaWJ1dGVzPy5pcyk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShlbGVtZW50LCBrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciB0YXJnZXQgPVxuXHRcdFx0XHRlbGVtZW50LnRhZ05hbWUgPT09ICdURU1QTEFURSdcblx0XHRcdFx0XHQ/IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKGVsZW1lbnQpLmNvbnRlbnRcblx0XHRcdFx0XHQ6IGVsZW1lbnQ7XG5cblx0XHRcdHRhcmdldC5hcHBlbmQoXG5cdFx0XHRcdGZyYWdtZW50X2Zyb21fdHJlZShjaGlsZHJlbiwgZWxlbWVudC50YWdOYW1lID09PSAnZm9yZWlnbk9iamVjdCcgPyB1bmRlZmluZWQgOiBuYW1lc3BhY2UpXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGZyYWdtZW50LmFwcGVuZChlbGVtZW50KTtcblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RlbXBsYXRlU3RydWN0dXJlW119IHN0cnVjdHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcmV0dXJucyB7KCkgPT4gTm9kZSB8IE5vZGVbXX1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gZnJvbV90cmVlKHN0cnVjdHVyZSwgZmxhZ3MpIHtcblx0dmFyIGlzX2ZyYWdtZW50ID0gKGZsYWdzICYgVEVNUExBVEVfRlJBR01FTlQpICE9PSAwO1xuXHR2YXIgdXNlX2ltcG9ydF9ub2RlID0gKGZsYWdzICYgVEVNUExBVEVfVVNFX0lNUE9SVF9OT0RFKSAhPT0gMDtcblxuXHQvKiogQHR5cGUge05vZGV9ICovXG5cdHZhciBub2RlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0YXNzaWduX25vZGVzKGh5ZHJhdGVfbm9kZSwgbnVsbCk7XG5cdFx0XHRyZXR1cm4gaHlkcmF0ZV9ub2RlO1xuXHRcdH1cblxuXHRcdGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbnN0IG5zID1cblx0XHRcdFx0KGZsYWdzICYgVEVNUExBVEVfVVNFX1NWRykgIT09IDBcblx0XHRcdFx0XHQ/IE5BTUVTUEFDRV9TVkdcblx0XHRcdFx0XHQ6IChmbGFncyAmIFRFTVBMQVRFX1VTRV9NQVRITUwpICE9PSAwXG5cdFx0XHRcdFx0XHQ/IE5BTUVTUEFDRV9NQVRITUxcblx0XHRcdFx0XHRcdDogdW5kZWZpbmVkO1xuXG5cdFx0XHRub2RlID0gZnJhZ21lbnRfZnJvbV90cmVlKHN0cnVjdHVyZSwgbnMpO1xuXHRcdFx0aWYgKCFpc19mcmFnbWVudCkgbm9kZSA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSk7XG5cdFx0fVxuXG5cdFx0dmFyIGNsb25lID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChcblx0XHRcdHVzZV9pbXBvcnRfbm9kZSB8fCBpc19maXJlZm94ID8gZG9jdW1lbnQuaW1wb3J0Tm9kZShub2RlLCB0cnVlKSA6IG5vZGUuY2xvbmVOb2RlKHRydWUpXG5cdFx0KTtcblxuXHRcdGlmIChpc19mcmFnbWVudCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQoY2xvbmUpKTtcblx0XHRcdHZhciBlbmQgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGNsb25lLmxhc3RDaGlsZCk7XG5cblx0XHRcdGFzc2lnbl9ub2RlcyhzdGFydCwgZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXNzaWduX25vZGVzKGNsb25lLCBjbG9uZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gRWxlbWVudCB8IERvY3VtZW50RnJhZ21lbnR9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoX3NjcmlwdChmbikge1xuXHRyZXR1cm4gKCkgPT4gcnVuX3NjcmlwdHMoZm4oKSk7XG59XG5cbi8qKlxuICogQ3JlYXRpbmcgYSBkb2N1bWVudCBmcmFnbWVudCBmcm9tIEhUTUwgdGhhdCBjb250YWlucyBzY3JpcHQgdGFncyB3aWxsIG5vdCBleGVjdXRlXG4gKiB0aGUgc2NyaXB0cy4gV2UgbmVlZCB0byByZXBsYWNlIHRoZSBzY3JpcHQgdGFncyB3aXRoIG5ldyBvbmVzIHNvIHRoYXQgdGhleSBhcmUgZXhlY3V0ZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCBEb2N1bWVudEZyYWdtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7Tm9kZSB8IE5vZGVbXX1cbiAqL1xuZnVuY3Rpb24gcnVuX3NjcmlwdHMobm9kZSkge1xuXHQvLyBzY3JpcHRzIHdlcmUgU1NSJ2QsIGluIHdoaWNoIGNhc2UgdGhleSB3aWxsIHJ1blxuXHRpZiAoaHlkcmF0aW5nKSByZXR1cm4gbm9kZTtcblxuXHRjb25zdCBpc19mcmFnbWVudCA9IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG5cdGNvbnN0IHNjcmlwdHMgPVxuXHRcdC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKS50YWdOYW1lID09PSAnU0NSSVBUJ1xuXHRcdFx0PyBbLyoqIEB0eXBlIHtIVE1MU2NyaXB0RWxlbWVudH0gKi8gKG5vZGUpXVxuXHRcdFx0OiBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpO1xuXHRjb25zdCBlZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdGZvciAoY29uc3Qgc2NyaXB0IG9mIHNjcmlwdHMpIHtcblx0XHRjb25zdCBjbG9uZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdGZvciAodmFyIGF0dHJpYnV0ZSBvZiBzY3JpcHQuYXR0cmlidXRlcykge1xuXHRcdFx0Y2xvbmUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xuXHRcdH1cblxuXHRcdGNsb25lLnRleHRDb250ZW50ID0gc2NyaXB0LnRleHRDb250ZW50O1xuXG5cdFx0Ly8gVGhlIHNjcmlwdCBoYXMgY2hhbmdlZCAtIGlmIGl0J3MgYXQgdGhlIGVkZ2VzLCB0aGUgZWZmZWN0IG5vdyBwb2ludHMgYXQgZGVhZCBub2Rlc1xuXHRcdGlmIChpc19mcmFnbWVudCA/IG5vZGUuZmlyc3RDaGlsZCA9PT0gc2NyaXB0IDogbm9kZSA9PT0gc2NyaXB0KSB7XG5cdFx0XHRlZmZlY3Qubm9kZXNfc3RhcnQgPSBjbG9uZTtcblx0XHR9XG5cdFx0aWYgKGlzX2ZyYWdtZW50ID8gbm9kZS5sYXN0Q2hpbGQgPT09IHNjcmlwdCA6IG5vZGUgPT09IHNjcmlwdCkge1xuXHRcdFx0ZWZmZWN0Lm5vZGVzX2VuZCA9IGNsb25lO1xuXHRcdH1cblxuXHRcdHNjcmlwdC5yZXBsYWNlV2l0aChjbG9uZSk7XG5cdH1cblx0cmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRG9uJ3QgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0LWZyZWUsIGh5ZHJhdGlvbiBuZWVkcyB0byB3YWxrIGFsbCBub2Rlc1xuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0KHZhbHVlID0gJycpIHtcblx0aWYgKCFoeWRyYXRpbmcpIHtcblx0XHR2YXIgdCA9IGNyZWF0ZV90ZXh0KHZhbHVlICsgJycpO1xuXHRcdGFzc2lnbl9ub2Rlcyh0LCB0KTtcblx0XHRyZXR1cm4gdDtcblx0fVxuXG5cdHZhciBub2RlID0gaHlkcmF0ZV9ub2RlO1xuXG5cdGlmIChub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcblx0XHQvLyBpZiBhbiB7ZXhwcmVzc2lvbn0gaXMgZW1wdHkgZHVyaW5nIFNTUiwgd2UgbmVlZCB0byBpbnNlcnQgYW4gZW1wdHkgdGV4dCBub2RlXG5cdFx0bm9kZS5iZWZvcmUoKG5vZGUgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShub2RlKTtcblx0fVxuXG5cdGFzc2lnbl9ub2Rlcyhub2RlLCBub2RlKTtcblx0cmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21tZW50KCkge1xuXHQvLyB3ZSdyZSBub3QgZGVsZWdhdGluZyB0byBgdGVtcGxhdGVgIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFzc2lnbl9ub2RlcyhoeWRyYXRlX25vZGUsIG51bGwpO1xuXHRcdHJldHVybiBoeWRyYXRlX25vZGU7XG5cdH1cblxuXHR2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0dmFyIHN0YXJ0ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG5cdHZhciBhbmNob3IgPSBjcmVhdGVfdGV4dCgpO1xuXHRmcmFnLmFwcGVuZChzdGFydCwgYW5jaG9yKTtcblxuXHRhc3NpZ25fbm9kZXMoc3RhcnQsIGFuY2hvcik7XG5cblx0cmV0dXJuIGZyYWc7XG59XG5cbi8qKlxuICogQXNzaWduIHRoZSBjcmVhdGVkIChvciBpbiBoeWRyYXRpb24gbW9kZSwgdHJhdmVyc2VkKSBkb20gZWxlbWVudHMgdG8gdGhlIGN1cnJlbnQgYmxvY2tcbiAqIGFuZCBpbnNlcnQgdGhlIGVsZW1lbnRzIGludG8gdGhlIGRvbSAoaW4gY2xpZW50IG1vZGUpLlxuICogQHBhcmFtIHtUZXh0IHwgQ29tbWVudCB8IEVsZW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQoYW5jaG9yLCBkb20pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCkubm9kZXNfZW5kID0gaHlkcmF0ZV9ub2RlO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmIChhbmNob3IgPT09IG51bGwpIHtcblx0XHQvLyBlZGdlIGNhc2UgXHUyMDE0IHZvaWQgYDxzdmVsdGU6ZWxlbWVudD5gIHdpdGggY29udGVudFxuXHRcdHJldHVybjtcblx0fVxuXG5cdGFuY2hvci5iZWZvcmUoLyoqIEB0eXBlIHtOb2RlfSAqLyAoZG9tKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIChvciBoeWRyYXRlKSBhbiB1bmlxdWUgVUlEIGZvciB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcHNfaWQoKSB7XG5cdGlmIChcblx0XHRoeWRyYXRpbmcgJiZcblx0XHRoeWRyYXRlX25vZGUgJiZcblx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJlxuXHRcdGh5ZHJhdGVfbm9kZS50ZXh0Q29udGVudD8uc3RhcnRzV2l0aChgI2ApXG5cdCkge1xuXHRcdGNvbnN0IGlkID0gaHlkcmF0ZV9ub2RlLnRleHRDb250ZW50LnN1YnN0cmluZygxKTtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0XHRyZXR1cm4gaWQ7XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yIFRoaXMgd2F5IHdlIGVuc3VyZSB0aGUgaWQgaXMgdW5pcXVlIGV2ZW4gYWNyb3NzIFN2ZWx0ZSBydW50aW1lc1xuXHQod2luZG93Ll9fc3ZlbHRlID8/PSB7fSkudWlkID8/PSAxO1xuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIGBjJHt3aW5kb3cuX19zdmVsdGUudWlkKyt9YDtcbn1cbiIsICJjb25zdCByZWdleF9yZXR1cm5fY2hhcmFjdGVycyA9IC9cXHIvZztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChzdHIpIHtcblx0c3RyID0gc3RyLnJlcGxhY2UocmVnZXhfcmV0dXJuX2NoYXJhY3RlcnMsICcnKTtcblx0bGV0IGhhc2ggPSA1MzgxO1xuXHRsZXQgaSA9IHN0ci5sZW5ndGg7XG5cblx0d2hpbGUgKGktLSkgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG5cdHJldHVybiAoaGFzaCA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxuXG5jb25zdCBWT0lEX0VMRU1FTlRfTkFNRVMgPSBbXG5cdCdhcmVhJyxcblx0J2Jhc2UnLFxuXHQnYnInLFxuXHQnY29sJyxcblx0J2NvbW1hbmQnLFxuXHQnZW1iZWQnLFxuXHQnaHInLFxuXHQnaW1nJyxcblx0J2lucHV0Jyxcblx0J2tleWdlbicsXG5cdCdsaW5rJyxcblx0J21ldGEnLFxuXHQncGFyYW0nLFxuXHQnc291cmNlJyxcblx0J3RyYWNrJyxcblx0J3dicidcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIG9mIGEgdm9pZCBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfdm9pZChuYW1lKSB7XG5cdHJldHVybiBWT0lEX0VMRU1FTlRfTkFNRVMuaW5jbHVkZXMobmFtZSkgfHwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSAnIWRvY3R5cGUnO1xufVxuXG5jb25zdCBSRVNFUlZFRF9XT1JEUyA9IFtcblx0J2FyZ3VtZW50cycsXG5cdCdhd2FpdCcsXG5cdCdicmVhaycsXG5cdCdjYXNlJyxcblx0J2NhdGNoJyxcblx0J2NsYXNzJyxcblx0J2NvbnN0Jyxcblx0J2NvbnRpbnVlJyxcblx0J2RlYnVnZ2VyJyxcblx0J2RlZmF1bHQnLFxuXHQnZGVsZXRlJyxcblx0J2RvJyxcblx0J2Vsc2UnLFxuXHQnZW51bScsXG5cdCdldmFsJyxcblx0J2V4cG9ydCcsXG5cdCdleHRlbmRzJyxcblx0J2ZhbHNlJyxcblx0J2ZpbmFsbHknLFxuXHQnZm9yJyxcblx0J2Z1bmN0aW9uJyxcblx0J2lmJyxcblx0J2ltcGxlbWVudHMnLFxuXHQnaW1wb3J0Jyxcblx0J2luJyxcblx0J2luc3RhbmNlb2YnLFxuXHQnaW50ZXJmYWNlJyxcblx0J2xldCcsXG5cdCduZXcnLFxuXHQnbnVsbCcsXG5cdCdwYWNrYWdlJyxcblx0J3ByaXZhdGUnLFxuXHQncHJvdGVjdGVkJyxcblx0J3B1YmxpYycsXG5cdCdyZXR1cm4nLFxuXHQnc3RhdGljJyxcblx0J3N1cGVyJyxcblx0J3N3aXRjaCcsXG5cdCd0aGlzJyxcblx0J3Rocm93Jyxcblx0J3RydWUnLFxuXHQndHJ5Jyxcblx0J3R5cGVvZicsXG5cdCd2YXInLFxuXHQndm9pZCcsXG5cdCd3aGlsZScsXG5cdCd3aXRoJyxcblx0J3lpZWxkJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgd29yZGAgaXMgYSByZXNlcnZlZCBKYXZhU2NyaXB0IGtleXdvcmRcbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19yZXNlcnZlZCh3b3JkKSB7XG5cdHJldHVybiBSRVNFUlZFRF9XT1JEUy5pbmNsdWRlcyh3b3JkKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY2FwdHVyZV9ldmVudChuYW1lKSB7XG5cdHJldHVybiBuYW1lLmVuZHNXaXRoKCdjYXB0dXJlJykgJiYgbmFtZSAhPT0gJ2dvdHBvaW50ZXJjYXB0dXJlJyAmJiBuYW1lICE9PSAnbG9zdHBvaW50ZXJjYXB0dXJlJztcbn1cblxuLyoqIExpc3Qgb2YgRWxlbWVudCBldmVudHMgdGhhdCB3aWxsIGJlIGRlbGVnYXRlZCAqL1xuY29uc3QgREVMRUdBVEVEX0VWRU5UUyA9IFtcblx0J2JlZm9yZWlucHV0Jyxcblx0J2NsaWNrJyxcblx0J2NoYW5nZScsXG5cdCdkYmxjbGljaycsXG5cdCdjb250ZXh0bWVudScsXG5cdCdmb2N1c2luJyxcblx0J2ZvY3Vzb3V0Jyxcblx0J2lucHV0Jyxcblx0J2tleWRvd24nLFxuXHQna2V5dXAnLFxuXHQnbW91c2Vkb3duJyxcblx0J21vdXNlbW92ZScsXG5cdCdtb3VzZW91dCcsXG5cdCdtb3VzZW92ZXInLFxuXHQnbW91c2V1cCcsXG5cdCdwb2ludGVyZG93bicsXG5cdCdwb2ludGVybW92ZScsXG5cdCdwb2ludGVyb3V0Jyxcblx0J3BvaW50ZXJvdmVyJyxcblx0J3BvaW50ZXJ1cCcsXG5cdCd0b3VjaGVuZCcsXG5cdCd0b3VjaG1vdmUnLFxuXHQndG91Y2hzdGFydCdcbl07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYGV2ZW50X25hbWVgIGlzIGEgZGVsZWdhdGVkIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRfbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfZGVsZWdhdGVkKGV2ZW50X25hbWUpIHtcblx0cmV0dXJuIERFTEVHQVRFRF9FVkVOVFMuaW5jbHVkZXMoZXZlbnRfbmFtZSk7XG59XG5cbi8qKlxuICogQXR0cmlidXRlcyB0aGF0IGFyZSBib29sZWFuLCBpLmUuIHRoZXkgYXJlIHByZXNlbnQgb3Igbm90IHByZXNlbnQuXG4gKi9cbmNvbnN0IERPTV9CT09MRUFOX0FUVFJJQlVURVMgPSBbXG5cdCdhbGxvd2Z1bGxzY3JlZW4nLFxuXHQnYXN5bmMnLFxuXHQnYXV0b2ZvY3VzJyxcblx0J2F1dG9wbGF5Jyxcblx0J2NoZWNrZWQnLFxuXHQnY29udHJvbHMnLFxuXHQnZGVmYXVsdCcsXG5cdCdkaXNhYmxlZCcsXG5cdCdmb3Jtbm92YWxpZGF0ZScsXG5cdCdoaWRkZW4nLFxuXHQnaW5kZXRlcm1pbmF0ZScsXG5cdCdpbmVydCcsXG5cdCdpc21hcCcsXG5cdCdsb29wJyxcblx0J211bHRpcGxlJyxcblx0J211dGVkJyxcblx0J25vbW9kdWxlJyxcblx0J25vdmFsaWRhdGUnLFxuXHQnb3BlbicsXG5cdCdwbGF5c2lubGluZScsXG5cdCdyZWFkb25seScsXG5cdCdyZXF1aXJlZCcsXG5cdCdyZXZlcnNlZCcsXG5cdCdzZWFtbGVzcycsXG5cdCdzZWxlY3RlZCcsXG5cdCd3ZWJraXRkaXJlY3RvcnknLFxuXHQnZGVmZXInLFxuXHQnZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmUnLFxuXHQnZGlzYWJsZXJlbW90ZXBsYXliYWNrJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBgbmFtZWAgaXMgYSBib29sZWFuIGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX2Jvb2xlYW5fYXR0cmlidXRlKG5hbWUpIHtcblx0cmV0dXJuIERPTV9CT09MRUFOX0FUVFJJQlVURVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbi8qKlxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59XG4gKiBMaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IHNob3VsZCBiZSBhbGlhc2VkIHRvIHRoZWlyIHByb3BlcnR5IG5hbWVzXG4gKiBiZWNhdXNlIHRoZXkgYmVoYXZlIGRpZmZlcmVudGx5IGJldHdlZW4gc2V0dGluZyB0aGVtIGFzIGFuIGF0dHJpYnV0ZSBhbmRcbiAqIHNldHRpbmcgdGhlbSBhcyBhIHByb3BlcnR5LlxuICovXG5jb25zdCBBVFRSSUJVVEVfQUxJQVNFUyA9IHtcblx0Ly8gbm8gYGNsYXNzOiAnY2xhc3NOYW1lJ2AgYmVjYXVzZSB3ZSBoYW5kbGUgdGhhdCBzZXBhcmF0ZWx5XG5cdGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuXHRpc21hcDogJ2lzTWFwJyxcblx0bm9tb2R1bGU6ICdub01vZHVsZScsXG5cdHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuXHRyZWFkb25seTogJ3JlYWRPbmx5Jyxcblx0ZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcblx0ZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG5cdHNyY29iamVjdDogJ3NyY09iamVjdCcsXG5cdG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcblx0YWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsc2NyZWVuJyxcblx0ZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG5cdGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaydcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZV9hdHRyaWJ1dGUobmFtZSkge1xuXHRuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRyZXR1cm4gQVRUUklCVVRFX0FMSUFTRVNbbmFtZV0gPz8gbmFtZTtcbn1cblxuY29uc3QgRE9NX1BST1BFUlRJRVMgPSBbXG5cdC4uLkRPTV9CT09MRUFOX0FUVFJJQlVURVMsXG5cdCdmb3JtTm9WYWxpZGF0ZScsXG5cdCdpc01hcCcsXG5cdCdub01vZHVsZScsXG5cdCdwbGF5c0lubGluZScsXG5cdCdyZWFkT25seScsXG5cdCd2YWx1ZScsXG5cdCd2b2x1bWUnLFxuXHQnZGVmYXVsdFZhbHVlJyxcblx0J2RlZmF1bHRDaGVja2VkJyxcblx0J3NyY09iamVjdCcsXG5cdCdub1ZhbGlkYXRlJyxcblx0J2FsbG93RnVsbHNjcmVlbicsXG5cdCdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG5cdCdkaXNhYmxlUmVtb3RlUGxheWJhY2snXG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19kb21fcHJvcGVydHkobmFtZSkge1xuXHRyZXR1cm4gRE9NX1BST1BFUlRJRVMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IE5PTl9TVEFUSUNfUFJPUEVSVElFUyA9IFsnYXV0b2ZvY3VzJywgJ211dGVkJywgJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCddO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgY2Fubm90IGJlIHNldCB0aHJvdWdoIHRoZSB0ZW1wbGF0ZVxuICogc3RyaW5nLCBpLmUuIG5lZWRzIHNvbWUga2luZCBvZiBKYXZhU2NyaXB0IGhhbmRsaW5nIHRvIHdvcmsuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2Fubm90X2JlX3NldF9zdGF0aWNhbGx5KG5hbWUpIHtcblx0cmV0dXJuIE5PTl9TVEFUSUNfUFJPUEVSVElFUy5pbmNsdWRlcyhuYW1lKTtcbn1cblxuLyoqXG4gKiBTdWJzZXQgb2YgZGVsZWdhdGVkIGV2ZW50cyB3aGljaCBzaG91bGQgYmUgcGFzc2l2ZSBieSBkZWZhdWx0LlxuICogVGhlc2UgdHdvIGFyZSBhbHJlYWR5IHBhc3NpdmUgdmlhIGJyb3dzZXIgZGVmYXVsdHMgb24gd2luZG93LCBkb2N1bWVudCBhbmQgYm9keS5cbiAqIEJ1dCBzaW5jZVxuICogLSB3ZSdyZSBkZWxlZ2F0aW5nIHRoZW1cbiAqIC0gdGhleSBoYXBwZW4gb2Z0ZW5cbiAqIC0gdGhleSBhcHBseSB0byBtb2JpbGUgd2hpY2ggaXMgZ2VuZXJhbGx5IGxlc3MgcGVyZm9ybWFudFxuICogd2UncmUgbWFya2luZyB0aGVtIGFzIHBhc3NpdmUgYnkgZGVmYXVsdCBmb3Igb3RoZXIgZWxlbWVudHMsIHRvby5cbiAqL1xuY29uc3QgUEFTU0lWRV9FVkVOVFMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJ107XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgYG5hbWVgIGlzIGEgcGFzc2l2ZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3Bhc3NpdmVfZXZlbnQobmFtZSkge1xuXHRyZXR1cm4gUEFTU0lWRV9FVkVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IENPTlRFTlRfRURJVEFCTEVfQklORElOR1MgPSBbJ3RleHRDb250ZW50JywgJ2lubmVySFRNTCcsICdpbm5lclRleHQnXTtcblxuLyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5leHBvcnQgZnVuY3Rpb24gaXNfY29udGVudF9lZGl0YWJsZV9iaW5kaW5nKG5hbWUpIHtcblx0cmV0dXJuIENPTlRFTlRfRURJVEFCTEVfQklORElOR1MuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IExPQURfRVJST1JfRUxFTUVOVFMgPSBbXG5cdCdib2R5Jyxcblx0J2VtYmVkJyxcblx0J2lmcmFtZScsXG5cdCdpbWcnLFxuXHQnbGluaycsXG5cdCdvYmplY3QnLFxuXHQnc2NyaXB0Jyxcblx0J3N0eWxlJyxcblx0J3RyYWNrJ1xuXTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZWxlbWVudCBlbWl0cyBgbG9hZGAgYW5kIGBlcnJvcmAgZXZlbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNfbG9hZF9lcnJvcl9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIExPQURfRVJST1JfRUxFTUVOVFMuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNvbnN0IFNWR19FTEVNRU5UUyA9IFtcblx0J2FsdEdseXBoJyxcblx0J2FsdEdseXBoRGVmJyxcblx0J2FsdEdseXBoSXRlbScsXG5cdCdhbmltYXRlJyxcblx0J2FuaW1hdGVDb2xvcicsXG5cdCdhbmltYXRlTW90aW9uJyxcblx0J2FuaW1hdGVUcmFuc2Zvcm0nLFxuXHQnY2lyY2xlJyxcblx0J2NsaXBQYXRoJyxcblx0J2NvbG9yLXByb2ZpbGUnLFxuXHQnY3Vyc29yJyxcblx0J2RlZnMnLFxuXHQnZGVzYycsXG5cdCdkaXNjYXJkJyxcblx0J2VsbGlwc2UnLFxuXHQnZmVCbGVuZCcsXG5cdCdmZUNvbG9yTWF0cml4Jyxcblx0J2ZlQ29tcG9uZW50VHJhbnNmZXInLFxuXHQnZmVDb21wb3NpdGUnLFxuXHQnZmVDb252b2x2ZU1hdHJpeCcsXG5cdCdmZURpZmZ1c2VMaWdodGluZycsXG5cdCdmZURpc3BsYWNlbWVudE1hcCcsXG5cdCdmZURpc3RhbnRMaWdodCcsXG5cdCdmZURyb3BTaGFkb3cnLFxuXHQnZmVGbG9vZCcsXG5cdCdmZUZ1bmNBJyxcblx0J2ZlRnVuY0InLFxuXHQnZmVGdW5jRycsXG5cdCdmZUZ1bmNSJyxcblx0J2ZlR2F1c3NpYW5CbHVyJyxcblx0J2ZlSW1hZ2UnLFxuXHQnZmVNZXJnZScsXG5cdCdmZU1lcmdlTm9kZScsXG5cdCdmZU1vcnBob2xvZ3knLFxuXHQnZmVPZmZzZXQnLFxuXHQnZmVQb2ludExpZ2h0Jyxcblx0J2ZlU3BlY3VsYXJMaWdodGluZycsXG5cdCdmZVNwb3RMaWdodCcsXG5cdCdmZVRpbGUnLFxuXHQnZmVUdXJidWxlbmNlJyxcblx0J2ZpbHRlcicsXG5cdCdmb250Jyxcblx0J2ZvbnQtZmFjZScsXG5cdCdmb250LWZhY2UtZm9ybWF0Jyxcblx0J2ZvbnQtZmFjZS1uYW1lJyxcblx0J2ZvbnQtZmFjZS1zcmMnLFxuXHQnZm9udC1mYWNlLXVyaScsXG5cdCdmb3JlaWduT2JqZWN0Jyxcblx0J2cnLFxuXHQnZ2x5cGgnLFxuXHQnZ2x5cGhSZWYnLFxuXHQnaGF0Y2gnLFxuXHQnaGF0Y2hwYXRoJyxcblx0J2hrZXJuJyxcblx0J2ltYWdlJyxcblx0J2xpbmUnLFxuXHQnbGluZWFyR3JhZGllbnQnLFxuXHQnbWFya2VyJyxcblx0J21hc2snLFxuXHQnbWVzaCcsXG5cdCdtZXNoZ3JhZGllbnQnLFxuXHQnbWVzaHBhdGNoJyxcblx0J21lc2hyb3cnLFxuXHQnbWV0YWRhdGEnLFxuXHQnbWlzc2luZy1nbHlwaCcsXG5cdCdtcGF0aCcsXG5cdCdwYXRoJyxcblx0J3BhdHRlcm4nLFxuXHQncG9seWdvbicsXG5cdCdwb2x5bGluZScsXG5cdCdyYWRpYWxHcmFkaWVudCcsXG5cdCdyZWN0Jyxcblx0J3NldCcsXG5cdCdzb2xpZGNvbG9yJyxcblx0J3N0b3AnLFxuXHQnc3ZnJyxcblx0J3N3aXRjaCcsXG5cdCdzeW1ib2wnLFxuXHQndGV4dCcsXG5cdCd0ZXh0UGF0aCcsXG5cdCd0cmVmJyxcblx0J3RzcGFuJyxcblx0J3Vua25vd24nLFxuXHQndXNlJyxcblx0J3ZpZXcnLFxuXHQndmtlcm4nXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19zdmcobmFtZSkge1xuXHRyZXR1cm4gU1ZHX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBNQVRITUxfRUxFTUVOVFMgPSBbXG5cdCdhbm5vdGF0aW9uJyxcblx0J2Fubm90YXRpb24teG1sJyxcblx0J21hY3Rpb24nLFxuXHQnbWF0aCcsXG5cdCdtZXJyb3InLFxuXHQnbWZyYWMnLFxuXHQnbWknLFxuXHQnbW11bHRpc2NyaXB0cycsXG5cdCdtbicsXG5cdCdtbycsXG5cdCdtb3ZlcicsXG5cdCdtcGFkZGVkJyxcblx0J21waGFudG9tJyxcblx0J21wcmVzY3JpcHRzJyxcblx0J21yb290Jyxcblx0J21yb3cnLFxuXHQnbXMnLFxuXHQnbXNwYWNlJyxcblx0J21zcXJ0Jyxcblx0J21zdHlsZScsXG5cdCdtc3ViJyxcblx0J21zdWJzdXAnLFxuXHQnbXN1cCcsXG5cdCdtdGFibGUnLFxuXHQnbXRkJyxcblx0J210ZXh0Jyxcblx0J210cicsXG5cdCdtdW5kZXInLFxuXHQnbXVuZGVyb3ZlcicsXG5cdCdzZW1hbnRpY3MnXG5dO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19tYXRobWwobmFtZSkge1xuXHRyZXR1cm4gTUFUSE1MX0VMRU1FTlRTLmluY2x1ZGVzKG5hbWUpO1xufVxuXG5jb25zdCBTVEFURV9DUkVBVElPTl9SVU5FUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdCckc3RhdGUnLFxuXHQnJHN0YXRlLnJhdycsXG5cdCckZGVyaXZlZCcsXG5cdCckZGVyaXZlZC5ieSdcbl0pO1xuXG5jb25zdCBSVU5FUyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbXG5cdC4uLlNUQVRFX0NSRUFUSU9OX1JVTkVTLFxuXHQnJHN0YXRlLnNuYXBzaG90Jyxcblx0JyRwcm9wcycsXG5cdCckcHJvcHMuaWQnLFxuXHQnJGJpbmRhYmxlJyxcblx0JyRlZmZlY3QnLFxuXHQnJGVmZmVjdC5wcmUnLFxuXHQnJGVmZmVjdC50cmFja2luZycsXG5cdCckZWZmZWN0LnJvb3QnLFxuXHQnJGVmZmVjdC5wZW5kaW5nJyxcblx0JyRpbnNwZWN0Jyxcblx0JyRpbnNwZWN0KCkud2l0aCcsXG5cdCckaW5zcGVjdC50cmFjZScsXG5cdCckaG9zdCdcbl0pO1xuXG4vKiogQHR5cGVkZWYge3R5cGVvZiBSVU5FU1tudW1iZXJdfSBSdW5lTmFtZSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmFtZSBpcyBSdW5lTmFtZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3J1bmUobmFtZSkge1xuXHRyZXR1cm4gUlVORVMuaW5jbHVkZXMoLyoqIEB0eXBlIHtSdW5lTmFtZX0gKi8gKG5hbWUpKTtcbn1cblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgU1RBVEVfQ1JFQVRJT05fUlVORVNbbnVtYmVyXX0gU3RhdGVDcmVhdGlvblJ1bmVOYW1lICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuYW1lIGlzIFN0YXRlQ3JlYXRpb25SdW5lTmFtZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzX3N0YXRlX2NyZWF0aW9uX3J1bmUobmFtZSkge1xuXHRyZXR1cm4gU1RBVEVfQ1JFQVRJT05fUlVORVMuaW5jbHVkZXMoLyoqIEB0eXBlIHtTdGF0ZUNyZWF0aW9uUnVuZU5hbWV9ICovIChuYW1lKSk7XG59XG5cbi8qKiBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgcmVxdWlyZSByYXcgY29udGVudHMgYW5kIHNob3VsZCBub3QgaGF2ZSBTU1IgY29tbWVudHMgcHV0IGluIHRoZW0gKi9cbmNvbnN0IFJBV19URVhUX0VMRU1FTlRTID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsndGV4dGFyZWEnLCAnc2NyaXB0JywgJ3N0eWxlJywgJ3RpdGxlJ10pO1xuXG4vKiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc19yYXdfdGV4dF9lbGVtZW50KG5hbWUpIHtcblx0cmV0dXJuIFJBV19URVhUX0VMRU1FTlRTLmluY2x1ZGVzKC8qKiBAdHlwZSB7dHlwZW9mIFJBV19URVhUX0VMRU1FTlRTW251bWJlcl19ICovIChuYW1lKSk7XG59XG5cbi8qKlxuICogUHJldmVudCBkZXZ0b29scyB0cnlpbmcgdG8gbWFrZSBgbG9jYXRpb25gIGEgY2xpY2thYmxlIGxpbmsgYnkgaW5zZXJ0aW5nIGEgemVyby13aWR0aCBzcGFjZVxuICogQHRlbXBsYXRlIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRcbiAqIEBwYXJhbSB7VH0gbG9jYXRpb25cbiAqIEByZXR1cm5zIHtUfTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplX2xvY2F0aW9uKGxvY2F0aW9uKSB7XG5cdHJldHVybiAvKiogQHR5cGUge1R9ICovIChsb2NhdGlvbj8ucmVwbGFjZSgvXFwvL2csICcvXFx1MjAwYicpKTtcbn1cbiIsICIvKiogQGltcG9ydCB7IENvbXBvbmVudENvbnRleHQsIEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRUeXBlLCBTdmVsdGVDb21wb25lbnQsIE1vdW50T3B0aW9ucyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRjbGVhcl90ZXh0X2NvbnRlbnQsXG5cdGNyZWF0ZV90ZXh0LFxuXHRnZXRfZmlyc3RfY2hpbGQsXG5cdGdldF9uZXh0X3NpYmxpbmcsXG5cdGluaXRfb3BlcmF0aW9uc1xufSBmcm9tICcuL2RvbS9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7IEhZRFJBVElPTl9FTkQsIEhZRFJBVElPTl9FUlJPUiwgSFlEUkFUSU9OX1NUQVJUIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgcHVzaCwgcG9wLCBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfcm9vdCwgYnJhbmNoIH0gZnJvbSAnLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuL2RvbS9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgYXJyYXlfZnJvbSB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRhbGxfcmVnaXN0ZXJlZF9ldmVudHMsXG5cdGhhbmRsZV9ldmVudF9wcm9wYWdhdGlvbixcblx0cm9vdF9ldmVudF9oYW5kbGVzXG59IGZyb20gJy4vZG9tL2VsZW1lbnRzL2V2ZW50cy5qcyc7XG5pbXBvcnQgeyByZXNldF9oZWFkX2FuY2hvciB9IGZyb20gJy4vZG9tL2Jsb2Nrcy9zdmVsdGUtaGVhZC5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuL2RvbS90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgeyBpc19wYXNzaXZlX2V2ZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG4vKipcbiAqIFRoaXMgaXMgbm9ybWFsbHkgdHJ1ZSBcdTIwMTQgYmxvY2sgZWZmZWN0cyBzaG91bGQgcnVuIHRoZWlyIGludHJvIHRyYW5zaXRpb25zIFx1MjAxNFxuICogYnV0IGlzIGZhbHNlIGR1cmluZyBoeWRyYXRpb24gKHVubGVzcyBgb3B0aW9ucy5pbnRyb2AgaXMgYHRydWVgKSBhbmRcbiAqIHdoZW4gY3JlYXRpbmcgdGhlIGNoaWxkcmVuIG9mIGEgYDxzdmVsdGU6ZWxlbWVudD5gIHRoYXQganVzdCBjaGFuZ2VkIHRhZ1xuICovXG5leHBvcnQgbGV0IHNob3VsZF9pbnRybyA9IHRydWU7XG5cbi8qKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3Nob3VsZF9pbnRybyh2YWx1ZSkge1xuXHRzaG91bGRfaW50cm8gPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfdGV4dCh0ZXh0LCB2YWx1ZSkge1xuXHQvLyBGb3Igb2JqZWN0cywgd2UgYXBwbHkgc3RyaW5nIGNvZXJjaW9uICh3aGljaCBtaWdodCBtYWtlIHRoaW5ncyBsaWtlICRzdGF0ZSBhcnJheSByZWZlcmVuY2VzIGluIHRoZSB0ZW1wbGF0ZSByZWFjdGl2ZSkgYmVmb3JlIGRpZmZpbmdcblx0dmFyIHN0ciA9IHZhbHVlID09IG51bGwgPyAnJyA6IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSArICcnIDogdmFsdWU7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0aWYgKHN0ciAhPT0gKHRleHQuX190ID8/PSB0ZXh0Lm5vZGVWYWx1ZSkpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0dGV4dC5fX3QgPSBzdHI7XG5cdFx0dGV4dC5ub2RlVmFsdWUgPSBzdHIgKyAnJztcblx0fVxufVxuXG4vKipcbiAqIE1vdW50cyBhIGNvbXBvbmVudCB0byB0aGUgZ2l2ZW4gdGFyZ2V0IGFuZCByZXR1cm5zIHRoZSBleHBvcnRzIGFuZCBwb3RlbnRpYWxseSB0aGUgcHJvcHMgKGlmIGNvbXBpbGVkIHdpdGggYGFjY2Vzc29yczogdHJ1ZWApIG9mIHRoZSBjb21wb25lbnQuXG4gKiBUcmFuc2l0aW9ucyB3aWxsIHBsYXkgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciB1bmxlc3MgdGhlIGBpbnRyb2Agb3B0aW9uIGlzIHNldCB0byBgZmFsc2VgLlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxQcm9wcz4+IHwgQ29tcG9uZW50PFByb3BzLCBFeHBvcnRzLCBhbnk+fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TW91bnRPcHRpb25zPFByb3BzPn0gb3B0aW9uc1xuICogQHJldHVybnMge0V4cG9ydHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtb3VudChjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0cmV0dXJuIF9tb3VudChjb21wb25lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEh5ZHJhdGVzIGEgY29tcG9uZW50IG9uIHRoZSBnaXZlbiB0YXJnZXQgYW5kIHJldHVybnMgdGhlIGV4cG9ydHMgYW5kIHBvdGVudGlhbGx5IHRoZSBwcm9wcyAoaWYgY29tcGlsZWQgd2l0aCBgYWNjZXNzb3JzOiB0cnVlYCkgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxQcm9wcz4+IHwgQ29tcG9uZW50PFByb3BzLCBFeHBvcnRzLCBhbnk+fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7e30gZXh0ZW5kcyBQcm9wcyA/IHtcbiAqIFx0XHR0YXJnZXQ6IERvY3VtZW50IHwgRWxlbWVudCB8IFNoYWRvd1Jvb3Q7XG4gKiBcdFx0cHJvcHM/OiBQcm9wcztcbiAqIFx0XHRldmVudHM/OiBSZWNvcmQ8c3RyaW5nLCAoZTogYW55KSA9PiBhbnk+O1xuICogIFx0Y29udGV4dD86IE1hcDxhbnksIGFueT47XG4gKiBcdFx0aW50cm8/OiBib29sZWFuO1xuICogXHRcdHJlY292ZXI/OiBib29sZWFuO1xuICogXHR9IDoge1xuICogXHRcdHRhcmdldDogRG9jdW1lbnQgfCBFbGVtZW50IHwgU2hhZG93Um9vdDtcbiAqIFx0XHRwcm9wczogUHJvcHM7XG4gKiBcdFx0ZXZlbnRzPzogUmVjb3JkPHN0cmluZywgKGU6IGFueSkgPT4gYW55PjtcbiAqICBcdGNvbnRleHQ/OiBNYXA8YW55LCBhbnk+O1xuICogXHRcdGludHJvPzogYm9vbGVhbjtcbiAqIFx0XHRyZWNvdmVyPzogYm9vbGVhbjtcbiAqIFx0fX0gb3B0aW9uc1xuICogQHJldHVybnMge0V4cG9ydHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHRpbml0X29wZXJhdGlvbnMoKTtcblx0b3B0aW9ucy5pbnRybyA9IG9wdGlvbnMuaW50cm8gPz8gZmFsc2U7XG5cdGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXHRjb25zdCB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXHRjb25zdCBwcmV2aW91c19oeWRyYXRlX25vZGUgPSBoeWRyYXRlX25vZGU7XG5cblx0dHJ5IHtcblx0XHR2YXIgYW5jaG9yID0gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQodGFyZ2V0KSk7XG5cdFx0d2hpbGUgKFxuXHRcdFx0YW5jaG9yICYmXG5cdFx0XHQoYW5jaG9yLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHwgLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKS5kYXRhICE9PSBIWURSQVRJT05fU1RBUlQpXG5cdFx0KSB7XG5cdFx0XHRhbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9uZXh0X3NpYmxpbmcoYW5jaG9yKSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFhbmNob3IpIHtcblx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHR9XG5cblx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdHNldF9oeWRyYXRlX25vZGUoLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoYW5jaG9yKSk7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cblx0XHRjb25zdCBpbnN0YW5jZSA9IF9tb3VudChjb21wb25lbnQsIHsgLi4ub3B0aW9ucywgYW5jaG9yIH0pO1xuXG5cdFx0aWYgKFxuXHRcdFx0aHlkcmF0ZV9ub2RlID09PSBudWxsIHx8XG5cdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSB8fFxuXHRcdFx0LyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKS5kYXRhICE9PSBIWURSQVRJT05fRU5EXG5cdFx0KSB7XG5cdFx0XHR3Lmh5ZHJhdGlvbl9taXNtYXRjaCgpO1xuXHRcdFx0dGhyb3cgSFlEUkFUSU9OX0VSUk9SO1xuXHRcdH1cblxuXHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXG5cdFx0cmV0dXJuIC8qKiAgQHR5cGUge0V4cG9ydHN9ICovIChpbnN0YW5jZSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gcmUtdGhyb3cgU3ZlbHRlIGVycm9ycyAtIHRoZXkgYXJlIGNlcnRhaW5seSBub3QgcmVsYXRlZCB0byBoeWRyYXRpb25cblx0XHRpZiAoXG5cdFx0XHRlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG5cdFx0XHRlcnJvci5tZXNzYWdlLnNwbGl0KCdcXG4nKS5zb21lKChsaW5lKSA9PiBsaW5lLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vc3ZlbHRlLmRldi9lLycpKVxuXHRcdCkge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHRcdGlmIChlcnJvciAhPT0gSFlEUkFUSU9OX0VSUk9SKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuXHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gaHlkcmF0ZTogJywgZXJyb3IpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnJlY292ZXIgPT09IGZhbHNlKSB7XG5cdFx0XHRlLmh5ZHJhdGlvbl9mYWlsZWQoKTtcblx0XHR9XG5cblx0XHQvLyBJZiBhbiBlcnJvciBvY2N1cmVkIGFib3ZlLCB0aGUgb3BlcmF0aW9ucyBtaWdodCBub3QgeWV0IGhhdmUgYmVlbiBpbml0aWFsaXNlZC5cblx0XHRpbml0X29wZXJhdGlvbnMoKTtcblx0XHRjbGVhcl90ZXh0X2NvbnRlbnQodGFyZ2V0KTtcblxuXHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdHJldHVybiBtb3VudChjb21wb25lbnQsIG9wdGlvbnMpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNldF9oeWRyYXRpbmcod2FzX2h5ZHJhdGluZyk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShwcmV2aW91c19oeWRyYXRlX25vZGUpO1xuXHRcdHJlc2V0X2hlYWRfYW5jaG9yKCk7XG5cdH1cbn1cblxuLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBudW1iZXI+fSAqL1xuY29uc3QgZG9jdW1lbnRfbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHBhcmFtIHtDb21wb25lbnRUeXBlPFN2ZWx0ZUNvbXBvbmVudDxhbnk+PiB8IENvbXBvbmVudDxhbnk+fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7TW91bnRPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7RXhwb3J0c31cbiAqL1xuZnVuY3Rpb24gX21vdW50KENvbXBvbmVudCwgeyB0YXJnZXQsIGFuY2hvciwgcHJvcHMgPSB7fSwgZXZlbnRzLCBjb250ZXh0LCBpbnRybyA9IHRydWUgfSkge1xuXHRpbml0X29wZXJhdGlvbnMoKTtcblxuXHQvKiogQHR5cGUge1NldDxzdHJpbmc+fSAqL1xuXHR2YXIgcmVnaXN0ZXJlZF9ldmVudHMgPSBuZXcgU2V0KCk7XG5cblx0LyoqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXZlbnRzICovXG5cdHZhciBldmVudF9oYW5kbGUgPSAoZXZlbnRzKSA9PiB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBldmVudF9uYW1lID0gZXZlbnRzW2ldO1xuXG5cdFx0XHRpZiAocmVnaXN0ZXJlZF9ldmVudHMuaGFzKGV2ZW50X25hbWUpKSBjb250aW51ZTtcblx0XHRcdHJlZ2lzdGVyZWRfZXZlbnRzLmFkZChldmVudF9uYW1lKTtcblxuXHRcdFx0dmFyIHBhc3NpdmUgPSBpc19wYXNzaXZlX2V2ZW50KGV2ZW50X25hbWUpO1xuXG5cdFx0XHQvLyBBZGQgdGhlIGV2ZW50IGxpc3RlbmVyIHRvIGJvdGggdGhlIGNvbnRhaW5lciBhbmQgdGhlIGRvY3VtZW50LlxuXHRcdFx0Ly8gVGhlIGNvbnRhaW5lciBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyBmcm9tIHdpdGhpbiBpbiBjYXNlXG5cdFx0XHQvLyB0aGUgb3V0ZXIgY29udGVudCBzdG9wcyBwcm9wYWdhdGlvbiBvZiB0aGUgZXZlbnQuXG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblxuXHRcdFx0dmFyIG4gPSBkb2N1bWVudF9saXN0ZW5lcnMuZ2V0KGV2ZW50X25hbWUpO1xuXG5cdFx0XHRpZiAobiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIFRoZSBkb2N1bWVudCBsaXN0ZW5lciBlbnN1cmVzIHdlIGNhdGNoIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZSBmcm9tIGVsZW1lbnRzIHRoYXQgd2VyZVxuXHRcdFx0XHQvLyBtYW51YWxseSBtb3ZlZCBvdXRzaWRlIG9mIHRoZSBjb250YWluZXIgKGUuZy4gdmlhIG1hbnVhbCBwb3J0YWxzKS5cblx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVfZXZlbnRfcHJvcGFnYXRpb24sIHsgcGFzc2l2ZSB9KTtcblx0XHRcdFx0ZG9jdW1lbnRfbGlzdGVuZXJzLnNldChldmVudF9uYW1lLCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbiArIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRldmVudF9oYW5kbGUoYXJyYXlfZnJvbShhbGxfcmVnaXN0ZXJlZF9ldmVudHMpKTtcblx0cm9vdF9ldmVudF9oYW5kbGVzLmFkZChldmVudF9oYW5kbGUpO1xuXG5cdC8qKiBAdHlwZSB7RXhwb3J0c30gKi9cblx0Ly8gQHRzLWV4cGVjdC1lcnJvciB3aWxsIGJlIGRlZmluZWQgYmVjYXVzZSB0aGUgcmVuZGVyIGVmZmVjdCBydW5zIHN5bmNocm9ub3VzbHlcblx0dmFyIGNvbXBvbmVudCA9IHVuZGVmaW5lZDtcblxuXHR2YXIgdW5tb3VudCA9IGNvbXBvbmVudF9yb290KCgpID0+IHtcblx0XHR2YXIgYW5jaG9yX25vZGUgPSBhbmNob3IgPz8gdGFyZ2V0LmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXG5cdFx0YnJhbmNoKCgpID0+IHtcblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHB1c2goe30pO1xuXHRcdFx0XHR2YXIgY3R4ID0gLyoqIEB0eXBlIHtDb21wb25lbnRDb250ZXh0fSAqLyAoY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdFx0XHRjdHguYyA9IGNvbnRleHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0Ly8gV2UgY2FuJ3Qgc3ByZWFkIHRoZSBvYmplY3Qgb3IgZWxzZSB3ZSdkIGxvc2UgdGhlIHN0YXRlIHByb3h5IHN0dWZmLCBpZiBpdCBpcyBvbmVcblx0XHRcdFx0LyoqIEB0eXBlIHthbnl9ICovIChwcm9wcykuJCRldmVudHMgPSBldmVudHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0YXNzaWduX25vZGVzKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoYW5jaG9yX25vZGUpLCBudWxsKTtcblx0XHRcdH1cblxuXHRcdFx0c2hvdWxkX2ludHJvID0gaW50cm87XG5cdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIHRoZSBwdWJsaWMgdHlwaW5ncyBhcmUgbm90IHdoYXQgdGhlIGFjdHVhbCBmdW5jdGlvbiBsb29rcyBsaWtlXG5cdFx0XHRjb21wb25lbnQgPSBDb21wb25lbnQoYW5jaG9yX25vZGUsIHByb3BzKSB8fCB7fTtcblx0XHRcdHNob3VsZF9pbnRybyA9IHRydWU7XG5cblx0XHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtFZmZlY3R9ICovIChhY3RpdmVfZWZmZWN0KS5ub2Rlc19lbmQgPSBoeWRyYXRlX25vZGU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjb250ZXh0KSB7XG5cdFx0XHRcdHBvcCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdGZvciAodmFyIGV2ZW50X25hbWUgb2YgcmVnaXN0ZXJlZF9ldmVudHMpIHtcblx0XHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblxuXHRcdFx0XHR2YXIgbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZG9jdW1lbnRfbGlzdGVuZXJzLmdldChldmVudF9uYW1lKSk7XG5cblx0XHRcdFx0aWYgKC0tbiA9PT0gMCkge1xuXHRcdFx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlX2V2ZW50X3Byb3BhZ2F0aW9uKTtcblx0XHRcdFx0XHRkb2N1bWVudF9saXN0ZW5lcnMuZGVsZXRlKGV2ZW50X25hbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRvY3VtZW50X2xpc3RlbmVycy5zZXQoZXZlbnRfbmFtZSwgbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cm9vdF9ldmVudF9oYW5kbGVzLmRlbGV0ZShldmVudF9oYW5kbGUpO1xuXG5cdFx0XHRpZiAoYW5jaG9yX25vZGUgIT09IGFuY2hvcikge1xuXHRcdFx0XHRhbmNob3Jfbm9kZS5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChhbmNob3Jfbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSk7XG5cblx0bW91bnRlZF9jb21wb25lbnRzLnNldChjb21wb25lbnQsIHVubW91bnQpO1xuXHRyZXR1cm4gY29tcG9uZW50O1xufVxuXG4vKipcbiAqIFJlZmVyZW5jZXMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCB3ZXJlIG1vdW50ZWQgb3IgaHlkcmF0ZWQuXG4gKiBVc2VzIGEgYFdlYWtNYXBgIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAqL1xubGV0IG1vdW50ZWRfY29tcG9uZW50cyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBtb3VudGVkIHVzaW5nIGBtb3VudGAgb3IgYGh5ZHJhdGVgLlxuICpcbiAqIFNpbmNlIDUuMTMuMCwgaWYgYG9wdGlvbnMub3V0cm9gIGlzIGB0cnVlYCwgW3RyYW5zaXRpb25zXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdHJhbnNpdGlvbikgd2lsbCBwbGF5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBhZnRlciB0cmFuc2l0aW9ucyBoYXZlIGNvbXBsZXRlZCBpZiBgb3B0aW9ucy5vdXRyb2AgaXMgdHJ1ZSwgb3IgaW1tZWRpYXRlbHkgb3RoZXJ3aXNlIChwcmlvciB0byA1LjEzLjAsIHJldHVybnMgYHZvaWRgKS5cbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgbW91bnQsIHVubW91bnQgfSBmcm9tICdzdmVsdGUnO1xuICogaW1wb3J0IEFwcCBmcm9tICcuL0FwcC5zdmVsdGUnO1xuICpcbiAqIGNvbnN0IGFwcCA9IG1vdW50KEFwcCwgeyB0YXJnZXQ6IGRvY3VtZW50LmJvZHkgfSk7XG4gKlxuICogLy8gbGF0ZXIuLi5cbiAqIHVubW91bnQoYXBwLCB7IG91dHJvOiB0cnVlIH0pO1xuICogYGBgXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGNvbXBvbmVudFxuICogQHBhcmFtIHt7IG91dHJvPzogYm9vbGVhbiB9fSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudChjb21wb25lbnQsIG9wdGlvbnMpIHtcblx0Y29uc3QgZm4gPSBtb3VudGVkX2NvbXBvbmVudHMuZ2V0KGNvbXBvbmVudCk7XG5cblx0aWYgKGZuKSB7XG5cdFx0bW91bnRlZF9jb21wb25lbnRzLmRlbGV0ZShjb21wb25lbnQpO1xuXHRcdHJldHVybiBmbihvcHRpb25zKTtcblx0fVxuXG5cdGlmIChERVYpIHtcblx0XHR3LmxpZmVjeWNsZV9kb3VibGVfdW5tb3VudCgpO1xuXHR9XG5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuIiwgImltcG9ydCB7IGlzX3ZvaWQgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuL2Vycm9ycy5qcyc7XG5cbmV4cG9ydCB7IGludmFsaWRfZGVmYXVsdF9zbmlwcGV0IH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSB0YWdfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnX2ZuKSB7XG5cdGNvbnN0IHRhZyA9IHRhZ19mbigpO1xuXHRpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuXHRcdHcuZHluYW1pY192b2lkX2VsZW1lbnRfY29udGVudCh0YWcpO1xuXHR9XG59XG5cbi8qKiBAcGFyYW0geygpID0+IHVua25vd259IHRhZ19mbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudF90YWcodGFnX2ZuKSB7XG5cdGNvbnN0IHRhZyA9IHRhZ19mbigpO1xuXHRjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcblx0aWYgKHRhZyAmJiAhaXNfc3RyaW5nKSB7XG5cdFx0ZS5zdmVsdGVfZWxlbWVudF9pbnZhbGlkX3RoaXNfdmFsdWUoKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG5cdGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcblx0XHRlLnN0b3JlX2ludmFsaWRfc2hhcGUobmFtZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgeyguLi5hcmdzOiBhbnlbXSkgPT4gdW5rbm93bn0gVFxuICogQHBhcmFtIHtUfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudF9zbmlwcGV0X3N0cmluZ2lmaWNhdGlvbihmbikge1xuXHRmbi50b1N0cmluZyA9ICgpID0+IHtcblx0XHRlLnNuaXBwZXRfd2l0aG91dF9yZW5kZXJfdGFnKCk7XG5cdFx0cmV0dXJuICcnO1xuXHR9O1xuXHRyZXR1cm4gZm47XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTbmlwcGV0IH0gZnJvbSAnc3ZlbHRlJyAqL1xuLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFRlbXBsYXRlTm9kZSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEdldHRlcnMgfSBmcm9tICcjc2hhcmVkJyAqL1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5ULCBFTEVNRU5UX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBicmFuY2gsIGJsb2NrLCBkZXN0cm95X2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHtcblx0ZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uLFxuXHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uXG59IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9uZXh0LCBoeWRyYXRlX25vZGUsIGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfZnJhZ21lbnRfZnJvbV9odG1sIH0gZnJvbSAnLi4vcmVjb25jaWxlci5qcyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uLy4uL3dhcm5pbmdzLmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi4vLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IHByZXZlbnRfc25pcHBldF9zdHJpbmdpZmljYXRpb24gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdmFsaWRhdGUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7KG5vZGU6IFRlbXBsYXRlTm9kZSwgLi4uYXJnczogYW55W10pID0+IHZvaWR9IFNuaXBwZXRGblxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gU25pcHBldEZuIHwgbnVsbCB8IHVuZGVmaW5lZH0gZ2V0X3NuaXBwZXRcbiAqIEBwYXJhbSB7KCgpID0+IGFueSlbXX0gYXJnc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbmlwcGV0KG5vZGUsIGdldF9zbmlwcGV0LCAuLi5hcmdzKSB7XG5cdHZhciBhbmNob3IgPSBub2RlO1xuXG5cdC8qKiBAdHlwZSB7U25pcHBldEZuIHwgbnVsbCB8IHVuZGVmaW5lZH0gKi9cblx0Ly8gQHRzLWlnbm9yZVxuXHR2YXIgc25pcHBldCA9IG5vb3A7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgc25pcHBldF9lZmZlY3Q7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGlmIChzbmlwcGV0ID09PSAoc25pcHBldCA9IGdldF9zbmlwcGV0KCkpKSByZXR1cm47XG5cblx0XHRpZiAoc25pcHBldF9lZmZlY3QpIHtcblx0XHRcdGRlc3Ryb3lfZWZmZWN0KHNuaXBwZXRfZWZmZWN0KTtcblx0XHRcdHNuaXBwZXRfZWZmZWN0ID0gbnVsbDtcblx0XHR9XG5cblx0XHRpZiAoREVWICYmIHNuaXBwZXQgPT0gbnVsbCkge1xuXHRcdFx0ZS5pbnZhbGlkX3NuaXBwZXQoKTtcblx0XHR9XG5cblx0XHRzbmlwcGV0X2VmZmVjdCA9IGJyYW5jaCgoKSA9PiAvKiogQHR5cGUge1NuaXBwZXRGbn0gKi8gKHNuaXBwZXQpKGFuY2hvciwgLi4uYXJncykpO1xuXHR9LCBFRkZFQ1RfVFJBTlNQQVJFTlQpO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cblxuLyoqXG4gKiBJbiBkZXZlbG9wbWVudCwgd3JhcCB0aGUgc25pcHBldCBmdW5jdGlvbiBzbyB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9uLCBhbmQgc28gdGhhdCB0aGVcbiAqIGNvcnJlY3QgY29tcG9uZW50IGNvbnRleHQgaXMgc2V0IGZvciBvd25lcnNoaXAgY2hlY2tzXG4gKiBAcGFyYW0ge2FueX0gY29tcG9uZW50XG4gKiBAcGFyYW0geyhub2RlOiBUZW1wbGF0ZU5vZGUsIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBmblxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcF9zbmlwcGV0KGNvbXBvbmVudCwgZm4pIHtcblx0Y29uc3Qgc25pcHBldCA9ICgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gbm9kZSwgLyoqIEB0eXBlIHthbnlbXX0gKi8gLi4uYXJncykgPT4ge1xuXHRcdHZhciBwcmV2aW91c19jb21wb25lbnRfZnVuY3Rpb24gPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb247XG5cdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihjb21wb25lbnQpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBmbihub2RlLCAuLi5hcmdzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihwcmV2aW91c19jb21wb25lbnRfZnVuY3Rpb24pO1xuXHRcdH1cblx0fTtcblxuXHRwcmV2ZW50X3NuaXBwZXRfc3RyaW5naWZpY2F0aW9uKHNuaXBwZXQpO1xuXG5cdHJldHVybiBzbmlwcGV0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNuaXBwZXQgcHJvZ3JhbW1hdGljYWxseVxuICogQHRlbXBsYXRlIHt1bmtub3duW119IFBhcmFtc1xuICogQHBhcmFtIHsoLi4ucGFyYW1zOiBHZXR0ZXJzPFBhcmFtcz4pID0+IHtcbiAqICAgcmVuZGVyOiAoKSA9PiBzdHJpbmdcbiAqICAgc2V0dXA/OiAoZWxlbWVudDogRWxlbWVudCkgPT4gdm9pZCB8ICgoKSA9PiB2b2lkKVxuICogfX0gZm5cbiAqIEByZXR1cm5zIHtTbmlwcGV0PFBhcmFtcz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYXdTbmlwcGV0KGZuKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHR5cGVzIGFyZSBhIGxpZVxuXHRyZXR1cm4gKC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyBhbmNob3IsIC8qKiBAdHlwZSB7R2V0dGVyczxQYXJhbXM+fSAqLyAuLi5wYXJhbXMpID0+IHtcblx0XHR2YXIgc25pcHBldCA9IGZuKC4uLnBhcmFtcyk7XG5cblx0XHQvKiogQHR5cGUge0VsZW1lbnR9ICovXG5cdFx0dmFyIGVsZW1lbnQ7XG5cblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRlbGVtZW50ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaHRtbCA9IHNuaXBwZXQucmVuZGVyKCkudHJpbSgpO1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50X2Zyb21faHRtbChodG1sKTtcblx0XHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChnZXRfZmlyc3RfY2hpbGQoZnJhZ21lbnQpKTtcblxuXHRcdFx0aWYgKERFViAmJiAoZ2V0X25leHRfc2libGluZyhlbGVtZW50KSAhPT0gbnVsbCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUpKSB7XG5cdFx0XHRcdHcuaW52YWxpZF9yYXdfc25pcHBldF9yZW5kZXIoKTtcblx0XHRcdH1cblxuXHRcdFx0YW5jaG9yLmJlZm9yZShlbGVtZW50KTtcblx0XHR9XG5cblx0XHRjb25zdCByZXN1bHQgPSBzbmlwcGV0LnNldHVwPy4oZWxlbWVudCk7XG5cdFx0YXNzaWduX25vZGVzKGVsZW1lbnQsIGVsZW1lbnQpO1xuXG5cdFx0aWYgKHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRlYXJkb3duKHJlc3VsdCk7XG5cdFx0fVxuXHR9O1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dCwgQ29tcG9uZW50Q29udGV4dExlZ2FjeSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vaW5kZXguanMnICovXG4vKiogQGltcG9ydCB7IE5vdEZ1bmN0aW9uIH0gZnJvbSAnLi9pbnRlcm5hbC90eXBlcy5qcycgKi9cbmltcG9ydCB7IGFjdGl2ZV9yZWFjdGlvbiwgdW50cmFjayB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgaXNfYXJyYXkgfSBmcm9tICcuL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyB1c2VyX2VmZmVjdCB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L2luZGV4LmpzJztcbmltcG9ydCAqIGFzIGUgZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvZXJyb3JzLmpzJztcbmltcG9ydCB7IGxlZ2FjeV9tb2RlX2ZsYWcgfSBmcm9tICcuL2ludGVybmFsL2ZsYWdzL2luZGV4LmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvY29udGV4dC5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcblxuaWYgKERFVikge1xuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJ1bmVcblx0ICovXG5cdGZ1bmN0aW9uIHRocm93X3J1bmVfZXJyb3IocnVuZSkge1xuXHRcdGlmICghKHJ1bmUgaW4gZ2xvYmFsVGhpcykpIHtcblx0XHRcdC8vIFRPRE8gaWYgcGVvcGxlIHN0YXJ0IGFkanVzdGluZyB0aGUgXCJ0aGlzIGNhbiBjb250YWluIHJ1bmVzXCIgY29uZmlnIHRocm91Z2ggdi1wLXMgbW9yZSwgYWRqdXN0IHRoaXMgbWVzc2FnZVxuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0XHRsZXQgdmFsdWU7IC8vIGxldCdzIGhvcGUgbm9vbmUgbW9kaWZpZXMgdGhpcyBnbG9iYWwsIGJ1dCBiZWx0cyBhbmQgYnJhY2VzXG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgcnVuZSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBnZXR0ZXItcmV0dXJuXG5cdFx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZS5ydW5lX291dHNpZGVfc3ZlbHRlKHJ1bmUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6ICh2KSA9PiB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR0aHJvd19ydW5lX2Vycm9yKCckc3RhdGUnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGVmZmVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckZGVyaXZlZCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckaW5zcGVjdCcpO1xuXHR0aHJvd19ydW5lX2Vycm9yKCckcHJvcHMnKTtcblx0dGhyb3dfcnVuZV9lcnJvcignJGJpbmRhYmxlJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBbYEFib3J0U2lnbmFsYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsKSB0aGF0IGFib3J0cyB3aGVuIHRoZSBjdXJyZW50IFtkZXJpdmVkXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGRlcml2ZWQpIG9yIFtlZmZlY3RdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0KSByZS1ydW5zIG9yIGlzIGRlc3Ryb3llZC5cbiAqXG4gKiBNdXN0IGJlIGNhbGxlZCB3aGlsZSBhIGRlcml2ZWQgb3IgZWZmZWN0IGlzIHJ1bm5pbmcuXG4gKlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0PlxuICogXHRpbXBvcnQgeyBnZXRBYm9ydFNpZ25hbCB9IGZyb20gJ3N2ZWx0ZSc7XG4gKlxuICogXHRsZXQgeyBpZCB9ID0gJHByb3BzKCk7XG4gKlxuICogXHRhc3luYyBmdW5jdGlvbiBnZXREYXRhKGlkKSB7XG4gKiBcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2l0ZW1zLyR7aWR9YCwge1xuICogXHRcdFx0c2lnbmFsOiBnZXRBYm9ydFNpZ25hbCgpXG4gKiBcdFx0fSk7XG4gKlxuICogXHRcdHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gKiBcdH1cbiAqXG4gKiBcdGNvbnN0IGRhdGEgPSAkZGVyaXZlZChhd2FpdCBnZXREYXRhKGlkKSk7XG4gKiA8L3NjcmlwdD5cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWJvcnRTaWduYWwoKSB7XG5cdGlmIChhY3RpdmVfcmVhY3Rpb24gPT09IG51bGwpIHtcblx0XHRlLmdldF9hYm9ydF9zaWduYWxfb3V0c2lkZV9yZWFjdGlvbigpO1xuXHR9XG5cblx0cmV0dXJuIChhY3RpdmVfcmVhY3Rpb24uYWMgPz89IG5ldyBBYm9ydENvbnRyb2xsZXIoKSkuc2lnbmFsO1xufVxuXG4vKipcbiAqIGBvbk1vdW50YCwgbGlrZSBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCksIHNjaGVkdWxlcyBhIGZ1bmN0aW9uIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogVW5saWtlIGAkZWZmZWN0YCwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIG9ubHkgcnVucyBvbmNlLlxuICpcbiAqIEl0IG11c3QgYmUgY2FsbGVkIGR1cmluZyB0aGUgY29tcG9uZW50J3MgaW5pdGlhbGlzYXRpb24gKGJ1dCBkb2Vzbid0IG5lZWQgdG8gbGl2ZSBfaW5zaWRlXyB0aGUgY29tcG9uZW50O1xuICogaXQgY2FuIGJlIGNhbGxlZCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZSkuIElmIGEgZnVuY3Rpb24gaXMgcmV0dXJuZWQgX3N5bmNocm9ub3VzbHlfIGZyb20gYG9uTW91bnRgLFxuICogaXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBgb25Nb3VudGAgZnVuY3Rpb25zIGRvIG5vdCBydW4gZHVyaW5nIFtzZXJ2ZXItc2lkZSByZW5kZXJpbmddKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS9zdmVsdGUtc2VydmVyI3JlbmRlcikuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7KCkgPT4gTm90RnVuY3Rpb248VD4gfCBQcm9taXNlPE5vdEZ1bmN0aW9uPFQ+PiB8ICgoKSA9PiBhbnkpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1vdW50KGZuKSB7XG5cdGlmIChjb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdvbk1vdW50Jyk7XG5cdH1cblxuXHRpZiAobGVnYWN5X21vZGVfZmxhZyAmJiBjb21wb25lbnRfY29udGV4dC5sICE9PSBudWxsKSB7XG5cdFx0aW5pdF91cGRhdGVfY2FsbGJhY2tzKGNvbXBvbmVudF9jb250ZXh0KS5tLnB1c2goZm4pO1xuXHR9IGVsc2Uge1xuXHRcdHVzZXJfZWZmZWN0KCgpID0+IHtcblx0XHRcdGNvbnN0IGNsZWFudXAgPSB1bnRyYWNrKGZuKTtcblx0XHRcdGlmICh0eXBlb2YgY2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIC8qKiBAdHlwZSB7KCkgPT4gdm9pZH0gKi8gKGNsZWFudXApO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcblx0aWYgKGNvbXBvbmVudF9jb250ZXh0ID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfb3V0c2lkZV9jb21wb25lbnQoJ29uRGVzdHJveScpO1xuXHR9XG5cblx0b25Nb3VudCgoKSA9PiAoKSA9PiB1bnRyYWNrKGZuKSk7XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFtUPWFueV1cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1R9IFtkZXRhaWxdXG4gKiBAcGFyYW0ge2FueX1wYXJhbXNfMFxuICogQHJldHVybnMge0N1c3RvbUV2ZW50PFQ+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVfY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcblx0cmV0dXJuIG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGV2ZW50IGRpc3BhdGNoZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwYXRjaCBbY29tcG9uZW50IGV2ZW50c10oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL2xlZ2FjeS1vbiNDb21wb25lbnQtZXZlbnRzKS5cbiAqIEV2ZW50IGRpc3BhdGNoZXJzIGFyZSBmdW5jdGlvbnMgdGhhdCBjYW4gdGFrZSB0d28gYXJndW1lbnRzOiBgbmFtZWAgYW5kIGBkZXRhaWxgLlxuICpcbiAqIENvbXBvbmVudCBldmVudHMgY3JlYXRlZCB3aXRoIGBjcmVhdGVFdmVudERpc3BhdGNoZXJgIGNyZWF0ZSBhXG4gKiBbQ3VzdG9tRXZlbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudCkuXG4gKiBUaGVzZSBldmVudHMgZG8gbm90IFtidWJibGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvTGVhcm4vSmF2YVNjcmlwdC9CdWlsZGluZ19ibG9ja3MvRXZlbnRzI0V2ZW50X2J1YmJsaW5nX2FuZF9jYXB0dXJlKS5cbiAqIFRoZSBgZGV0YWlsYCBhcmd1bWVudCBjb3JyZXNwb25kcyB0byB0aGUgW0N1c3RvbUV2ZW50LmRldGFpbF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L2RldGFpbClcbiAqIHByb3BlcnR5IGFuZCBjYW4gY29udGFpbiBhbnkgdHlwZSBvZiBkYXRhLlxuICpcbiAqIFRoZSBldmVudCBkaXNwYXRjaGVyIGNhbiBiZSB0eXBlZCB0byBuYXJyb3cgdGhlIGFsbG93ZWQgZXZlbnQgbmFtZXMgYW5kIHRoZSB0eXBlIG9mIHRoZSBgZGV0YWlsYCBhcmd1bWVudDpcbiAqIGBgYHRzXG4gKiBjb25zdCBkaXNwYXRjaCA9IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcjx7XG4gKiAgbG9hZGVkOiBudWxsOyAvLyBkb2VzIG5vdCB0YWtlIGEgZGV0YWlsIGFyZ3VtZW50XG4gKiAgY2hhbmdlOiBzdHJpbmc7IC8vIHRha2VzIGEgZGV0YWlsIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nLCB3aGljaCBpcyByZXF1aXJlZFxuICogIG9wdGlvbmFsOiBudW1iZXIgfCBudWxsOyAvLyB0YWtlcyBhbiBvcHRpb25hbCBkZXRhaWwgYXJndW1lbnQgb2YgdHlwZSBudW1iZXJcbiAqIH0+KCk7XG4gKiBgYGBcbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgY2FsbGJhY2sgcHJvcHMgYW5kL29yIHRoZSBgJGhvc3QoKWAgcnVuZSBpbnN0ZWFkIFx1MjAxNCBzZWUgW21pZ3JhdGlvbiBndWlkZV0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3Y1LW1pZ3JhdGlvbi1ndWlkZSNFdmVudC1jaGFuZ2VzLUNvbXBvbmVudC1ldmVudHMpXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFtFdmVudE1hcCA9IGFueV1cbiAqIEByZXR1cm5zIHtFdmVudERpc3BhdGNoZXI8RXZlbnRNYXA+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuXHRjb25zdCBhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdjcmVhdGVFdmVudERpc3BhdGNoZXInKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gW2RldGFpbF1cblx0ICogQHBhcmFtIFtvcHRpb25zXVxuXHQgKi9cblx0cmV0dXJuICh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpID0+IHtcblx0XHRjb25zdCBldmVudHMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIEZ1bmN0aW9uIHwgRnVuY3Rpb25bXT59ICovIChcblx0XHRcdGFjdGl2ZV9jb21wb25lbnRfY29udGV4dC5zLiQkZXZlbnRzXG5cdFx0KT8uWy8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodHlwZSldO1xuXG5cdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2tzID0gaXNfYXJyYXkoZXZlbnRzKSA/IGV2ZW50cy5zbGljZSgpIDogW2V2ZW50c107XG5cdFx0XHQvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG5cdFx0XHQvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG5cdFx0XHRjb25zdCBldmVudCA9IGNyZWF0ZV9jdXN0b21fZXZlbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0eXBlKSwgZGV0YWlsLCBvcHRpb25zKTtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGZuLmNhbGwoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LngsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcbn1cblxuLy8gVE9ETyBtYXJrIGJlZm9yZVVwZGF0ZSBhbmQgYWZ0ZXJVcGRhdGUgYXMgZGVwcmVjYXRlZCBpbiBTdmVsdGUgNlxuXG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0LnByZWAgaW5zdGVhZC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgW2AkZWZmZWN0LnByZWBdKGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzL3N2ZWx0ZS8kZWZmZWN0IyRlZmZlY3QucHJlKSBpbnN0ZWFkXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYmVmb3JlVXBkYXRlJyk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50X2NvbnRleHQubCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX2xlZ2FjeV9vbmx5KCdiZWZvcmVVcGRhdGUnKTtcblx0fVxuXG5cdGluaXRfdXBkYXRlX2NhbGxiYWNrcyhjb21wb25lbnRfY29udGV4dCkuYi5wdXNoKGZuKTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgYmVlbiB1cGRhdGVkLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBydW5zIHdpbGwgYmUgYWZ0ZXIgdGhlIGluaXRpYWwgYG9uTW91bnRgLlxuICpcbiAqIEluIHJ1bmVzIG1vZGUgdXNlIGAkZWZmZWN0YCBpbnN0ZWFkLlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBbYCRlZmZlY3RgXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvJGVmZmVjdCkgaW5zdGVhZFxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuXHRpZiAoY29tcG9uZW50X2NvbnRleHQgPT09IG51bGwpIHtcblx0XHRlLmxpZmVjeWNsZV9vdXRzaWRlX2NvbXBvbmVudCgnYWZ0ZXJVcGRhdGUnKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRfY29udGV4dC5sID09PSBudWxsKSB7XG5cdFx0ZS5saWZlY3ljbGVfbGVnYWN5X29ubHkoJ2FmdGVyVXBkYXRlJyk7XG5cdH1cblxuXHRpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29tcG9uZW50X2NvbnRleHQpLmEucHVzaChmbik7XG59XG5cbi8qKlxuICogTGVnYWN5LW1vZGU6IEluaXQgY2FsbGJhY2tzIG9iamVjdCBmb3Igb25Nb3VudC9iZWZvcmVVcGRhdGUvYWZ0ZXJVcGRhdGVcbiAqIEBwYXJhbSB7Q29tcG9uZW50Q29udGV4dH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBpbml0X3VwZGF0ZV9jYWxsYmFja3MoY29udGV4dCkge1xuXHR2YXIgbCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbnRleHQpLmw7XG5cdHJldHVybiAobC51ID8/PSB7IGE6IFtdLCBiOiBbXSwgbTogW10gfSk7XG59XG5cbmV4cG9ydCB7IGZsdXNoU3luYyB9IGZyb20gJy4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuZXhwb3J0IHsgZ2V0Q29udGV4dCwgZ2V0QWxsQ29udGV4dHMsIGhhc0NvbnRleHQsIHNldENvbnRleHQgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9jb250ZXh0LmpzJztcbmV4cG9ydCB7IGh5ZHJhdGUsIG1vdW50LCB1bm1vdW50IH0gZnJvbSAnLi9pbnRlcm5hbC9jbGllbnQvcmVuZGVyLmpzJztcbmV4cG9ydCB7IHRpY2ssIHVudHJhY2ssIHNldHRsZWQgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9ydW50aW1lLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVJhd1NuaXBwZXQgfSBmcm9tICcuL2ludGVybmFsL2NsaWVudC9kb20vYmxvY2tzL3NuaXBwZXQuanMnO1xuIiwgIi8qKiBAaW1wb3J0IHsgQWN0aW9uLCBBY3Rpb25SZXR1cm4gfSBmcm9tICcuLi9hY3Rpb24vcHVibGljJyAqL1xuLyoqIEBpbXBvcnQgeyBBdHRhY2htZW50IH0gZnJvbSAnLi9wdWJsaWMnICovXG5pbXBvcnQgeyBub29wLCByZW5kZXJfZWZmZWN0IH0gZnJvbSAnc3ZlbHRlL2ludGVybmFsL2NsaWVudCc7XG5pbXBvcnQgeyBBVFRBQ0hNRU5UX0tFWSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vaW5kZXgtY2xpZW50LmpzJztcbmltcG9ydCB7IHRlYXJkb3duIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qga2V5IHRoYXQgd2lsbCBiZSByZWNvZ25pc2VkIGFzIGFuIGF0dGFjaG1lbnQgd2hlbiB0aGUgb2JqZWN0IGlzIHNwcmVhZCBvbnRvIGFuIGVsZW1lbnQsXG4gKiBhcyBhIHByb2dyYW1tYXRpYyBhbHRlcm5hdGl2ZSB0byB1c2luZyBge0BhdHRhY2ggLi4ufWAuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgbGlicmFyeSBhdXRob3JzLCB0aG91Z2hcbiAqIGlzIGdlbmVyYWxseSBub3QgbmVlZGVkIHdoZW4gYnVpbGRpbmcgYW4gYXBwLlxuICpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdD5cbiAqIFx0aW1wb3J0IHsgY3JlYXRlQXR0YWNobWVudEtleSB9IGZyb20gJ3N2ZWx0ZS9hdHRhY2htZW50cyc7XG4gKlxuICogXHRjb25zdCBwcm9wcyA9IHtcbiAqIFx0XHRjbGFzczogJ2Nvb2wnLFxuICogXHRcdG9uY2xpY2s6ICgpID0+IGFsZXJ0KCdjbGlja2VkJyksXG4gKiBcdFx0W2NyZWF0ZUF0dGFjaG1lbnRLZXkoKV06IChub2RlKSA9PiB7XG4gKiBcdFx0XHRub2RlLnRleHRDb250ZW50ID0gJ2F0dGFjaGVkISc7XG4gKiBcdFx0fVxuICogXHR9O1xuICogPC9zY3JpcHQ+XG4gKlxuICogPGJ1dHRvbiB7Li4ucHJvcHN9PmNsaWNrIG1lPC9idXR0b24+XG4gKiBgYGBcbiAqIEBzaW5jZSA1LjI5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBdHRhY2htZW50S2V5KCkge1xuXHRyZXR1cm4gU3ltYm9sKEFUVEFDSE1FTlRfS0VZKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBbYWN0aW9uXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdXNlKSBpbnRvIGFuIFthdHRhY2htZW50XShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvQGF0dGFjaCkga2VlcGluZyB0aGUgc2FtZSBiZWhhdmlvci5cbiAqIEl0J3MgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHN0YXJ0IHVzaW5nIGF0dGFjaG1lbnRzIG9uIGNvbXBvbmVudHMgYnV0IHlvdSBoYXZlIGFjdGlvbnMgcHJvdmlkZWQgYnkgYSBsaWJyYXJ5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgX3JldHVybnNfIHRoZSBhcmd1bWVudCB0byB0aGVcbiAqIGFjdGlvbiBmdW5jdGlvbiwgbm90IHRoZSBhcmd1bWVudCBpdHNlbGYuXG4gKlxuICogYGBgc3ZlbHRlXG4gKiA8IS0tIHdpdGggYW4gYWN0aW9uIC0tPlxuICogPGRpdiB1c2U6Zm9vPXtiYXJ9Pi4uLjwvZGl2PlxuICpcbiAqIDwhLS0gd2l0aCBhbiBhdHRhY2htZW50IC0tPlxuICogPGRpdiB7QGF0dGFjaCBmcm9tQWN0aW9uKGZvbywgKCkgPT4gYmFyKX0+Li4uPC9kaXY+XG4gKiBgYGBcbiAqIEB0ZW1wbGF0ZSB7RXZlbnRUYXJnZXR9IEVcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bn0gVFxuICogQG92ZXJsb2FkXG4gKiBAcGFyYW0ge0FjdGlvbjxFLCBUPiB8ICgoZWxlbWVudDogRSwgYXJnOiBUKSA9PiB2b2lkIHwgQWN0aW9uUmV0dXJuPFQ+KX0gYWN0aW9uIFRoZSBhY3Rpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGFyZ3VtZW50IGZvciB0aGUgYWN0aW9uXG4gKiBAcmV0dXJucyB7QXR0YWNobWVudDxFPn1cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBbYWN0aW9uXShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvdXNlKSBpbnRvIGFuIFthdHRhY2htZW50XShodHRwczovL3N2ZWx0ZS5kZXYvZG9jcy9zdmVsdGUvQGF0dGFjaCkga2VlcGluZyB0aGUgc2FtZSBiZWhhdmlvci5cbiAqIEl0J3MgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHN0YXJ0IHVzaW5nIGF0dGFjaG1lbnRzIG9uIGNvbXBvbmVudHMgYnV0IHlvdSBoYXZlIGFjdGlvbnMgcHJvdmlkZWQgYnkgYSBsaWJyYXJ5LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgX3JldHVybnNfIHRoZSBhcmd1bWVudCB0byB0aGVcbiAqIGFjdGlvbiBmdW5jdGlvbiwgbm90IHRoZSBhcmd1bWVudCBpdHNlbGYuXG4gKlxuICogYGBgc3ZlbHRlXG4gKiA8IS0tIHdpdGggYW4gYWN0aW9uIC0tPlxuICogPGRpdiB1c2U6Zm9vPXtiYXJ9Pi4uLjwvZGl2PlxuICpcbiAqIDwhLS0gd2l0aCBhbiBhdHRhY2htZW50IC0tPlxuICogPGRpdiB7QGF0dGFjaCBmcm9tQWN0aW9uKGZvbywgKCkgPT4gYmFyKX0+Li4uPC9kaXY+XG4gKiBgYGBcbiAqIEB0ZW1wbGF0ZSB7RXZlbnRUYXJnZXR9IEVcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtBY3Rpb248RSwgdm9pZD4gfCAoKGVsZW1lbnQ6IEUpID0+IHZvaWQgfCBBY3Rpb25SZXR1cm48dm9pZD4pfSBhY3Rpb24gVGhlIGFjdGlvbiBmdW5jdGlvblxuICogQHJldHVybnMge0F0dGFjaG1lbnQ8RT59XG4gKi9cbi8qKlxuICogQ29udmVydHMgYW4gW2FjdGlvbl0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL3VzZSkgaW50byBhbiBbYXR0YWNobWVudF0oaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3Mvc3ZlbHRlL0BhdHRhY2gpIGtlZXBpbmcgdGhlIHNhbWUgYmVoYXZpb3IuXG4gKiBJdCdzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBzdGFydCB1c2luZyBhdHRhY2htZW50cyBvbiBjb21wb25lbnRzIGJ1dCB5b3UgaGF2ZSBhY3Rpb25zIHByb3ZpZGVkIGJ5IGEgbGlicmFyeS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IF9yZXR1cm5zXyB0aGUgYXJndW1lbnQgdG8gdGhlXG4gKiBhY3Rpb24gZnVuY3Rpb24sIG5vdCB0aGUgYXJndW1lbnQgaXRzZWxmLlxuICpcbiAqIGBgYHN2ZWx0ZVxuICogPCEtLSB3aXRoIGFuIGFjdGlvbiAtLT5cbiAqIDxkaXYgdXNlOmZvbz17YmFyfT4uLi48L2Rpdj5cbiAqXG4gKiA8IS0tIHdpdGggYW4gYXR0YWNobWVudCAtLT5cbiAqIDxkaXYge0BhdHRhY2ggZnJvbUFjdGlvbihmb28sICgpID0+IGJhcil9Pi4uLjwvZGl2PlxuICogYGBgXG4gKlxuICogQHRlbXBsYXRlIHtFdmVudFRhcmdldH0gRVxuICogQHRlbXBsYXRlIHt1bmtub3dufSBUXG4gKiBAcGFyYW0ge0FjdGlvbjxFLCBUPiB8ICgoZWxlbWVudDogRSwgYXJnOiBUKSA9PiB2b2lkIHwgQWN0aW9uUmV0dXJuPFQ+KX0gYWN0aW9uIFRoZSBhY3Rpb24gZnVuY3Rpb25cbiAqIEBwYXJhbSB7KCkgPT4gVH0gZm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGFyZ3VtZW50IGZvciB0aGUgYWN0aW9uXG4gKiBAcmV0dXJucyB7QXR0YWNobWVudDxFPn1cbiAqIEBzaW5jZSA1LjMyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWN0aW9uKGFjdGlvbiwgZm4gPSAvKiogQHR5cGUgeygpID0+IFR9ICovIChub29wKSkge1xuXHRyZXR1cm4gKGVsZW1lbnQpID0+IHtcblx0XHRjb25zdCB7IHVwZGF0ZSwgZGVzdHJveSB9ID0gdW50cmFjaygoKSA9PiBhY3Rpb24oZWxlbWVudCwgZm4oKSkgPz8ge30pO1xuXG5cdFx0aWYgKHVwZGF0ZSkge1xuXHRcdFx0dmFyIHJhbiA9IGZhbHNlO1xuXHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IGFyZyA9IGZuKCk7XG5cdFx0XHRcdGlmIChyYW4pIHVwZGF0ZShhcmcpO1xuXHRcdFx0fSk7XG5cdFx0XHRyYW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChkZXN0cm95KSB7XG5cdFx0XHR0ZWFyZG93bihkZXN0cm95KTtcblx0XHR9XG5cdH07XG59XG4iLCAiaW1wb3J0IHsgc2FuaXRpemVfbG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4uL3dhcm5pbmdzLmpzJztcblxuLyoqXG4gKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIsIHByb3BlcnR5LCBsb2NhdGlvbikge1xuXHRpZiAoYSAhPT0gYikge1xuXHRcdHcuYXNzaWdubWVudF92YWx1ZV9zdGFsZShwcm9wZXJ0eSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovIChzYW5pdGl6ZV9sb2NhdGlvbihsb2NhdGlvbikpKTtcblx0fVxuXG5cdHJldHVybiBhO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgbG9jYXRpb24pIHtcblx0cmV0dXJuIGNvbXBhcmUoXG5cdFx0KG9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZSksXG5cdFx0dW50cmFjaygoKSA9PiBvYmplY3RbcHJvcGVydHldKSxcblx0XHRwcm9wZXJ0eSxcblx0XHRsb2NhdGlvblxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbl9hbmQob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIGxvY2F0aW9uKSB7XG5cdHJldHVybiBjb21wYXJlKFxuXHRcdChvYmplY3RbcHJvcGVydHldICYmPSB2YWx1ZSksXG5cdFx0dW50cmFjaygoKSA9PiBvYmplY3RbcHJvcGVydHldKSxcblx0XHRwcm9wZXJ0eSxcblx0XHRsb2NhdGlvblxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbl9vcihvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgbG9jYXRpb24pIHtcblx0cmV0dXJuIGNvbXBhcmUoXG5cdFx0KG9iamVjdFtwcm9wZXJ0eV0gfHw9IHZhbHVlKSxcblx0XHR1bnRyYWNrKCgpID0+IG9iamVjdFtwcm9wZXJ0eV0pLFxuXHRcdHByb3BlcnR5LFxuXHRcdGxvY2F0aW9uXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduX251bGxpc2gob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIGxvY2F0aW9uKSB7XG5cdHJldHVybiBjb21wYXJlKFxuXHRcdChvYmplY3RbcHJvcGVydHldID8/PSB2YWx1ZSksXG5cdFx0dW50cmFjaygoKSA9PiBvYmplY3RbcHJvcGVydHldKSxcblx0XHRwcm9wZXJ0eSxcblx0XHRsb2NhdGlvblxuXHQpO1xufVxuIiwgIi8qKiBAdHlwZSB7TWFwPFN0cmluZywgU2V0PEhUTUxTdHlsZUVsZW1lbnQ+Pn0gKi9cbnZhciBhbGxfc3R5bGVzID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcl9zdHlsZShoYXNoLCBzdHlsZSkge1xuXHR2YXIgc3R5bGVzID0gYWxsX3N0eWxlcy5nZXQoaGFzaCk7XG5cblx0aWYgKCFzdHlsZXMpIHtcblx0XHRzdHlsZXMgPSBuZXcgU2V0KCk7XG5cdFx0YWxsX3N0eWxlcy5zZXQoaGFzaCwgc3R5bGVzKTtcblx0fVxuXG5cdHN0eWxlcy5hZGQoc3R5bGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwX3N0eWxlcyhoYXNoKSB7XG5cdHZhciBzdHlsZXMgPSBhbGxfc3R5bGVzLmdldChoYXNoKTtcblx0aWYgKCFzdHlsZXMpIHJldHVybjtcblxuXHRmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuXHRcdHN0eWxlLnJlbW92ZSgpO1xuXHR9XG5cblx0YWxsX3N0eWxlcy5kZWxldGUoaGFzaCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTb3VyY2VMb2NhdGlvbiB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBDT01NRU5UX05PREUsIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUsIEVMRU1FTlRfTk9ERSB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IEhZRFJBVElPTl9FTkQsIEhZRFJBVElPTl9TVEFSVCwgSFlEUkFUSU9OX1NUQVJUX0VMU0UgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vZG9tL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBkZXZfc3RhY2sgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gZm5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHBhcmFtIHtTb3VyY2VMb2NhdGlvbltdfSBsb2NhdGlvbnNcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfbG9jYXRpb25zKGZuLCBmaWxlbmFtZSwgbG9jYXRpb25zKSB7XG5cdHJldHVybiAoLyoqIEB0eXBlIHthbnlbXX0gKi8gLi4uYXJncykgPT4ge1xuXHRcdGNvbnN0IGRvbSA9IGZuKC4uLmFyZ3MpO1xuXG5cdFx0dmFyIG5vZGUgPSBoeWRyYXRpbmcgPyBkb20gOiBkb20ubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPyBkb20uZmlyc3RDaGlsZCA6IGRvbTtcblx0XHRhc3NpZ25fbG9jYXRpb25zKG5vZGUsIGZpbGVuYW1lLCBsb2NhdGlvbnMpO1xuXG5cdFx0cmV0dXJuIGRvbTtcblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHBhcmFtIHtTb3VyY2VMb2NhdGlvbn0gbG9jYXRpb25cbiAqL1xuZnVuY3Rpb24gYXNzaWduX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGVuYW1lLCBsb2NhdGlvbikge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcblx0XHRwYXJlbnQ6IGRldl9zdGFjayxcblx0XHRsb2M6IHsgZmlsZTogZmlsZW5hbWUsIGxpbmU6IGxvY2F0aW9uWzBdLCBjb2x1bW46IGxvY2F0aW9uWzFdIH1cblx0fTtcblxuXHRpZiAobG9jYXRpb25bMl0pIHtcblx0XHRhc3NpZ25fbG9jYXRpb25zKGVsZW1lbnQuZmlyc3RDaGlsZCwgZmlsZW5hbWUsIGxvY2F0aW9uWzJdKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZSB8IG51bGx9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHBhcmFtIHtTb3VyY2VMb2NhdGlvbltdfSBsb2NhdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXNzaWduX2xvY2F0aW9ucyhub2RlLCBmaWxlbmFtZSwgbG9jYXRpb25zKSB7XG5cdHZhciBpID0gMDtcblx0dmFyIGRlcHRoID0gMDtcblxuXHR3aGlsZSAobm9kZSAmJiBpIDwgbG9jYXRpb25zLmxlbmd0aCkge1xuXHRcdGlmIChoeWRyYXRpbmcgJiYgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG5cdFx0XHR2YXIgY29tbWVudCA9IC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpO1xuXHRcdFx0aWYgKGNvbW1lbnQuZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUIHx8IGNvbW1lbnQuZGF0YSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0UpIGRlcHRoICs9IDE7XG5cdFx0XHRlbHNlIGlmIChjb21tZW50LmRhdGFbMF0gPT09IEhZRFJBVElPTl9FTkQpIGRlcHRoIC09IDE7XG5cdFx0fVxuXG5cdFx0aWYgKGRlcHRoID09PSAwICYmIG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuXHRcdFx0YXNzaWduX2xvY2F0aW9uKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUpLCBmaWxlbmFtZSwgbG9jYXRpb25zW2krK10pO1xuXHRcdH1cblxuXHRcdG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBTb3VyY2UsIEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEZJTEVOQU1FLCBITVIgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5UIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgaHlkcmF0ZV9ub2RlLCBoeWRyYXRpbmcgfSBmcm9tICcuLi9kb20vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIGRlc3Ryb3lfZWZmZWN0IH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHNvdXJjZSB9IGZyb20gJy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBzZXRfc2hvdWxkX2ludHJvIH0gZnJvbSAnLi4vcmVuZGVyLmpzJztcbmltcG9ydCB7IGdldCB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7KGFuY2hvcjogQ29tbWVudCwgcHJvcHM6IGFueSkgPT4gYW55fSBDb21wb25lbnRcbiAqIEBwYXJhbSB7Q29tcG9uZW50fSBvcmlnaW5hbFxuICogQHBhcmFtIHsoKSA9PiBTb3VyY2U8Q29tcG9uZW50Pn0gZ2V0X3NvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaG1yKG9yaWdpbmFsLCBnZXRfc291cmNlKSB7XG5cdC8qKlxuXHQgKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gYW5jaG9yXG5cdCAqIEBwYXJhbSB7YW55fSBwcm9wc1xuXHQgKi9cblx0ZnVuY3Rpb24gd3JhcHBlcihhbmNob3IsIHByb3BzKSB7XG5cdFx0bGV0IGluc3RhbmNlID0ge307XG5cblx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi9cblx0XHRsZXQgZWZmZWN0O1xuXG5cdFx0bGV0IHJhbiA9IGZhbHNlO1xuXG5cdFx0YmxvY2soKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc291cmNlID0gZ2V0X3NvdXJjZSgpO1xuXHRcdFx0Y29uc3QgY29tcG9uZW50ID0gZ2V0KHNvdXJjZSk7XG5cblx0XHRcdGlmIChlZmZlY3QpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRmb3IgKHZhciBrIGluIGluc3RhbmNlKSBkZWxldGUgaW5zdGFuY2Vba107XG5cdFx0XHRcdGRlc3Ryb3lfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHR9XG5cblx0XHRcdGVmZmVjdCA9IGJyYW5jaCgoKSA9PiB7XG5cdFx0XHRcdC8vIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbnZhbGlkYXRlZCwgcmVwbGFjZSBpdCB3aXRob3V0IHRyYW5zaXRpb25zXG5cdFx0XHRcdGlmIChyYW4pIHNldF9zaG91bGRfaW50cm8oZmFsc2UpO1xuXG5cdFx0XHRcdC8vIHByZXNlcnZlIGdldHRlcnMvc2V0dGVyc1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcblx0XHRcdFx0XHRpbnN0YW5jZSxcblx0XHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhcblx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRcdG5ldy50YXJnZXQgPyBuZXcgY29tcG9uZW50KGFuY2hvciwgcHJvcHMpIDogY29tcG9uZW50KGFuY2hvciwgcHJvcHMpXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChyYW4pIHNldF9zaG91bGRfaW50cm8odHJ1ZSk7XG5cdFx0XHR9KTtcblx0XHR9LCBFRkZFQ1RfVFJBTlNQQVJFTlQpO1xuXG5cdFx0cmFuID0gdHJ1ZTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHdyYXBwZXJbRklMRU5BTUVdID0gb3JpZ2luYWxbRklMRU5BTUVdO1xuXG5cdC8vIEB0cy1pZ25vcmVcblx0d3JhcHBlcltITVJdID0ge1xuXHRcdC8vIFdoZW4gd2UgYWNjZXB0IGFuIHVwZGF0ZSwgd2Ugc2V0IHRoZSBvcmlnaW5hbCBzb3VyY2UgdG8gdGhlIG5ldyBjb21wb25lbnRcblx0XHRvcmlnaW5hbCxcblx0XHQvLyBUaGUgYGdldF9zb3VyY2VgIHBhcmFtZXRlciByZWFkcyBgd3JhcHBlcltITVJdLnNvdXJjZWAsIGJ1dCBpbiB0aGUgYGFjY2VwdGBcblx0XHQvLyBmdW5jdGlvbiB3ZSBhbHdheXMgcmVwbGFjZSBpdCB3aXRoIGBwcmV2aW91c1tITVJdLnNvdXJjZWAsIHdoaWNoIGluIHByYWN0aWNlXG5cdFx0Ly8gbWVhbnMgd2Ugb25seSBldmVyIHVwZGF0ZSB0aGUgb3JpZ2luYWxcblx0XHRzb3VyY2U6IHNvdXJjZShvcmlnaW5hbClcblx0fTtcblxuXHRyZXR1cm4gd3JhcHBlcjtcbn1cbiIsICIvKiogQHR5cGVkZWYge3sgZmlsZTogc3RyaW5nLCBsaW5lOiBudW1iZXIsIGNvbHVtbjogbnVtYmVyIH19IExvY2F0aW9uICovXG5cbmltcG9ydCB7IGdldF9kZXNjcmlwdG9yIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCB7IExFR0FDWV9QUk9QUywgU1RBVEVfU1lNQk9MIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0LmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgc2FuaXRpemVfbG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogU2V0cyB1cCBhIHZhbGlkYXRvciB0aGF0XG4gKiAtIHRyYXZlcnNlcyB0aGUgcGF0aCBvZiBhIHByb3AgdG8gZmluZCBvdXQgaWYgaXQgaXMgYWxsb3dlZCB0byBiZSBtdXRhdGVkXG4gKiAtIGNoZWNrcyB0aGF0IHRoZSBiaW5kaW5nIGNoYWluIGlzIG5vdCBpbnRlcnJ1cHRlZFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX293bmVyc2hpcF92YWxpZGF0b3IocHJvcHMpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uO1xuXHRjb25zdCBwYXJlbnQgPSBjb21wb25lbnRfY29udGV4dD8ucD8uZnVuY3Rpb247XG5cblx0cmV0dXJuIHtcblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuXHRcdCAqIEBwYXJhbSB7YW55W119IHBhdGhcblx0XHQgKiBAcGFyYW0ge2FueX0gcmVzdWx0XG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGxpbmVcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uXG5cdFx0ICovXG5cdFx0bXV0YXRpb246IChwcm9wLCBwYXRoLCByZXN1bHQsIGxpbmUsIGNvbHVtbikgPT4ge1xuXHRcdFx0Y29uc3QgbmFtZSA9IHBhdGhbMF07XG5cdFx0XHRpZiAoaXNfYm91bmRfb3JfdW5zZXQocHJvcHMsIG5hbWUpIHx8ICFwYXJlbnQpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0XHRsZXQgdmFsdWUgPSBwcm9wcztcblxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhdGhbaV1dO1xuXHRcdFx0XHRpZiAoIXZhbHVlPy5bU1RBVEVfU1lNQk9MXSkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbG9jYXRpb24gPSBzYW5pdGl6ZV9sb2NhdGlvbihgJHtjb21wb25lbnRbRklMRU5BTUVdfToke2xpbmV9OiR7Y29sdW1ufWApO1xuXG5cdFx0XHR3Lm93bmVyc2hpcF9pbnZhbGlkX211dGF0aW9uKG5hbWUsIGxvY2F0aW9uLCBwcm9wLCBwYXJlbnRbRklMRU5BTUVdKTtcblxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9LFxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7YW55fSBrZXlcblx0XHQgKiBAcGFyYW0ge2FueX0gY2hpbGRfY29tcG9uZW50XG5cdFx0ICogQHBhcmFtIHsoKSA9PiBhbnl9IHZhbHVlXG5cdFx0ICovXG5cdFx0YmluZGluZzogKGtleSwgY2hpbGRfY29tcG9uZW50LCB2YWx1ZSkgPT4ge1xuXHRcdFx0aWYgKCFpc19ib3VuZF9vcl91bnNldChwcm9wcywga2V5KSAmJiBwYXJlbnQgJiYgdmFsdWUoKT8uW1NUQVRFX1NZTUJPTF0pIHtcblx0XHRcdFx0dy5vd25lcnNoaXBfaW52YWxpZF9iaW5kaW5nKFxuXHRcdFx0XHRcdGNvbXBvbmVudFtGSUxFTkFNRV0sXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGNoaWxkX2NvbXBvbmVudFtGSUxFTkFNRV0sXG5cdFx0XHRcdFx0cGFyZW50W0ZJTEVOQU1FXVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcF9uYW1lXG4gKi9cbmZ1bmN0aW9uIGlzX2JvdW5kX29yX3Vuc2V0KHByb3BzLCBwcm9wX25hbWUpIHtcblx0Ly8gQ2FuIGJlIHRoZSBjYXNlIHdoZW4gc29tZW9uZSBkb2VzIGBtb3VudChDb21wb25lbnQsIHByb3BzKWAgd2l0aCBgbGV0IHByb3BzID0gJHN0YXRlKHsuLi59KWBcblx0Ly8gb3IgYGNyZWF0ZUNsYXNzQ29tcG9uZW50KENvbXBvbmVudCwgcHJvcHMpYFxuXHRjb25zdCBpc19lbnRyeV9wcm9wcyA9IFNUQVRFX1NZTUJPTCBpbiBwcm9wcyB8fCBMRUdBQ1lfUFJPUFMgaW4gcHJvcHM7XG5cdHJldHVybiAoXG5cdFx0ISFnZXRfZGVzY3JpcHRvcihwcm9wcywgcHJvcF9uYW1lKT8uc2V0IHx8XG5cdFx0KGlzX2VudHJ5X3Byb3BzICYmIHByb3BfbmFtZSBpbiBwcm9wcykgfHxcblx0XHQhKHByb3BfbmFtZSBpbiBwcm9wcylcblx0KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBlIGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgRklMRU5BTUUgfSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMuanMnO1xuXG4vKiogQHBhcmFtIHtGdW5jdGlvbiAmIHsgW0ZJTEVOQU1FXTogc3RyaW5nIH19IHRhcmdldCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrX3RhcmdldCh0YXJnZXQpIHtcblx0aWYgKHRhcmdldCkge1xuXHRcdGUuY29tcG9uZW50X2FwaV9pbnZhbGlkX25ldyh0YXJnZXRbRklMRU5BTUVdID8/ICdhIGNvbXBvbmVudCcsIHRhcmdldC5uYW1lKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGVnYWN5X2FwaSgpIHtcblx0Y29uc3QgY29tcG9uZW50ID0gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uO1xuXG5cdC8qKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kICovXG5cdGZ1bmN0aW9uIGVycm9yKG1ldGhvZCkge1xuXHRcdGUuY29tcG9uZW50X2FwaV9jaGFuZ2VkKG1ldGhvZCwgY29tcG9uZW50W0ZJTEVOQU1FXSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdCRkZXN0cm95OiAoKSA9PiBlcnJvcignJGRlc3Ryb3koKScpLFxuXHRcdCRvbjogKCkgPT4gZXJyb3IoJyRvbiguLi4pJyksXG5cdFx0JHNldDogKCkgPT4gZXJyb3IoJyRzZXQoLi4uKScpXG5cdH07XG59XG4iLCAiaW1wb3J0IHsgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBzbmFwc2hvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jbG9uZS5qcyc7XG5pbXBvcnQgeyBpbnNwZWN0X2VmZmVjdCwgcmVuZGVyX2VmZmVjdCwgdmFsaWRhdGVfZWZmZWN0IH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geygpID0+IGFueVtdfSBnZXRfdmFsdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbnNwZWN0b3JdXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdChnZXRfdmFsdWUsIGluc3BlY3RvciA9IGNvbnNvbGUubG9nKSB7XG5cdHZhbGlkYXRlX2VmZmVjdCgnJGluc3BlY3QnKTtcblxuXHRsZXQgaW5pdGlhbCA9IHRydWU7XG5cdGxldCBlcnJvciA9IC8qKiBAdHlwZSB7YW55fSAqLyAoVU5JTklUSUFMSVpFRCk7XG5cblx0Ly8gSW5zcGVjdCBlZmZlY3RzIHJ1bnMgc3luY2hyb25vdXNseSBzbyB0aGF0IHdlIGNhbiBjYXB0dXJlIHVzZWZ1bFxuXHQvLyBzdGFjayB0cmFjZXMuIEFzIGEgY29uc2VxdWVuY2UsIHJlYWRpbmcgdGhlIHZhbHVlIG1pZ2h0IHJlc3VsdFxuXHQvLyBpbiBhbiBlcnJvciAoYW4gYCRpbnNwZWN0KG9iamVjdC5wcm9wZXJ0eSlgIHdpbGwgcnVuIGJlZm9yZSB0aGVcblx0Ly8gYHsjaWYgb2JqZWN0fS4uLnsvaWZ9YCB0aGF0IGNvbnRhaW5zIGl0KVxuXHRpbnNwZWN0X2VmZmVjdCgoKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldF92YWx1ZSgpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGVycm9yID0gZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc25hcCA9IHNuYXBzaG90KHZhbHVlLCB0cnVlLCB0cnVlKTtcblx0XHR1bnRyYWNrKCgpID0+IHtcblx0XHRcdGluc3BlY3Rvcihpbml0aWFsID8gJ2luaXQnIDogJ3VwZGF0ZScsIC4uLnNuYXApO1xuXHRcdH0pO1xuXG5cdFx0aW5pdGlhbCA9IGZhbHNlO1xuXHR9KTtcblxuXHQvLyBJZiBhbiBlcnJvciBvY2N1cnMsIHdlIHN0b3JlIGl0IChhbG9uZyB3aXRoIGl0cyBzdGFjayB0cmFjZSkuXG5cdC8vIElmIHRoZSByZW5kZXIgZWZmZWN0IHN1YnNlcXVlbnRseSBydW5zLCB3ZSBsb2cgdGhlIGVycm9yLFxuXHQvLyBidXQgaWYgaXQgZG9lc24ndCBydW4gaXQncyBiZWNhdXNlIHRoZSBgJGluc3BlY3RgIHdhc1xuXHQvLyBkZXN0cm95ZWQsIG1lYW5pbmcgd2UgZG9uJ3QgbmVlZCB0byBib3RoZXJcblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGNhbGwgYGdldF92YWx1ZWAgc28gdGhhdCB0aGlzIHJ1bnMgYWxvbmdzaWRlIHRoZSBpbnNwZWN0IGVmZmVjdFxuXHRcdFx0Z2V0X3ZhbHVlKCk7XG5cdFx0fSBjYXRjaCB7XG5cdFx0XHQvLyBpZ25vcmVcblx0XHR9XG5cblx0XHRpZiAoZXJyb3IgIT09IFVOSU5JVElBTElaRUQpIHtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRjb25zb2xlLmVycm9yKGVycm9yKTtcblx0XHRcdGVycm9yID0gVU5JTklUSUFMSVpFRDtcblx0XHR9XG5cdH0pO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9hc3luYy5qcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGdldF9wZW5kaW5nX2JvdW5kYXJ5IH0gZnJvbSAnLi9ib3VuZGFyeS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtUZW1wbGF0ZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gUHJvbWlzZTxhbnk+Pn0gZXhwcmVzc2lvbnNcbiAqIEBwYXJhbSB7KGFuY2hvcjogVGVtcGxhdGVOb2RlLCAuLi5kZXJpdmVkczogVmFsdWVbXSkgPT4gdm9pZH0gZm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jKG5vZGUsIGV4cHJlc3Npb25zLCBmbikge1xuXHR2YXIgYm91bmRhcnkgPSBnZXRfcGVuZGluZ19ib3VuZGFyeSgpO1xuXG5cdGJvdW5kYXJ5LnVwZGF0ZV9wZW5kaW5nX2NvdW50KDEpO1xuXG5cdGZsYXR0ZW4oW10sIGV4cHJlc3Npb25zLCAodmFsdWVzKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIGdldCB2YWx1ZXMgZWFnZXJseSB0byBhdm9pZCBjcmVhdGluZyBibG9ja3MgaWYgdGhleSByZWplY3Rcblx0XHRcdGZvciAoY29uc3QgZCBvZiB2YWx1ZXMpIGdldChkKTtcblxuXHRcdFx0Zm4obm9kZSwgLi4udmFsdWVzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0Ym91bmRhcnkudXBkYXRlX3BlbmRpbmdfY291bnQoLTEpO1xuXHRcdH1cblx0fSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGFuY2hvclxuICogQHBhcmFtIHsuLi4oKCk9PmFueSlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVfc25pcHBldF9hcmdzKGFuY2hvciwgLi4uYXJncykge1xuXHRpZiAodHlwZW9mIGFuY2hvciAhPT0gJ29iamVjdCcgfHwgIShhbmNob3IgaW5zdGFuY2VvZiBOb2RlKSkge1xuXHRcdGUuaW52YWxpZF9zbmlwcGV0X2FyZ3VtZW50cygpO1xuXHR9XG5cblx0Zm9yIChsZXQgYXJnIG9mIGFyZ3MpIHtcblx0XHRpZiAodHlwZW9mIGFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0ZS5pbnZhbGlkX3NuaXBwZXRfYXJndW1lbnRzKCk7XG5cdFx0fVxuXHR9XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBFZmZlY3QsIFNvdXJjZSwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgaXNfcHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBwYXVzZV9lZmZlY3QsIHJlc3VtZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaW50ZXJuYWxfc2V0LCBtdXRhYmxlX3NvdXJjZSwgc291cmNlIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IHNldF9hY3RpdmVfZWZmZWN0LCBzZXRfYWN0aXZlX3JlYWN0aW9uIH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQge1xuXHRoeWRyYXRlX25leHQsXG5cdGh5ZHJhdGVfbm9kZSxcblx0aHlkcmF0aW5nLFxuXHRyZW1vdmVfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IEhZRFJBVElPTl9TVEFSVF9FTFNFLCBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG5cdGNvbXBvbmVudF9jb250ZXh0LFxuXHRkZXZfc3RhY2ssXG5cdGlzX3J1bmVzLFxuXHRzZXRfY29tcG9uZW50X2NvbnRleHQsXG5cdHNldF9kZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24sXG5cdHNldF9kZXZfc3RhY2tcbn0gZnJvbSAnLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuY29uc3QgUEVORElORyA9IDA7XG5jb25zdCBUSEVOID0gMTtcbmNvbnN0IENBVENIID0gMjtcblxuLyoqIEB0eXBlZGVmIHt0eXBlb2YgUEVORElORyB8IHR5cGVvZiBUSEVOIHwgdHlwZW9mIENBVENIfSBBd2FpdFN0YXRlICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygoKSA9PiBQcm9taXNlPFY+KX0gZ2V0X2lucHV0XG4gKiBAcGFyYW0ge251bGwgfCAoKGFuY2hvcjogTm9kZSkgPT4gdm9pZCl9IHBlbmRpbmdfZm5cbiAqIEBwYXJhbSB7bnVsbCB8ICgoYW5jaG9yOiBOb2RlLCB2YWx1ZTogU291cmNlPFY+KSA9PiB2b2lkKX0gdGhlbl9mblxuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IE5vZGUsIGVycm9yOiB1bmtub3duKSA9PiB2b2lkKX0gY2F0Y2hfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXdhaXRfYmxvY2sobm9kZSwgZ2V0X2lucHV0LCBwZW5kaW5nX2ZuLCB0aGVuX2ZuLCBjYXRjaF9mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gbm9kZTtcblx0dmFyIHJ1bmVzID0gaXNfcnVuZXMoKTtcblx0dmFyIGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9IGNvbXBvbmVudF9jb250ZXh0O1xuXG5cdC8qKiBAdHlwZSB7YW55fSAqL1xuXHR2YXIgY29tcG9uZW50X2Z1bmN0aW9uID0gREVWID8gY29tcG9uZW50X2NvbnRleHQ/LmZ1bmN0aW9uIDogbnVsbDtcblx0dmFyIGRldl9vcmlnaW5hbF9zdGFjayA9IERFViA/IGRldl9zdGFjayA6IG51bGw7XG5cblx0LyoqIEB0eXBlIHtWIHwgUHJvbWlzZTxWPiB8IHR5cGVvZiBVTklOSVRJQUxJWkVEfSAqL1xuXHR2YXIgaW5wdXQgPSBVTklOSVRJQUxJWkVEO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIHBlbmRpbmdfZWZmZWN0O1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIHRoZW5fZWZmZWN0O1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGNhdGNoX2VmZmVjdDtcblxuXHR2YXIgaW5wdXRfc291cmNlID0gcnVuZXNcblx0XHQ/IHNvdXJjZSgvKiogQHR5cGUge1Z9ICovICh1bmRlZmluZWQpKVxuXHRcdDogbXV0YWJsZV9zb3VyY2UoLyoqIEB0eXBlIHtWfSAqLyAodW5kZWZpbmVkKSwgZmFsc2UsIGZhbHNlKTtcblx0dmFyIGVycm9yX3NvdXJjZSA9IHJ1bmVzID8gc291cmNlKHVuZGVmaW5lZCkgOiBtdXRhYmxlX3NvdXJjZSh1bmRlZmluZWQsIGZhbHNlLCBmYWxzZSk7XG5cdHZhciByZXNvbHZlZCA9IGZhbHNlO1xuXHQvKipcblx0ICogQHBhcmFtIHtBd2FpdFN0YXRlfSBzdGF0ZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3RvcmVcblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSwgcmVzdG9yZSkge1xuXHRcdHJlc29sdmVkID0gdHJ1ZTtcblxuXHRcdGlmIChyZXN0b3JlKSB7XG5cdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChlZmZlY3QpO1xuXHRcdFx0c2V0X2FjdGl2ZV9yZWFjdGlvbihlZmZlY3QpOyAvLyBUT0RPIGRvIHdlIG5lZWQgYm90aD9cblx0XHRcdHNldF9jb21wb25lbnRfY29udGV4dChhY3RpdmVfY29tcG9uZW50X2NvbnRleHQpO1xuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRzZXRfZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uKGNvbXBvbmVudF9mdW5jdGlvbik7XG5cdFx0XHRcdHNldF9kZXZfc3RhY2soZGV2X29yaWdpbmFsX3N0YWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0aWYgKHN0YXRlID09PSBQRU5ESU5HICYmIHBlbmRpbmdfZm4pIHtcblx0XHRcdFx0aWYgKHBlbmRpbmdfZWZmZWN0KSByZXN1bWVfZWZmZWN0KHBlbmRpbmdfZWZmZWN0KTtcblx0XHRcdFx0ZWxzZSBwZW5kaW5nX2VmZmVjdCA9IGJyYW5jaCgoKSA9PiBwZW5kaW5nX2ZuKGFuY2hvcikpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3RhdGUgPT09IFRIRU4gJiYgdGhlbl9mbikge1xuXHRcdFx0XHRpZiAodGhlbl9lZmZlY3QpIHJlc3VtZV9lZmZlY3QodGhlbl9lZmZlY3QpO1xuXHRcdFx0XHRlbHNlIHRoZW5fZWZmZWN0ID0gYnJhbmNoKCgpID0+IHRoZW5fZm4oYW5jaG9yLCBpbnB1dF9zb3VyY2UpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0YXRlID09PSBDQVRDSCAmJiBjYXRjaF9mbikge1xuXHRcdFx0XHRpZiAoY2F0Y2hfZWZmZWN0KSByZXN1bWVfZWZmZWN0KGNhdGNoX2VmZmVjdCk7XG5cdFx0XHRcdGVsc2UgY2F0Y2hfZWZmZWN0ID0gYnJhbmNoKCgpID0+IGNhdGNoX2ZuKGFuY2hvciwgZXJyb3Jfc291cmNlKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdGF0ZSAhPT0gUEVORElORyAmJiBwZW5kaW5nX2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QocGVuZGluZ19lZmZlY3QsICgpID0+IChwZW5kaW5nX2VmZmVjdCA9IG51bGwpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0YXRlICE9PSBUSEVOICYmIHRoZW5fZWZmZWN0KSB7XG5cdFx0XHRcdHBhdXNlX2VmZmVjdCh0aGVuX2VmZmVjdCwgKCkgPT4gKHRoZW5fZWZmZWN0ID0gbnVsbCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3RhdGUgIT09IENBVENIICYmIGNhdGNoX2VmZmVjdCkge1xuXHRcdFx0XHRwYXVzZV9lZmZlY3QoY2F0Y2hfZWZmZWN0LCAoKSA9PiAoY2F0Y2hfZWZmZWN0ID0gbnVsbCkpO1xuXHRcdFx0fVxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRpZiAocmVzdG9yZSkge1xuXHRcdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdFx0c2V0X2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbihudWxsKTtcblx0XHRcdFx0XHRzZXRfZGV2X3N0YWNrKG51bGwpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2V0X2NvbXBvbmVudF9jb250ZXh0KG51bGwpO1xuXHRcdFx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKG51bGwpO1xuXHRcdFx0XHRzZXRfYWN0aXZlX2VmZmVjdChudWxsKTtcblxuXHRcdFx0XHQvLyB3aXRob3V0IHRoaXMsIHRoZSBET00gZG9lcyBub3QgdXBkYXRlIHVudGlsIHR3byB0aWNrcyBhZnRlciB0aGUgcHJvbWlzZVxuXHRcdFx0XHQvLyByZXNvbHZlcywgd2hpY2ggaXMgdW5leHBlY3RlZCBiZWhhdmlvdXIgKGFuZCBzb21ld2hhdCBpcmtzb21lIHRvIHRlc3QpXG5cdFx0XHRcdGZsdXNoU3luYygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBlZmZlY3QgPSBibG9jaygoKSA9PiB7XG5cdFx0aWYgKGlucHV0ID09PSAoaW5wdXQgPSBnZXRfaW5wdXQoKSkpIHJldHVybjtcblxuXHRcdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdC8vIEB0cy1pZ25vcmUgY29lcmNpbmcgYGFuY2hvcmAgdG8gYSBgQ29tbWVudGAgY2F1c2VzIFR5cGVTY3JpcHQgYW5kIFByZXR0aWVyIHRvIGZpZ2h0XG5cdFx0bGV0IG1pc21hdGNoID0gaHlkcmF0aW5nICYmIGlzX3Byb21pc2UoaW5wdXQpID09PSAoYW5jaG9yLmRhdGEgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFKTtcblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gSHlkcmF0aW9uIG1pc21hdGNoOiByZW1vdmUgZXZlcnl0aGluZyBpbnNpZGUgdGhlIGFuY2hvciBhbmQgc3RhcnQgZnJlc2hcblx0XHRcdGFuY2hvciA9IHJlbW92ZV9ub2RlcygpO1xuXG5cdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoaXNfcHJvbWlzZShpbnB1dCkpIHtcblx0XHRcdHZhciBwcm9taXNlID0gaW5wdXQ7XG5cblx0XHRcdHJlc29sdmVkID0gZmFsc2U7XG5cblx0XHRcdHByb21pc2UudGhlbihcblx0XHRcdFx0KHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHByb21pc2UgIT09IGlucHV0KSByZXR1cm47XG5cdFx0XHRcdFx0Ly8gd2UgdGVjaG5pY2FsbHkgY291bGQgdXNlIGBzZXRgIGhlcmUgc2luY2UgaXQncyBvbiB0aGUgbmV4dCBtaWNyb3RpY2tcblx0XHRcdFx0XHQvLyBidXQgbGV0J3MgdXNlIGludGVybmFsX3NldCBmb3IgY29uc2lzdGVuY3kgYW5kIGp1c3QgdG8gYmUgc2FmZVxuXHRcdFx0XHRcdGludGVybmFsX3NldChpbnB1dF9zb3VyY2UsIHZhbHVlKTtcblx0XHRcdFx0XHR1cGRhdGUoVEhFTiwgdHJ1ZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdChlcnJvcikgPT4ge1xuXHRcdFx0XHRcdGlmIChwcm9taXNlICE9PSBpbnB1dCkgcmV0dXJuO1xuXHRcdFx0XHRcdC8vIHdlIHRlY2huaWNhbGx5IGNvdWxkIHVzZSBgc2V0YCBoZXJlIHNpbmNlIGl0J3Mgb24gdGhlIG5leHQgbWljcm90aWNrXG5cdFx0XHRcdFx0Ly8gYnV0IGxldCdzIHVzZSBpbnRlcm5hbF9zZXQgZm9yIGNvbnNpc3RlbmN5IGFuZCBqdXN0IHRvIGJlIHNhZmVcblx0XHRcdFx0XHRpbnRlcm5hbF9zZXQoZXJyb3Jfc291cmNlLCBlcnJvcik7XG5cdFx0XHRcdFx0dXBkYXRlKENBVENILCB0cnVlKTtcblx0XHRcdFx0XHRpZiAoIWNhdGNoX2ZuKSB7XG5cdFx0XHRcdFx0XHQvLyBSZXRocm93IHRoZSBlcnJvciBpZiBubyBjYXRjaCBibG9jayBleGlzdHNcblx0XHRcdFx0XHRcdHRocm93IGVycm9yX3NvdXJjZS52O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0XHRpZiAocGVuZGluZ19mbikge1xuXHRcdFx0XHRcdHBlbmRpbmdfZWZmZWN0ID0gYnJhbmNoKCgpID0+IHBlbmRpbmdfZm4oYW5jaG9yKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdhaXQgYSBtaWNyb3Rhc2sgYmVmb3JlIGNoZWNraW5nIGlmIHdlIHNob3VsZCBzaG93IHRoZSBwZW5kaW5nIHN0YXRlIGFzXG5cdFx0XHRcdC8vIHRoZSBwcm9taXNlIG1pZ2h0IGhhdmUgcmVzb2x2ZWQgYnkgdGhlIG5leHQgbWljcm90YXNrLlxuXHRcdFx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdFx0XHRpZiAoIXJlc29sdmVkKSB1cGRhdGUoUEVORElORywgdHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnRlcm5hbF9zZXQoaW5wdXRfc291cmNlLCBpbnB1dCk7XG5cdFx0XHR1cGRhdGUoVEhFTiwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBpbnB1dCB0byBzb21ldGhpbmcgZWxzZSwgaW4gb3JkZXIgdG8gZGlzYWJsZSB0aGUgcHJvbWlzZSBjYWxsYmFja3Ncblx0XHRyZXR1cm4gKCkgPT4gKGlucHV0ID0gVU5JTklUSUFMSVpFRCk7XG5cdH0pO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJzsgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uLFxuXHRyZW1vdmVfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIHBhdXNlX2VmZmVjdCwgcmVzdW1lX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBIWURSQVRJT05fU1RBUlRfRUxTRSwgVU5JTklUSUFMSVpFRCB9IGZyb20gJy4uLy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVfdGV4dCwgc2hvdWxkX2RlZmVyX2FwcGVuZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHsgY3VycmVudF9iYXRjaCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuXG4vLyBUT0RPIHJlaW5zdGF0ZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvMTUyNTBcblxuLyoqXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoYnJhbmNoOiAoZm46IChhbmNob3I6IE5vZGUpID0+IHZvaWQsIGZsYWc/OiBib29sZWFuKSA9PiB2b2lkKSA9PiB2b2lkfSBmblxuICogQHBhcmFtIHtib29sZWFufSBbZWxzZWlmXSBUcnVlIGlmIHRoaXMgaXMgYW4gYHs6ZWxzZSBpZiAuLi59YCBibG9jayByYXRoZXIgdGhhbiBhbiBgeyNpZiAuLi59YCwgYXMgdGhhdCBhZmZlY3RzIHdoaWNoIHRyYW5zaXRpb25zIGFyZSBjb25zaWRlcmVkICdsb2NhbCdcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaWZfYmxvY2sobm9kZSwgZm4sIGVsc2VpZiA9IGZhbHNlKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBhbmNob3IgPSBub2RlO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGNvbnNlcXVlbnRfZWZmZWN0ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge0VmZmVjdCB8IG51bGx9ICovXG5cdHZhciBhbHRlcm5hdGVfZWZmZWN0ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge3R5cGVvZiBVTklOSVRJQUxJWkVEIHwgYm9vbGVhbiB8IG51bGx9ICovXG5cdHZhciBjb25kaXRpb24gPSBVTklOSVRJQUxJWkVEO1xuXG5cdHZhciBmbGFncyA9IGVsc2VpZiA/IEVGRkVDVF9UUkFOU1BBUkVOVCA6IDA7XG5cblx0dmFyIGhhc19icmFuY2ggPSBmYWxzZTtcblxuXHRjb25zdCBzZXRfYnJhbmNoID0gKC8qKiBAdHlwZSB7KGFuY2hvcjogTm9kZSkgPT4gdm9pZH0gKi8gZm4sIGZsYWcgPSB0cnVlKSA9PiB7XG5cdFx0aGFzX2JyYW5jaCA9IHRydWU7XG5cdFx0dXBkYXRlX2JyYW5jaChmbGFnLCBmbik7XG5cdH07XG5cblx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgbnVsbH0gKi9cblx0dmFyIG9mZnNjcmVlbl9mcmFnbWVudCA9IG51bGw7XG5cblx0ZnVuY3Rpb24gY29tbWl0KCkge1xuXHRcdGlmIChvZmZzY3JlZW5fZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIHJlbW92ZSB0aGUgYW5jaG9yXG5cdFx0XHQvKiogQHR5cGUge1RleHR9ICovIChvZmZzY3JlZW5fZnJhZ21lbnQubGFzdENoaWxkKS5yZW1vdmUoKTtcblxuXHRcdFx0YW5jaG9yLmJlZm9yZShvZmZzY3JlZW5fZnJhZ21lbnQpO1xuXHRcdFx0b2Zmc2NyZWVuX2ZyYWdtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHR2YXIgYWN0aXZlID0gY29uZGl0aW9uID8gY29uc2VxdWVudF9lZmZlY3QgOiBhbHRlcm5hdGVfZWZmZWN0O1xuXHRcdHZhciBpbmFjdGl2ZSA9IGNvbmRpdGlvbiA/IGFsdGVybmF0ZV9lZmZlY3QgOiBjb25zZXF1ZW50X2VmZmVjdDtcblxuXHRcdGlmIChhY3RpdmUpIHtcblx0XHRcdHJlc3VtZV9lZmZlY3QoYWN0aXZlKTtcblx0XHR9XG5cblx0XHRpZiAoaW5hY3RpdmUpIHtcblx0XHRcdHBhdXNlX2VmZmVjdChpbmFjdGl2ZSwgKCkgPT4ge1xuXHRcdFx0XHRpZiAoY29uZGl0aW9uKSB7XG5cdFx0XHRcdFx0YWx0ZXJuYXRlX2VmZmVjdCA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc2VxdWVudF9lZmZlY3QgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCB1cGRhdGVfYnJhbmNoID0gKFxuXHRcdC8qKiBAdHlwZSB7Ym9vbGVhbiB8IG51bGx9ICovIG5ld19jb25kaXRpb24sXG5cdFx0LyoqIEB0eXBlIHtudWxsIHwgKChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSAqLyBmblxuXHQpID0+IHtcblx0XHRpZiAoY29uZGl0aW9uID09PSAoY29uZGl0aW9uID0gbmV3X2NvbmRpdGlvbikpIHJldHVybjtcblxuXHRcdC8qKiBXaGV0aGVyIG9yIG5vdCB0aGVyZSB3YXMgYSBoeWRyYXRpb24gbWlzbWF0Y2guIE5lZWRzIHRvIGJlIGEgYGxldGAgb3IgZWxzZSBpdCBpc24ndCB0cmVlc2hha2VuIG91dCAqL1xuXHRcdGxldCBtaXNtYXRjaCA9IGZhbHNlO1xuXG5cdFx0aWYgKGh5ZHJhdGluZykge1xuXHRcdFx0Y29uc3QgaXNfZWxzZSA9IHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uKGFuY2hvcikgPT09IEhZRFJBVElPTl9TVEFSVF9FTFNFO1xuXG5cdFx0XHRpZiAoISFjb25kaXRpb24gPT09IGlzX2Vsc2UpIHtcblx0XHRcdFx0Ly8gSHlkcmF0aW9uIG1pc21hdGNoOiByZW1vdmUgZXZlcnl0aGluZyBpbnNpZGUgdGhlIGFuY2hvciBhbmQgc3RhcnQgZnJlc2guXG5cdFx0XHRcdC8vIFRoaXMgY291bGQgaGFwcGVuIHdpdGggYHsjaWYgYnJvd3Nlcn0uLi57L2lmfWAsIGZvciBleGFtcGxlXG5cdFx0XHRcdGFuY2hvciA9IHJlbW92ZV9ub2RlcygpO1xuXG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUoYW5jaG9yKTtcblx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdG1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgZGVmZXIgPSBzaG91bGRfZGVmZXJfYXBwZW5kKCk7XG5cdFx0dmFyIHRhcmdldCA9IGFuY2hvcjtcblxuXHRcdGlmIChkZWZlcikge1xuXHRcdFx0b2Zmc2NyZWVuX2ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0b2Zmc2NyZWVuX2ZyYWdtZW50LmFwcGVuZCgodGFyZ2V0ID0gY3JlYXRlX3RleHQoKSkpO1xuXHRcdH1cblxuXHRcdGlmIChjb25kaXRpb24pIHtcblx0XHRcdGNvbnNlcXVlbnRfZWZmZWN0ID8/PSBmbiAmJiBicmFuY2goKCkgPT4gZm4odGFyZ2V0KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFsdGVybmF0ZV9lZmZlY3QgPz89IGZuICYmIGJyYW5jaCgoKSA9PiBmbih0YXJnZXQpKTtcblx0XHR9XG5cblx0XHRpZiAoZGVmZXIpIHtcblx0XHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblxuXHRcdFx0dmFyIGFjdGl2ZSA9IGNvbmRpdGlvbiA/IGNvbnNlcXVlbnRfZWZmZWN0IDogYWx0ZXJuYXRlX2VmZmVjdDtcblx0XHRcdHZhciBpbmFjdGl2ZSA9IGNvbmRpdGlvbiA/IGFsdGVybmF0ZV9lZmZlY3QgOiBjb25zZXF1ZW50X2VmZmVjdDtcblxuXHRcdFx0aWYgKGFjdGl2ZSkgYmF0Y2guc2tpcHBlZF9lZmZlY3RzLmRlbGV0ZShhY3RpdmUpO1xuXHRcdFx0aWYgKGluYWN0aXZlKSBiYXRjaC5za2lwcGVkX2VmZmVjdHMuYWRkKGluYWN0aXZlKTtcblxuXHRcdFx0YmF0Y2guYWRkX2NhbGxiYWNrKGNvbW1pdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbW1pdCgpO1xuXHRcdH1cblxuXHRcdGlmIChtaXNtYXRjaCkge1xuXHRcdFx0Ly8gY29udGludWUgaW4gaHlkcmF0aW9uIG1vZGVcblx0XHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRoYXNfYnJhbmNoID0gZmFsc2U7XG5cdFx0Zm4oc2V0X2JyYW5jaCk7XG5cdFx0aWYgKCFoYXNfYnJhbmNoKSB7XG5cdFx0XHR1cGRhdGVfYnJhbmNoKG51bGwsIG51bGwpO1xuXHRcdH1cblx0fSwgZmxhZ3MpO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJzsgKi9cbmltcG9ydCB7IFVOSU5JVElBTElaRUQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgYmxvY2ssIGJyYW5jaCwgcGF1c2VfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG5vdF9lcXVhbCwgc2FmZV9ub3RfZXF1YWwgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IGlzX3J1bmVzIH0gZnJvbSAnLi4vLi4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV90ZXh0LCBzaG91bGRfZGVmZXJfYXBwZW5kIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2JhdGNoIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7VGVtcGxhdGVOb2RlfSBub2RlXG4gKiBAcGFyYW0geygpID0+IFZ9IGdldF9rZXlcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSkgPT4gVGVtcGxhdGVOb2RlIHwgdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtleShub2RlLCBnZXRfa2V5LCByZW5kZXJfZm4pIHtcblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtWIHwgdHlwZW9mIFVOSU5JVElBTElaRUR9ICovXG5cdHZhciBrZXkgPSBVTklOSVRJQUxJWkVEO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0fSAqL1xuXHR2YXIgcGVuZGluZ19lZmZlY3Q7XG5cblx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgbnVsbH0gKi9cblx0dmFyIG9mZnNjcmVlbl9mcmFnbWVudCA9IG51bGw7XG5cblx0dmFyIGNoYW5nZWQgPSBpc19ydW5lcygpID8gbm90X2VxdWFsIDogc2FmZV9ub3RfZXF1YWw7XG5cblx0ZnVuY3Rpb24gY29tbWl0KCkge1xuXHRcdGlmIChlZmZlY3QpIHtcblx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QpO1xuXHRcdH1cblxuXHRcdGlmIChvZmZzY3JlZW5fZnJhZ21lbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIHJlbW92ZSB0aGUgYW5jaG9yXG5cdFx0XHQvKiogQHR5cGUge1RleHR9ICovIChvZmZzY3JlZW5fZnJhZ21lbnQubGFzdENoaWxkKS5yZW1vdmUoKTtcblxuXHRcdFx0YW5jaG9yLmJlZm9yZShvZmZzY3JlZW5fZnJhZ21lbnQpO1xuXHRcdFx0b2Zmc2NyZWVuX2ZyYWdtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRlZmZlY3QgPSBwZW5kaW5nX2VmZmVjdDtcblx0fVxuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRpZiAoY2hhbmdlZChrZXksIChrZXkgPSBnZXRfa2V5KCkpKSkge1xuXHRcdFx0dmFyIHRhcmdldCA9IGFuY2hvcjtcblxuXHRcdFx0dmFyIGRlZmVyID0gc2hvdWxkX2RlZmVyX2FwcGVuZCgpO1xuXG5cdFx0XHRpZiAoZGVmZXIpIHtcblx0XHRcdFx0b2Zmc2NyZWVuX2ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRvZmZzY3JlZW5fZnJhZ21lbnQuYXBwZW5kKCh0YXJnZXQgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0XHR9XG5cblx0XHRcdHBlbmRpbmdfZWZmZWN0ID0gYnJhbmNoKCgpID0+IHJlbmRlcl9mbih0YXJnZXQpKTtcblxuXHRcdFx0aWYgKGRlZmVyKSB7XG5cdFx0XHRcdC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKS5hZGRfY2FsbGJhY2soY29tbWl0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbW1pdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJlbmRlcl9lZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZywgc2V0X2h5ZHJhdGVfbm9kZSB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRfZmlyc3RfY2hpbGQgfSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50IHwgU1ZHR0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7KCkgPT4gUmVjb3JkPHN0cmluZywgc3RyaW5nPn0gZ2V0X3N0eWxlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjc3NfcHJvcHMoZWxlbWVudCwgZ2V0X3N0eWxlcykge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGdldF9maXJzdF9jaGlsZChlbGVtZW50KSkpO1xuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHN0eWxlcyA9IGdldF9zdHlsZXMoKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuXG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0ZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWFjaEl0ZW0sIEVhY2hTdGF0ZSwgRWZmZWN0LCBNYXliZVNvdXJjZSwgU291cmNlLCBUZW1wbGF0ZU5vZGUsIFRyYW5zaXRpb25NYW5hZ2VyLCBWYWx1ZSB9IGZyb20gJyNjbGllbnQnICovXG4vKiogQGltcG9ydCB7IEJhdGNoIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7ICovXG5pbXBvcnQge1xuXHRFQUNIX0lOREVYX1JFQUNUSVZFLFxuXHRFQUNIX0lTX0FOSU1BVEVELFxuXHRFQUNIX0lTX0NPTlRST0xMRUQsXG5cdEVBQ0hfSVRFTV9JTU1VVEFCTEUsXG5cdEVBQ0hfSVRFTV9SRUFDVElWRSxcblx0SFlEUkFUSU9OX0VORCxcblx0SFlEUkFUSU9OX1NUQVJUX0VMU0Vcbn0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7XG5cdGh5ZHJhdGVfbmV4dCxcblx0aHlkcmF0ZV9ub2RlLFxuXHRoeWRyYXRpbmcsXG5cdHJlYWRfaHlkcmF0aW9uX2luc3RydWN0aW9uLFxuXHRyZW1vdmVfbm9kZXMsXG5cdHNldF9oeWRyYXRlX25vZGUsXG5cdHNldF9oeWRyYXRpbmdcbn0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7XG5cdGNsZWFyX3RleHRfY29udGVudCxcblx0Y3JlYXRlX3RleHQsXG5cdGdldF9maXJzdF9jaGlsZCxcblx0Z2V0X25leHRfc2libGluZyxcblx0c2hvdWxkX2RlZmVyX2FwcGVuZFxufSBmcm9tICcuLi9vcGVyYXRpb25zLmpzJztcbmltcG9ydCB7XG5cdGJsb2NrLFxuXHRicmFuY2gsXG5cdGRlc3Ryb3lfZWZmZWN0LFxuXHRydW5fb3V0X3RyYW5zaXRpb25zLFxuXHRwYXVzZV9jaGlsZHJlbixcblx0cGF1c2VfZWZmZWN0LFxuXHRyZXN1bWVfZWZmZWN0XG59IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzb3VyY2UsIG11dGFibGVfc291cmNlLCBpbnRlcm5hbF9zZXQgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L3NvdXJjZXMuanMnO1xuaW1wb3J0IHsgYXJyYXlfZnJvbSwgaXNfYXJyYXkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgQ09NTUVOVF9OT0RFLCBJTkVSVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi90YXNrLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QsIGdldCB9IGZyb20gJy4uLy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBkZXJpdmVkX3NhZmVfZXF1YWwgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IGN1cnJlbnRfYmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLyoqXG4gKiBUaGUgcm93IG9mIGEga2V5ZWQgZWFjaCBibG9jayB0aGF0IGlzIGN1cnJlbnRseSB1cGRhdGluZy4gV2UgdHJhY2sgdGhpc1xuICogc28gdGhhdCBgYW5pbWF0ZTpgIGRpcmVjdGl2ZXMgaGF2ZSBzb21ldGhpbmcgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG9cbiAqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9XG4gKi9cbmV4cG9ydCBsZXQgY3VycmVudF9lYWNoX2l0ZW0gPSBudWxsO1xuXG4vKiogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IGl0ZW0gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VycmVudF9lYWNoX2l0ZW0oaXRlbSkge1xuXHRjdXJyZW50X2VhY2hfaXRlbSA9IGl0ZW07XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IF9cbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChfLCBpKSB7XG5cdHJldHVybiBpO1xufVxuXG4vKipcbiAqIFBhdXNlIG11bHRpcGxlIGVmZmVjdHMgc2ltdWx0YW5lb3VzbHksIGFuZCBjb29yZGluYXRlIHRoZWlyXG4gKiBzdWJzZXF1ZW50IGRlc3RydWN0aW9uLiBVc2VkIGluIGVhY2ggYmxvY2tzXG4gKiBAcGFyYW0ge0VhY2hTdGF0ZX0gc3RhdGVcbiAqIEBwYXJhbSB7RWFjaEl0ZW1bXX0gaXRlbXNcbiAqIEBwYXJhbSB7bnVsbCB8IE5vZGV9IGNvbnRyb2xsZWRfYW5jaG9yXG4gKi9cbmZ1bmN0aW9uIHBhdXNlX2VmZmVjdHMoc3RhdGUsIGl0ZW1zLCBjb250cm9sbGVkX2FuY2hvcikge1xuXHR2YXIgaXRlbXNfbWFwID0gc3RhdGUuaXRlbXM7XG5cblx0LyoqIEB0eXBlIHtUcmFuc2l0aW9uTWFuYWdlcltdfSAqL1xuXHR2YXIgdHJhbnNpdGlvbnMgPSBbXTtcblx0dmFyIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0cGF1c2VfY2hpbGRyZW4oaXRlbXNbaV0uZSwgdHJhbnNpdGlvbnMsIHRydWUpO1xuXHR9XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSBsZW5ndGggPiAwICYmIHRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMCAmJiBjb250cm9sbGVkX2FuY2hvciAhPT0gbnVsbDtcblx0Ly8gSWYgd2UgaGF2ZSBhIGNvbnRyb2xsZWQgYW5jaG9yLCBpdCBtZWFucyB0aGF0IHRoZSBlYWNoIGJsb2NrIGlzIGluc2lkZSBhIHNpbmdsZVxuXHQvLyBET00gZWxlbWVudCwgc28gd2UgY2FuIGFwcGx5IGEgZmFzdC1wYXRoIGZvciBjbGVhcmluZyB0aGUgY29udGVudHMgb2YgdGhlIGVsZW1lbnQuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoXG5cdFx0XHQvKiogQHR5cGUge0VsZW1lbnR9ICovIChjb250cm9sbGVkX2FuY2hvcikucGFyZW50Tm9kZVxuXHRcdCk7XG5cdFx0Y2xlYXJfdGV4dF9jb250ZW50KHBhcmVudF9ub2RlKTtcblx0XHRwYXJlbnRfbm9kZS5hcHBlbmQoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoY29udHJvbGxlZF9hbmNob3IpKTtcblx0XHRpdGVtc19tYXAuY2xlYXIoKTtcblx0XHRsaW5rKHN0YXRlLCBpdGVtc1swXS5wcmV2LCBpdGVtc1tsZW5ndGggLSAxXS5uZXh0KTtcblx0fVxuXG5cdHJ1bl9vdXRfdHJhbnNpdGlvbnModHJhbnNpdGlvbnMsICgpID0+IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKCFpc19jb250cm9sbGVkKSB7XG5cdFx0XHRcdGl0ZW1zX21hcC5kZWxldGUoaXRlbS5rKTtcblx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0fVxuXHRcdFx0ZGVzdHJveV9lZmZlY3QoaXRlbS5lLCAhaXNfY29udHJvbGxlZCk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudH0gbm9kZSBUaGUgbmV4dCBzaWJsaW5nIG5vZGUsIG9yIHRoZSBwYXJlbnQgbm9kZSBpZiB0aGlzIGlzIGEgJ2NvbnRyb2xsZWQnIGJsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHBhcmFtIHsodmFsdWU6IFYsIGluZGV4OiBudW1iZXIpID0+IGFueX0gZ2V0X2tleVxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IE1heWJlU291cmNlPG51bWJlcj4pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IE5vZGUpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG5vZGUsIGZsYWdzLCBnZXRfY29sbGVjdGlvbiwgZ2V0X2tleSwgcmVuZGVyX2ZuLCBmYWxsYmFja19mbiA9IG51bGwpIHtcblx0dmFyIGFuY2hvciA9IG5vZGU7XG5cblx0LyoqIEB0eXBlIHtFYWNoU3RhdGV9ICovXG5cdHZhciBzdGF0ZSA9IHsgZmxhZ3MsIGl0ZW1zOiBuZXcgTWFwKCksIGZpcnN0OiBudWxsIH07XG5cblx0dmFyIGlzX2NvbnRyb2xsZWQgPSAoZmxhZ3MgJiBFQUNIX0lTX0NPTlRST0xMRUQpICE9PSAwO1xuXG5cdGlmIChpc19jb250cm9sbGVkKSB7XG5cdFx0dmFyIHBhcmVudF9ub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSk7XG5cblx0XHRhbmNob3IgPSBoeWRyYXRpbmdcblx0XHRcdD8gc2V0X2h5ZHJhdGVfbm9kZSgvKiogQHR5cGUge0NvbW1lbnQgfCBUZXh0fSAqLyAoZ2V0X2ZpcnN0X2NoaWxkKHBhcmVudF9ub2RlKSkpXG5cdFx0XHQ6IHBhcmVudF9ub2RlLmFwcGVuZENoaWxkKGNyZWF0ZV90ZXh0KCkpO1xuXHR9XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZmFsbGJhY2sgPSBudWxsO1xuXG5cdHZhciB3YXNfZW1wdHkgPSBmYWxzZTtcblxuXHQvKiogQHR5cGUge01hcDxhbnksIEVhY2hJdGVtPn0gKi9cblx0dmFyIG9mZnNjcmVlbl9pdGVtcyA9IG5ldyBNYXAoKTtcblxuXHQvLyBUT0RPOiBpZGVhbGx5IHdlIGNvdWxkIHVzZSBkZXJpdmVkIGZvciBydW5lcyBtb2RlIGJ1dCBiZWNhdXNlIG9mIHRoZSBhYmlsaXR5XG5cdC8vIHRvIHVzZSBhIHN0b3JlIHdoaWNoIGNhbiBiZSBtdXRhdGVkLCB3ZSBjYW4ndCBkbyB0aGF0IGhlcmUgYXMgbXV0YXRpbmcgYSBzdG9yZVxuXHQvLyB3aWxsIHN0aWxsIHJlc3VsdCBpbiB0aGUgY29sbGVjdGlvbiBhcnJheSBiZWluZyB0aGUgc2FtZSBmcm9tIHRoZSBzdG9yZVxuXHR2YXIgZWFjaF9hcnJheSA9IGRlcml2ZWRfc2FmZV9lcXVhbCgoKSA9PiB7XG5cdFx0dmFyIGNvbGxlY3Rpb24gPSBnZXRfY29sbGVjdGlvbigpO1xuXG5cdFx0cmV0dXJuIGlzX2FycmF5KGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IGNvbGxlY3Rpb24gPT0gbnVsbCA/IFtdIDogYXJyYXlfZnJvbShjb2xsZWN0aW9uKTtcblx0fSk7XG5cblx0LyoqIEB0eXBlIHtWW119ICovXG5cdHZhciBhcnJheTtcblxuXHQvKiogQHR5cGUge0VmZmVjdH0gKi9cblx0dmFyIGVhY2hfZWZmZWN0O1xuXG5cdGZ1bmN0aW9uIGNvbW1pdCgpIHtcblx0XHRyZWNvbmNpbGUoXG5cdFx0XHRlYWNoX2VmZmVjdCxcblx0XHRcdGFycmF5LFxuXHRcdFx0c3RhdGUsXG5cdFx0XHRvZmZzY3JlZW5faXRlbXMsXG5cdFx0XHRhbmNob3IsXG5cdFx0XHRyZW5kZXJfZm4sXG5cdFx0XHRmbGFncyxcblx0XHRcdGdldF9rZXksXG5cdFx0XHRnZXRfY29sbGVjdGlvblxuXHRcdCk7XG5cblx0XHRpZiAoZmFsbGJhY2tfZm4gIT09IG51bGwpIHtcblx0XHRcdGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0aWYgKGZhbGxiYWNrKSB7XG5cdFx0XHRcdFx0cmVzdW1lX2VmZmVjdChmYWxsYmFjayk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZmFsbGJhY2sgPSBicmFuY2goKCkgPT4gZmFsbGJhY2tfZm4oYW5jaG9yKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZmFsbGJhY2sgIT09IG51bGwpIHtcblx0XHRcdFx0cGF1c2VfZWZmZWN0KGZhbGxiYWNrLCAoKSA9PiB7XG5cdFx0XHRcdFx0ZmFsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRibG9jaygoKSA9PiB7XG5cdFx0Ly8gc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGVmZmVjdCBzbyB0aGF0IHdlIGNhbiB1cGRhdGUgdGhlIHN0YXJ0L2VuZCBub2RlcyBpbiByZWNvbmNpbGlhdGlvblxuXHRcdGVhY2hfZWZmZWN0ID8/PSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdFx0YXJyYXkgPSAvKiogQHR5cGUge1ZbXX0gKi8gKGdldChlYWNoX2FycmF5KSk7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuXHRcdGlmICh3YXNfZW1wdHkgJiYgbGVuZ3RoID09PSAwKSB7XG5cdFx0XHQvLyBpZ25vcmUgdXBkYXRlcyBpZiB0aGUgYXJyYXkgaXMgZW1wdHksXG5cdFx0XHQvLyBhbmQgaXQgYWxyZWFkeSB3YXMgZW1wdHkgb24gcHJldmlvdXMgcnVuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHdhc19lbXB0eSA9IGxlbmd0aCA9PT0gMDtcblxuXHRcdC8qKiBgdHJ1ZWAgaWYgdGhlcmUgd2FzIGEgaHlkcmF0aW9uIG1pc21hdGNoLiBOZWVkcyB0byBiZSBhIGBsZXRgIG9yIGVsc2UgaXQgaXNuJ3QgdHJlZXNoYWtlbiBvdXQgKi9cblx0XHRsZXQgbWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdHZhciBpc19lbHNlID0gcmVhZF9oeWRyYXRpb25faW5zdHJ1Y3Rpb24oYW5jaG9yKSA9PT0gSFlEUkFUSU9OX1NUQVJUX0VMU0U7XG5cblx0XHRcdGlmIChpc19lbHNlICE9PSAobGVuZ3RoID09PSAwKSkge1xuXHRcdFx0XHQvLyBoeWRyYXRpb24gbWlzbWF0Y2ggXHUyMDE0IHJlbW92ZSB0aGUgc2VydmVyLXJlbmRlcmVkIERPTSBhbmQgc3RhcnQgb3ZlclxuXHRcdFx0XHRhbmNob3IgPSByZW1vdmVfbm9kZXMoKTtcblxuXHRcdFx0XHRzZXRfaHlkcmF0ZV9ub2RlKGFuY2hvcik7XG5cdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcyBpcyBzZXBhcmF0ZSB0byB0aGUgcHJldmlvdXMgYmxvY2sgYmVjYXVzZSBgaHlkcmF0aW5nYCBtaWdodCBjaGFuZ2Vcblx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHQvKiogQHR5cGUge0VhY2hJdGVtIHwgbnVsbH0gKi9cblx0XHRcdHZhciBwcmV2ID0gbnVsbDtcblxuXHRcdFx0LyoqIEB0eXBlIHtFYWNoSXRlbX0gKi9cblx0XHRcdHZhciBpdGVtO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJlxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKGh5ZHJhdGVfbm9kZSkuZGF0YSA9PT0gSFlEUkFUSU9OX0VORFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyBUaGUgc2VydmVyIHJlbmRlcmVkIGZld2VyIGl0ZW1zIHRoYW4gZXhwZWN0ZWQsXG5cdFx0XHRcdFx0Ly8gc28gYnJlYWsgb3V0IGFuZCBjb250aW51ZSBhcHBlbmRpbmcgbm9uLWh5ZHJhdGVkIGl0ZW1zXG5cdFx0XHRcdFx0YW5jaG9yID0gLyoqIEB0eXBlIHtDb21tZW50fSAqLyAoaHlkcmF0ZV9ub2RlKTtcblx0XHRcdFx0XHRtaXNtYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdFx0dmFyIGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdFx0XHRpdGVtID0gY3JlYXRlX2l0ZW0oXG5cdFx0XHRcdFx0aHlkcmF0ZV9ub2RlLFxuXHRcdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRcdHByZXYsXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRyZW5kZXJfZm4sXG5cdFx0XHRcdFx0ZmxhZ3MsXG5cdFx0XHRcdFx0Z2V0X2NvbGxlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdFx0c3RhdGUuaXRlbXMuc2V0KGtleSwgaXRlbSk7XG5cblx0XHRcdFx0cHJldiA9IGl0ZW07XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBleGNlc3Mgbm9kZXNcblx0XHRcdGlmIChsZW5ndGggPiAwKSB7XG5cdFx0XHRcdHNldF9oeWRyYXRlX25vZGUocmVtb3ZlX25vZGVzKCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdGlmIChsZW5ndGggPT09IDAgJiYgZmFsbGJhY2tfZm4pIHtcblx0XHRcdFx0ZmFsbGJhY2sgPSBicmFuY2goKCkgPT4gZmFsbGJhY2tfZm4oYW5jaG9yKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChzaG91bGRfZGVmZXJfYXBwZW5kKCkpIHtcblx0XHRcdFx0dmFyIGtleXMgPSBuZXcgU2V0KCk7XG5cdFx0XHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGFycmF5W2ldO1xuXHRcdFx0XHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXG5cdFx0XHRcdFx0dmFyIGV4aXN0aW5nID0gc3RhdGUuaXRlbXMuZ2V0KGtleSkgPz8gb2Zmc2NyZWVuX2l0ZW1zLmdldChrZXkpO1xuXG5cdFx0XHRcdFx0aWYgKGV4aXN0aW5nKSB7XG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgYmVmb3JlIHJlY29uY2lsaWF0aW9uLCB0byB0cmlnZ2VyIGFueSBhc3luYyB1cGRhdGVzXG5cdFx0XHRcdFx0XHRpZiAoKGZsYWdzICYgKEVBQ0hfSVRFTV9SRUFDVElWRSB8IEVBQ0hfSU5ERVhfUkVBQ1RJVkUpKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHR1cGRhdGVfaXRlbShleGlzdGluZywgdmFsdWUsIGksIGZsYWdzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aXRlbSA9IGNyZWF0ZV9pdGVtKFxuXHRcdFx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRcdFx0cmVuZGVyX2ZuLFxuXHRcdFx0XHRcdFx0XHRmbGFncyxcblx0XHRcdFx0XHRcdFx0Z2V0X2NvbGxlY3Rpb24sXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdG9mZnNjcmVlbl9pdGVtcy5zZXQoa2V5LCBpdGVtKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRrZXlzLmFkZChrZXkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBzdGF0ZS5pdGVtcykge1xuXHRcdFx0XHRcdGlmICgha2V5cy5oYXMoa2V5KSkge1xuXHRcdFx0XHRcdFx0YmF0Y2guc2tpcHBlZF9lZmZlY3RzLmFkZChpdGVtLmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhdGNoLmFkZF9jYWxsYmFjayhjb21taXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29tbWl0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG1pc21hdGNoKSB7XG5cdFx0XHQvLyBjb250aW51ZSBpbiBoeWRyYXRpb24gbW9kZVxuXHRcdFx0c2V0X2h5ZHJhdGluZyh0cnVlKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHdlIG1vdW50IHRoZSBlYWNoIGJsb2NrIGZvciB0aGUgZmlyc3QgdGltZSwgdGhlIGNvbGxlY3Rpb24gd29uJ3QgYmVcblx0XHQvLyBjb25uZWN0ZWQgdG8gdGhpcyBlZmZlY3QgYXMgdGhlIGVmZmVjdCBoYXNuJ3QgZmluaXNoZWQgcnVubmluZyB5ZXQgYW5kIGl0cyBkZXBzXG5cdFx0Ly8gd29uJ3QgYmUgYXNzaWduZWQuIEhvd2V2ZXIsIGl0J3MgcG9zc2libGUgdGhhdCB3aGVuIHJlY29uY2lsaW5nIHRoZSBlYWNoIGJsb2NrXG5cdFx0Ly8gdGhhdCBhIG11dGF0aW9uIG9jY3VycmVkIGFuZCBpdCdzIG1hZGUgdGhlIGNvbGxlY3Rpb24gTUFZQkVfRElSVFksIHNvIHJlYWRpbmcgdGhlXG5cdFx0Ly8gY29sbGVjdGlvbiBhZ2FpbiBjYW4gcHJvdmlkZSBjb25zaXN0ZW5jeSB0byB0aGUgcmVhY3RpdmUgZ3JhcGggYWdhaW4gYXMgdGhlIGRlcml2ZWRzXG5cdFx0Ly8gd2lsbCBub3cgYmUgYENMRUFOYC5cblx0XHRnZXQoZWFjaF9hcnJheSk7XG5cdH0pO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRhbmNob3IgPSBoeWRyYXRlX25vZGU7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGQsIHJlbW92ZSwgb3IgcmVvcmRlciBpdGVtcyBvdXRwdXQgYnkgYW4gZWFjaCBibG9jayBhcyBpdHMgaW5wdXQgY2hhbmdlc1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7RWZmZWN0fSBlYWNoX2VmZmVjdFxuICogQHBhcmFtIHtBcnJheTxWPn0gYXJyYXlcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtNYXA8YW55LCBFYWNoSXRlbT59IG9mZnNjcmVlbl9pdGVtc1xuICogQHBhcmFtIHtFbGVtZW50IHwgQ29tbWVudCB8IFRleHR9IGFuY2hvclxuICogQHBhcmFtIHsoYW5jaG9yOiBOb2RlLCBpdGVtOiBNYXliZVNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFNvdXJjZTxudW1iZXI+LCBjb2xsZWN0aW9uOiAoKSA9PiBWW10pID0+IHZvaWR9IHJlbmRlcl9mblxuICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzXG4gKiBAcGFyYW0geyh2YWx1ZTogViwgaW5kZXg6IG51bWJlcikgPT4gYW55fSBnZXRfa2V5XG4gKiBAcGFyYW0geygpID0+IFZbXX0gZ2V0X2NvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiByZWNvbmNpbGUoXG5cdGVhY2hfZWZmZWN0LFxuXHRhcnJheSxcblx0c3RhdGUsXG5cdG9mZnNjcmVlbl9pdGVtcyxcblx0YW5jaG9yLFxuXHRyZW5kZXJfZm4sXG5cdGZsYWdzLFxuXHRnZXRfa2V5LFxuXHRnZXRfY29sbGVjdGlvblxuKSB7XG5cdHZhciBpc19hbmltYXRlZCA9IChmbGFncyAmIEVBQ0hfSVNfQU5JTUFURUQpICE9PSAwO1xuXHR2YXIgc2hvdWxkX3VwZGF0ZSA9IChmbGFncyAmIChFQUNIX0lURU1fUkVBQ1RJVkUgfCBFQUNIX0lOREVYX1JFQUNUSVZFKSkgIT09IDA7XG5cblx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0dmFyIGl0ZW1zID0gc3RhdGUuaXRlbXM7XG5cdHZhciBmaXJzdCA9IHN0YXRlLmZpcnN0O1xuXHR2YXIgY3VycmVudCA9IGZpcnN0O1xuXG5cdC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgU2V0PEVhY2hJdGVtPn0gKi9cblx0dmFyIHNlZW47XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IG51bGx9ICovXG5cdHZhciBwcmV2ID0gbnVsbDtcblxuXHQvKiogQHR5cGUge3VuZGVmaW5lZCB8IFNldDxFYWNoSXRlbT59ICovXG5cdHZhciB0b19hbmltYXRlO1xuXG5cdC8qKiBAdHlwZSB7RWFjaEl0ZW1bXX0gKi9cblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHQvKiogQHR5cGUge0VhY2hJdGVtW119ICovXG5cdHZhciBzdGFzaGVkID0gW107XG5cblx0LyoqIEB0eXBlIHtWfSAqL1xuXHR2YXIgdmFsdWU7XG5cblx0LyoqIEB0eXBlIHthbnl9ICovXG5cdHZhciBrZXk7XG5cblx0LyoqIEB0eXBlIHtFYWNoSXRlbSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIGl0ZW07XG5cblx0LyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cdHZhciBpO1xuXG5cdGlmIChpc19hbmltYXRlZCkge1xuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRcdGtleSA9IGdldF9rZXkodmFsdWUsIGkpO1xuXHRcdFx0aXRlbSA9IGl0ZW1zLmdldChrZXkpO1xuXG5cdFx0XHRpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGl0ZW0uYT8ubWVhc3VyZSgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5hZGQoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFsdWUgPSBhcnJheVtpXTtcblx0XHRrZXkgPSBnZXRfa2V5KHZhbHVlLCBpKTtcblxuXHRcdGl0ZW0gPSBpdGVtcy5nZXQoa2V5KTtcblxuXHRcdGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBwZW5kaW5nID0gb2Zmc2NyZWVuX2l0ZW1zLmdldChrZXkpO1xuXG5cdFx0XHRpZiAocGVuZGluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG9mZnNjcmVlbl9pdGVtcy5kZWxldGUoa2V5KTtcblx0XHRcdFx0aXRlbXMuc2V0KGtleSwgcGVuZGluZyk7XG5cblx0XHRcdFx0dmFyIG5leHQgPSBwcmV2ID8gcHJldi5uZXh0IDogY3VycmVudDtcblxuXHRcdFx0XHRsaW5rKHN0YXRlLCBwcmV2LCBwZW5kaW5nKTtcblx0XHRcdFx0bGluayhzdGF0ZSwgcGVuZGluZywgbmV4dCk7XG5cblx0XHRcdFx0bW92ZShwZW5kaW5nLCBuZXh0LCBhbmNob3IpO1xuXHRcdFx0XHRwcmV2ID0gcGVuZGluZztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBjaGlsZF9hbmNob3IgPSBjdXJyZW50ID8gLyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChjdXJyZW50LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdFx0XHRcdHByZXYgPSBjcmVhdGVfaXRlbShcblx0XHRcdFx0XHRjaGlsZF9hbmNob3IsXG5cdFx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdFx0cHJldixcblx0XHRcdFx0XHRwcmV2ID09PSBudWxsID8gc3RhdGUuZmlyc3QgOiBwcmV2Lm5leHQsXG5cdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGksXG5cdFx0XHRcdFx0cmVuZGVyX2ZuLFxuXHRcdFx0XHRcdGZsYWdzLFxuXHRcdFx0XHRcdGdldF9jb2xsZWN0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZW1zLnNldChrZXksIHByZXYpO1xuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdGN1cnJlbnQgPSBwcmV2Lm5leHQ7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoc2hvdWxkX3VwZGF0ZSkge1xuXHRcdFx0dXBkYXRlX2l0ZW0oaXRlbSwgdmFsdWUsIGksIGZsYWdzKTtcblx0XHR9XG5cblx0XHRpZiAoKGl0ZW0uZS5mICYgSU5FUlQpICE9PSAwKSB7XG5cdFx0XHRyZXN1bWVfZWZmZWN0KGl0ZW0uZSk7XG5cdFx0XHRpZiAoaXNfYW5pbWF0ZWQpIHtcblx0XHRcdFx0aXRlbS5hPy51bmZpeCgpO1xuXHRcdFx0XHQodG9fYW5pbWF0ZSA/Pz0gbmV3IFNldCgpKS5kZWxldGUoaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGl0ZW0gIT09IGN1cnJlbnQpIHtcblx0XHRcdGlmIChzZWVuICE9PSB1bmRlZmluZWQgJiYgc2Vlbi5oYXMoaXRlbSkpIHtcblx0XHRcdFx0aWYgKG1hdGNoZWQubGVuZ3RoIDwgc3Rhc2hlZC5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBtb3JlIGVmZmljaWVudCB0byBtb3ZlIGxhdGVyIGl0ZW1zIHRvIHRoZSBmcm9udFxuXHRcdFx0XHRcdHZhciBzdGFydCA9IHN0YXNoZWRbMF07XG5cdFx0XHRcdFx0dmFyIGo7XG5cblx0XHRcdFx0XHRwcmV2ID0gc3RhcnQucHJldjtcblxuXHRcdFx0XHRcdHZhciBhID0gbWF0Y2hlZFswXTtcblx0XHRcdFx0XHR2YXIgYiA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRtb3ZlKG1hdGNoZWRbal0sIHN0YXJ0LCBhbmNob3IpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBzdGFzaGVkLmxlbmd0aDsgaiArPSAxKSB7XG5cdFx0XHRcdFx0XHRzZWVuLmRlbGV0ZShzdGFzaGVkW2pdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsaW5rKHN0YXRlLCBhLnByZXYsIGIubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgYSk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgYiwgc3RhcnQpO1xuXG5cdFx0XHRcdFx0Y3VycmVudCA9IHN0YXJ0O1xuXHRcdFx0XHRcdHByZXYgPSBiO1xuXHRcdFx0XHRcdGkgLT0gMTtcblxuXHRcdFx0XHRcdG1hdGNoZWQgPSBbXTtcblx0XHRcdFx0XHRzdGFzaGVkID0gW107XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gbW9yZSBlZmZpY2llbnQgdG8gbW92ZSBlYXJsaWVyIGl0ZW1zIHRvIHRoZSBiYWNrXG5cdFx0XHRcdFx0c2Vlbi5kZWxldGUoaXRlbSk7XG5cdFx0XHRcdFx0bW92ZShpdGVtLCBjdXJyZW50LCBhbmNob3IpO1xuXG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgaXRlbS5wcmV2LCBpdGVtLm5leHQpO1xuXHRcdFx0XHRcdGxpbmsoc3RhdGUsIGl0ZW0sIHByZXYgPT09IG51bGwgPyBzdGF0ZS5maXJzdCA6IHByZXYubmV4dCk7XG5cdFx0XHRcdFx0bGluayhzdGF0ZSwgcHJldiwgaXRlbSk7XG5cblx0XHRcdFx0XHRwcmV2ID0gaXRlbTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRtYXRjaGVkID0gW107XG5cdFx0XHRzdGFzaGVkID0gW107XG5cblx0XHRcdHdoaWxlIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuayAhPT0ga2V5KSB7XG5cdFx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0IGFuZCBhbiBpdGVtIGhhcyBhbiBlZmZlY3QgdGhhdCBpcyBhbHJlYWR5IGluZXJ0LFxuXHRcdFx0XHQvLyBza2lwIG92ZXIgYWRkaW5nIGl0IHRvIG91ciBzZWVuIFNldCBhcyB0aGUgaXRlbSBpcyBhbHJlYWR5IGJlaW5nIGhhbmRsZWRcblx0XHRcdFx0aWYgKChjdXJyZW50LmUuZiAmIElORVJUKSA9PT0gMCkge1xuXHRcdFx0XHRcdChzZWVuID8/PSBuZXcgU2V0KCkpLmFkZChjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFzaGVkLnB1c2goY3VycmVudCk7XG5cdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjdXJyZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpdGVtID0gY3VycmVudDtcblx0XHR9XG5cblx0XHRtYXRjaGVkLnB1c2goaXRlbSk7XG5cdFx0cHJldiA9IGl0ZW07XG5cdFx0Y3VycmVudCA9IGl0ZW0ubmV4dDtcblx0fVxuXG5cdGlmIChjdXJyZW50ICE9PSBudWxsIHx8IHNlZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciB0b19kZXN0cm95ID0gc2VlbiA9PT0gdW5kZWZpbmVkID8gW10gOiBhcnJheV9mcm9tKHNlZW4pO1xuXG5cdFx0d2hpbGUgKGN1cnJlbnQgIT09IG51bGwpIHtcblx0XHRcdC8vIElmIHRoZSBlYWNoIGJsb2NrIGlzbid0IGluZXJ0LCB0aGVuIGluZXJ0IGVmZmVjdHMgYXJlIGN1cnJlbnRseSBvdXRyb2luZyBhbmQgd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHRyYW5zaXRpb24gaXMgZmluaXNoZWRcblx0XHRcdGlmICgoY3VycmVudC5lLmYgJiBJTkVSVCkgPT09IDApIHtcblx0XHRcdFx0dG9fZGVzdHJveS5wdXNoKGN1cnJlbnQpO1xuXHRcdFx0fVxuXHRcdFx0Y3VycmVudCA9IGN1cnJlbnQubmV4dDtcblx0XHR9XG5cblx0XHR2YXIgZGVzdHJveV9sZW5ndGggPSB0b19kZXN0cm95Lmxlbmd0aDtcblxuXHRcdGlmIChkZXN0cm95X2xlbmd0aCA+IDApIHtcblx0XHRcdHZhciBjb250cm9sbGVkX2FuY2hvciA9IChmbGFncyAmIEVBQ0hfSVNfQ09OVFJPTExFRCkgIT09IDAgJiYgbGVuZ3RoID09PSAwID8gYW5jaG9yIDogbnVsbDtcblxuXHRcdFx0aWYgKGlzX2FuaW1hdGVkKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkZXN0cm95X2xlbmd0aDsgaSArPSAxKSB7XG5cdFx0XHRcdFx0dG9fZGVzdHJveVtpXS5hPy5tZWFzdXJlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZGVzdHJveV9sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0XHRcdHRvX2Rlc3Ryb3lbaV0uYT8uZml4KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cGF1c2VfZWZmZWN0cyhzdGF0ZSwgdG9fZGVzdHJveSwgY29udHJvbGxlZF9hbmNob3IpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChpc19hbmltYXRlZCkge1xuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0aWYgKHRvX2FuaW1hdGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXHRcdFx0Zm9yIChpdGVtIG9mIHRvX2FuaW1hdGUpIHtcblx0XHRcdFx0aXRlbS5hPy5hcHBseSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0ZWFjaF9lZmZlY3QuZmlyc3QgPSBzdGF0ZS5maXJzdCAmJiBzdGF0ZS5maXJzdC5lO1xuXHRlYWNoX2VmZmVjdC5sYXN0ID0gcHJldiAmJiBwcmV2LmU7XG5cblx0Zm9yICh2YXIgdW51c2VkIG9mIG9mZnNjcmVlbl9pdGVtcy52YWx1ZXMoKSkge1xuXHRcdGRlc3Ryb3lfZWZmZWN0KHVudXNlZC5lKTtcblx0fVxuXG5cdG9mZnNjcmVlbl9pdGVtcy5jbGVhcigpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaEl0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZV9pdGVtKGl0ZW0sIHZhbHVlLCBpbmRleCwgdHlwZSkge1xuXHRpZiAoKHR5cGUgJiBFQUNIX0lURU1fUkVBQ1RJVkUpICE9PSAwKSB7XG5cdFx0aW50ZXJuYWxfc2V0KGl0ZW0udiwgdmFsdWUpO1xuXHR9XG5cblx0aWYgKCh0eXBlICYgRUFDSF9JTkRFWF9SRUFDVElWRSkgIT09IDApIHtcblx0XHRpbnRlcm5hbF9zZXQoLyoqIEB0eXBlIHtWYWx1ZTxudW1iZXI+fSAqLyAoaXRlbS5pKSwgaW5kZXgpO1xuXHR9IGVsc2Uge1xuXHRcdGl0ZW0uaSA9IGluZGV4O1xuXHR9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7Tm9kZSB8IG51bGx9IGFuY2hvclxuICogQHBhcmFtIHtFYWNoU3RhdGV9IHN0YXRlXG4gKiBAcGFyYW0ge0VhY2hJdGVtIHwgbnVsbH0gcHJldlxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7Vn0gdmFsdWVcbiAqIEBwYXJhbSB7dW5rbm93bn0ga2V5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7KGFuY2hvcjogTm9kZSwgaXRlbTogViB8IFNvdXJjZTxWPiwgaW5kZXg6IG51bWJlciB8IFZhbHVlPG51bWJlcj4sIGNvbGxlY3Rpb246ICgpID0+IFZbXSkgPT4gdm9pZH0gcmVuZGVyX2ZuXG4gKiBAcGFyYW0ge251bWJlcn0gZmxhZ3NcbiAqIEBwYXJhbSB7KCkgPT4gVltdfSBnZXRfY29sbGVjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbZGVmZXJyZWRdXG4gKiBAcmV0dXJucyB7RWFjaEl0ZW19XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZV9pdGVtKFxuXHRhbmNob3IsXG5cdHN0YXRlLFxuXHRwcmV2LFxuXHRuZXh0LFxuXHR2YWx1ZSxcblx0a2V5LFxuXHRpbmRleCxcblx0cmVuZGVyX2ZuLFxuXHRmbGFncyxcblx0Z2V0X2NvbGxlY3Rpb24sXG5cdGRlZmVycmVkXG4pIHtcblx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHR2YXIgcmVhY3RpdmUgPSAoZmxhZ3MgJiBFQUNIX0lURU1fUkVBQ1RJVkUpICE9PSAwO1xuXHR2YXIgbXV0YWJsZSA9IChmbGFncyAmIEVBQ0hfSVRFTV9JTU1VVEFCTEUpID09PSAwO1xuXG5cdHZhciB2ID0gcmVhY3RpdmUgPyAobXV0YWJsZSA/IG11dGFibGVfc291cmNlKHZhbHVlLCBmYWxzZSwgZmFsc2UpIDogc291cmNlKHZhbHVlKSkgOiB2YWx1ZTtcblx0dmFyIGkgPSAoZmxhZ3MgJiBFQUNIX0lOREVYX1JFQUNUSVZFKSA9PT0gMCA/IGluZGV4IDogc291cmNlKGluZGV4KTtcblxuXHRpZiAoREVWICYmIHJlYWN0aXZlKSB7XG5cdFx0Ly8gRm9yIHRyYWNpbmcgcHVycG9zZXMsIHdlIG5lZWQgdG8gbGluayB0aGUgc291cmNlIHNpZ25hbCB3ZSBjcmVhdGUgd2l0aCB0aGVcblx0XHQvLyBjb2xsZWN0aW9uICsgaW5kZXggc28gdGhhdCB0cmFjaW5nIHdvcmtzIGFzIGludGVuZGVkXG5cdFx0LyoqIEB0eXBlIHtWYWx1ZX0gKi8gKHYpLnRyYWNlID0gKCkgPT4ge1xuXHRcdFx0dmFyIGNvbGxlY3Rpb25faW5kZXggPSB0eXBlb2YgaSA9PT0gJ251bWJlcicgPyBpbmRleCA6IGkudjtcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRnZXRfY29sbGVjdGlvbigpW2NvbGxlY3Rpb25faW5kZXhdO1xuXHRcdH07XG5cdH1cblxuXHQvKiogQHR5cGUge0VhY2hJdGVtfSAqL1xuXHR2YXIgaXRlbSA9IHtcblx0XHRpLFxuXHRcdHYsXG5cdFx0azoga2V5LFxuXHRcdGE6IG51bGwsXG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGU6IG51bGwsXG5cdFx0cHJldixcblx0XHRuZXh0XG5cdH07XG5cblx0Y3VycmVudF9lYWNoX2l0ZW0gPSBpdGVtO1xuXG5cdHRyeSB7XG5cdFx0aWYgKGFuY2hvciA9PT0gbnVsbCkge1xuXHRcdFx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0ZnJhZ21lbnQuYXBwZW5kKChhbmNob3IgPSBjcmVhdGVfdGV4dCgpKSk7XG5cdFx0fVxuXG5cdFx0aXRlbS5lID0gYnJhbmNoKCgpID0+IHJlbmRlcl9mbigvKiogQHR5cGUge05vZGV9ICovIChhbmNob3IpLCB2LCBpLCBnZXRfY29sbGVjdGlvbiksIGh5ZHJhdGluZyk7XG5cblx0XHRpdGVtLmUucHJldiA9IHByZXYgJiYgcHJldi5lO1xuXHRcdGl0ZW0uZS5uZXh0ID0gbmV4dCAmJiBuZXh0LmU7XG5cblx0XHRpZiAocHJldiA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKCFkZWZlcnJlZCkge1xuXHRcdFx0XHRzdGF0ZS5maXJzdCA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByZXYubmV4dCA9IGl0ZW07XG5cdFx0XHRwcmV2LmUubmV4dCA9IGl0ZW0uZTtcblx0XHR9XG5cblx0XHRpZiAobmV4dCAhPT0gbnVsbCkge1xuXHRcdFx0bmV4dC5wcmV2ID0gaXRlbTtcblx0XHRcdG5leHQuZS5wcmV2ID0gaXRlbS5lO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtO1xuXHR9IGZpbmFsbHkge1xuXHRcdGN1cnJlbnRfZWFjaF9pdGVtID0gcHJldmlvdXNfZWFjaF9pdGVtO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFYWNoSXRlbX0gaXRlbVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IG5leHRcbiAqIEBwYXJhbSB7VGV4dCB8IEVsZW1lbnQgfCBDb21tZW50fSBhbmNob3JcbiAqL1xuZnVuY3Rpb24gbW92ZShpdGVtLCBuZXh0LCBhbmNob3IpIHtcblx0dmFyIGVuZCA9IGl0ZW0ubmV4dCA/IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaXRlbS5uZXh0LmUubm9kZXNfc3RhcnQpIDogYW5jaG9yO1xuXG5cdHZhciBkZXN0ID0gbmV4dCA/IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAobmV4dC5lLm5vZGVzX3N0YXJ0KSA6IGFuY2hvcjtcblx0dmFyIG5vZGUgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGl0ZW0uZS5ub2Rlc19zdGFydCk7XG5cblx0d2hpbGUgKG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZW5kKSB7XG5cdFx0dmFyIG5leHRfbm9kZSA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhub2RlKSk7XG5cdFx0ZGVzdC5iZWZvcmUobm9kZSk7XG5cdFx0bm9kZSA9IG5leHRfbm9kZTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWFjaFN0YXRlfSBzdGF0ZVxuICogQHBhcmFtIHtFYWNoSXRlbSB8IG51bGx9IHByZXZcbiAqIEBwYXJhbSB7RWFjaEl0ZW0gfCBudWxsfSBuZXh0XG4gKi9cbmZ1bmN0aW9uIGxpbmsoc3RhdGUsIHByZXYsIG5leHQpIHtcblx0aWYgKHByZXYgPT09IG51bGwpIHtcblx0XHRzdGF0ZS5maXJzdCA9IG5leHQ7XG5cdH0gZWxzZSB7XG5cdFx0cHJldi5uZXh0ID0gbmV4dDtcblx0XHRwcmV2LmUubmV4dCA9IG5leHQgJiYgbmV4dC5lO1xuXHR9XG5cblx0aWYgKG5leHQgIT09IG51bGwpIHtcblx0XHRuZXh0LnByZXYgPSBwcmV2O1xuXHRcdG5leHQuZS5wcmV2ID0gcHJldiAmJiBwcmV2LmU7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCwgVGVtcGxhdGVOb2RlIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IEZJTEVOQU1FLCBIWURSQVRJT05fRVJST1IgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgcmVtb3ZlX2VmZmVjdF9kb20sIHRlbXBsYXRlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nLCBzZXRfaHlkcmF0ZV9ub2RlIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwgfSBmcm9tICcuLi9yZWNvbmNpbGVyLmpzJztcbmltcG9ydCB7IGFzc2lnbl9ub2RlcyB9IGZyb20gJy4uL3RlbXBsYXRlLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgaGFzaCwgc2FuaXRpemVfbG9jYXRpb24gfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgZ2V0X2ZpcnN0X2NoaWxkLCBnZXRfbmV4dF9zaWJsaW5nIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBDT01NRU5UX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHNlcnZlcl9oYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gY2hlY2tfaGFzaChlbGVtZW50LCBzZXJ2ZXJfaGFzaCwgdmFsdWUpIHtcblx0aWYgKCFzZXJ2ZXJfaGFzaCB8fCBzZXJ2ZXJfaGFzaCA9PT0gaGFzaChTdHJpbmcodmFsdWUgPz8gJycpKSkgcmV0dXJuO1xuXG5cdGxldCBsb2NhdGlvbjtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGNvbnN0IGxvYyA9IGVsZW1lbnQuX19zdmVsdGVfbWV0YT8ubG9jO1xuXHRpZiAobG9jKSB7XG5cdFx0bG9jYXRpb24gPSBgbmVhciAke2xvYy5maWxlfToke2xvYy5saW5lfToke2xvYy5jb2x1bW59YDtcblx0fSBlbHNlIGlmIChkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24/LltGSUxFTkFNRV0pIHtcblx0XHRsb2NhdGlvbiA9IGBpbiAke2Rldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbltGSUxFTkFNRV19YDtcblx0fVxuXG5cdHcuaHlkcmF0aW9uX2h0bWxfY2hhbmdlZChzYW5pdGl6ZV9sb2NhdGlvbihsb2NhdGlvbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCB8IFRleHQgfCBDb21tZW50fSBub2RlXG4gKiBAcGFyYW0geygpID0+IHN0cmluZ30gZ2V0X3ZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtzdmddXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFttYXRobWxdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh0bWwobm9kZSwgZ2V0X3ZhbHVlLCBzdmcgPSBmYWxzZSwgbWF0aG1sID0gZmFsc2UsIHNraXBfd2FybmluZyA9IGZhbHNlKSB7XG5cdHZhciBhbmNob3IgPSBub2RlO1xuXG5cdHZhciB2YWx1ZSA9ICcnO1xuXG5cdHRlbXBsYXRlX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIGVmZmVjdCA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0XHRpZiAodmFsdWUgPT09ICh2YWx1ZSA9IGdldF92YWx1ZSgpID8/ICcnKSkge1xuXHRcdFx0aWYgKGh5ZHJhdGluZykgaHlkcmF0ZV9uZXh0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGVmZmVjdC5ub2Rlc19zdGFydCAhPT0gbnVsbCkge1xuXHRcdFx0cmVtb3ZlX2VmZmVjdF9kb20oZWZmZWN0Lm5vZGVzX3N0YXJ0LCAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKGVmZmVjdC5ub2Rlc19lbmQpKTtcblx0XHRcdGVmZmVjdC5ub2Rlc19zdGFydCA9IGVmZmVjdC5ub2Rlc19lbmQgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA9PT0gJycpIHJldHVybjtcblxuXHRcdGlmIChoeWRyYXRpbmcpIHtcblx0XHRcdC8vIFdlJ3JlIGRlbGliZXJhdGVseSBub3QgdHJ5aW5nIHRvIHJlcGFpciBtaXNtYXRjaGVzIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQsXG5cdFx0XHQvLyBhcyBpdCdzIGNvc3RseSBhbmQgZXJyb3ItcHJvbmUgKGFuZCBpdCdzIGFuIGVkZ2UgY2FzZSB0byBoYXZlIGEgbWlzbWF0Y2ggYW55d2F5KVxuXHRcdFx0dmFyIGhhc2ggPSAvKiogQHR5cGUge0NvbW1lbnR9ICovIChoeWRyYXRlX25vZGUpLmRhdGE7XG5cdFx0XHR2YXIgbmV4dCA9IGh5ZHJhdGVfbmV4dCgpO1xuXHRcdFx0dmFyIGxhc3QgPSBuZXh0O1xuXG5cdFx0XHR3aGlsZSAoXG5cdFx0XHRcdG5leHQgIT09IG51bGwgJiZcblx0XHRcdFx0KG5leHQubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSB8fCAvKiogQHR5cGUge0NvbW1lbnR9ICovIChuZXh0KS5kYXRhICE9PSAnJylcblx0XHRcdCkge1xuXHRcdFx0XHRsYXN0ID0gbmV4dDtcblx0XHRcdFx0bmV4dCA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoZ2V0X25leHRfc2libGluZyhuZXh0KSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXh0ID09PSBudWxsKSB7XG5cdFx0XHRcdHcuaHlkcmF0aW9uX21pc21hdGNoKCk7XG5cdFx0XHRcdHRocm93IEhZRFJBVElPTl9FUlJPUjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKERFViAmJiAhc2tpcF93YXJuaW5nKSB7XG5cdFx0XHRcdGNoZWNrX2hhc2goLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobmV4dC5wYXJlbnROb2RlKSwgaGFzaCwgdmFsdWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRhc3NpZ25fbm9kZXMoaHlkcmF0ZV9ub2RlLCBsYXN0KTtcblx0XHRcdGFuY2hvciA9IHNldF9oeWRyYXRlX25vZGUobmV4dCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGh0bWwgPSB2YWx1ZSArICcnO1xuXHRcdGlmIChzdmcpIGh0bWwgPSBgPHN2Zz4ke2h0bWx9PC9zdmc+YDtcblx0XHRlbHNlIGlmIChtYXRobWwpIGh0bWwgPSBgPG1hdGg+JHtodG1sfTwvbWF0aD5gO1xuXG5cdFx0Ly8gRG9uJ3QgdXNlIGNyZWF0ZV9mcmFnbWVudF93aXRoX3NjcmlwdF9mcm9tX2h0bWwgaGVyZSBiZWNhdXNlIHRoYXQgd291bGQgbWVhbiBzY3JpcHQgdGFncyBhcmUgZXhlY3V0ZWQuXG5cdFx0Ly8gQGh0bWwgaXMgYmFzaWNhbGx5IGAuaW5uZXJIVE1MID0gLi4uYCBhbmQgdGhhdCBkb2Vzbid0IGV4ZWN1dGUgc2NyaXB0cyBlaXRoZXIgZHVlIHRvIHNlY3VyaXR5IHJlYXNvbnMuXG5cdFx0LyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50IHwgRWxlbWVudH0gKi9cblx0XHR2YXIgbm9kZSA9IGNyZWF0ZV9mcmFnbWVudF9mcm9tX2h0bWwoaHRtbCk7XG5cblx0XHRpZiAoc3ZnIHx8IG1hdGhtbCkge1xuXHRcdFx0bm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKGdldF9maXJzdF9jaGlsZChub2RlKSk7XG5cdFx0fVxuXG5cdFx0YXNzaWduX25vZGVzKFxuXHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpLFxuXHRcdFx0LyoqIEB0eXBlIHtUZW1wbGF0ZU5vZGV9ICovIChub2RlLmxhc3RDaGlsZClcblx0XHQpO1xuXG5cdFx0aWYgKHN2ZyB8fCBtYXRobWwpIHtcblx0XHRcdHdoaWxlIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpIHtcblx0XHRcdFx0YW5jaG9yLmJlZm9yZSgvKiogQHR5cGUge05vZGV9ICovIChnZXRfZmlyc3RfY2hpbGQobm9kZSkpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0YW5jaG9yLmJlZm9yZShub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IGh5ZHJhdGVfbmV4dCwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0NvbW1lbnR9IGFuY2hvclxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAkJHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gc2xvdF9wcm9wc1xuICogQHBhcmFtIHtudWxsIHwgKChhbmNob3I6IENvbW1lbnQpID0+IHZvaWQpfSBmYWxsYmFja19mblxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xvdChhbmNob3IsICQkcHJvcHMsIG5hbWUsIHNsb3RfcHJvcHMsIGZhbGxiYWNrX2ZuKSB7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBzbG90X2ZuID0gJCRwcm9wcy4kJHNsb3RzPy5bbmFtZV07XG5cdC8vIEludGVyb3A6IENhbiB1c2Ugc25pcHBldHMgdG8gZmlsbCBzbG90c1xuXHR2YXIgaXNfaW50ZXJvcCA9IGZhbHNlO1xuXHRpZiAoc2xvdF9mbiA9PT0gdHJ1ZSkge1xuXHRcdHNsb3RfZm4gPSAkJHByb3BzW25hbWUgPT09ICdkZWZhdWx0JyA/ICdjaGlsZHJlbicgOiBuYW1lXTtcblx0XHRpc19pbnRlcm9wID0gdHJ1ZTtcblx0fVxuXG5cdGlmIChzbG90X2ZuID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZmFsbGJhY2tfZm4gIT09IG51bGwpIHtcblx0XHRcdGZhbGxiYWNrX2ZuKGFuY2hvcik7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHNsb3RfZm4oYW5jaG9yLCBpc19pbnRlcm9wID8gKCkgPT4gc2xvdF9wcm9wcyA6IHNsb3RfcHJvcHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBwcm9wc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVfc2xvdHMocHJvcHMpIHtcblx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn0gKi9cblx0Y29uc3Qgc2FuaXRpemVkID0ge307XG5cdGlmIChwcm9wcy5jaGlsZHJlbikgc2FuaXRpemVkLmRlZmF1bHQgPSB0cnVlO1xuXHRmb3IgKGNvbnN0IGtleSBpbiBwcm9wcy4kJHNsb3RzKSB7XG5cdFx0c2FuaXRpemVkW2tleV0gPSB0cnVlO1xuXHR9XG5cdHJldHVybiBzYW5pdGl6ZWQ7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBUZW1wbGF0ZU5vZGUsIERvbSwgRWZmZWN0IH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgQmF0Y2ggfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJzsgKi9cbmltcG9ydCB7IEVGRkVDVF9UUkFOU1BBUkVOVCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIHBhdXNlX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2JhdGNoIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9iYXRjaC5qcyc7XG5pbXBvcnQgeyBoeWRyYXRlX25leHQsIGh5ZHJhdGVfbm9kZSwgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZV90ZXh0LCBzaG91bGRfZGVmZXJfYXBwZW5kIH0gZnJvbSAnLi4vb3BlcmF0aW9ucy5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFBcbiAqIEB0ZW1wbGF0ZSB7KHByb3BzOiBQKSA9PiB2b2lkfSBDXG4gKiBAcGFyYW0ge1RlbXBsYXRlTm9kZX0gbm9kZVxuICogQHBhcmFtIHsoKSA9PiBDfSBnZXRfY29tcG9uZW50XG4gKiBAcGFyYW0geyhhbmNob3I6IFRlbXBsYXRlTm9kZSwgY29tcG9uZW50OiBDKSA9PiBEb20gfCB2b2lkfSByZW5kZXJfZm5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcG9uZW50KG5vZGUsIGdldF9jb21wb25lbnQsIHJlbmRlcl9mbikge1xuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0aHlkcmF0ZV9uZXh0KCk7XG5cdH1cblxuXHR2YXIgYW5jaG9yID0gbm9kZTtcblxuXHQvKiogQHR5cGUge0N9ICovXG5cdHZhciBjb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudCB8IG51bGx9ICovXG5cdHZhciBvZmZzY3JlZW5fZnJhZ21lbnQgPSBudWxsO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIHBlbmRpbmdfZWZmZWN0ID0gbnVsbDtcblxuXHRmdW5jdGlvbiBjb21taXQoKSB7XG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0cGF1c2VfZWZmZWN0KGVmZmVjdCk7XG5cdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChvZmZzY3JlZW5fZnJhZ21lbnQpIHtcblx0XHRcdC8vIHJlbW92ZSB0aGUgYW5jaG9yXG5cdFx0XHQvKiogQHR5cGUge1RleHR9ICovIChvZmZzY3JlZW5fZnJhZ21lbnQubGFzdENoaWxkKS5yZW1vdmUoKTtcblxuXHRcdFx0YW5jaG9yLmJlZm9yZShvZmZzY3JlZW5fZnJhZ21lbnQpO1xuXHRcdFx0b2Zmc2NyZWVuX2ZyYWdtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRlZmZlY3QgPSBwZW5kaW5nX2VmZmVjdDtcblx0XHRwZW5kaW5nX2VmZmVjdCA9IG51bGw7XG5cdH1cblxuXHRibG9jaygoKSA9PiB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gKGNvbXBvbmVudCA9IGdldF9jb21wb25lbnQoKSkpIHJldHVybjtcblxuXHRcdHZhciBkZWZlciA9IHNob3VsZF9kZWZlcl9hcHBlbmQoKTtcblxuXHRcdGlmIChjb21wb25lbnQpIHtcblx0XHRcdHZhciB0YXJnZXQgPSBhbmNob3I7XG5cblx0XHRcdGlmIChkZWZlcikge1xuXHRcdFx0XHRvZmZzY3JlZW5fZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdG9mZnNjcmVlbl9mcmFnbWVudC5hcHBlbmQoKHRhcmdldCA9IGNyZWF0ZV90ZXh0KCkpKTtcblx0XHRcdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7QmF0Y2h9ICovIChjdXJyZW50X2JhdGNoKS5za2lwcGVkX2VmZmVjdHMuYWRkKGVmZmVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBlbmRpbmdfZWZmZWN0ID0gYnJhbmNoKCgpID0+IHJlbmRlcl9mbih0YXJnZXQsIGNvbXBvbmVudCkpO1xuXHRcdH1cblxuXHRcdGlmIChkZWZlcikge1xuXHRcdFx0LyoqIEB0eXBlIHtCYXRjaH0gKi8gKGN1cnJlbnRfYmF0Y2gpLmFkZF9jYWxsYmFjayhjb21taXQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb21taXQoKTtcblx0XHR9XG5cdH0sIEVGRkVDVF9UUkFOU1BBUkVOVCk7XG5cblx0aWYgKGh5ZHJhdGluZykge1xuXHRcdGFuY2hvciA9IGh5ZHJhdGVfbm9kZTtcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBUZW1wbGF0ZU5vZGUgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgRklMRU5BTUUsIE5BTUVTUEFDRV9TVkcgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHtcblx0aHlkcmF0ZV9uZXh0LFxuXHRoeWRyYXRlX25vZGUsXG5cdGh5ZHJhdGluZyxcblx0c2V0X2h5ZHJhdGVfbm9kZSxcblx0c2V0X2h5ZHJhdGluZ1xufSBmcm9tICcuLi9oeWRyYXRpb24uanMnO1xuaW1wb3J0IHsgY3JlYXRlX3RleHQsIGdldF9maXJzdF9jaGlsZCB9IGZyb20gJy4uL29wZXJhdGlvbnMuanMnO1xuaW1wb3J0IHtcblx0YmxvY2ssXG5cdGJyYW5jaCxcblx0ZGVzdHJveV9lZmZlY3QsXG5cdHBhdXNlX2VmZmVjdCxcblx0cmVzdW1lX2VmZmVjdFxufSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgc2V0X3Nob3VsZF9pbnRybyB9IGZyb20gJy4uLy4uL3JlbmRlci5qcyc7XG5pbXBvcnQgeyBjdXJyZW50X2VhY2hfaXRlbSwgc2V0X2N1cnJlbnRfZWFjaF9pdGVtIH0gZnJvbSAnLi9lYWNoLmpzJztcbmltcG9ydCB7IGFjdGl2ZV9lZmZlY3QgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGNvbXBvbmVudF9jb250ZXh0LCBkZXZfc3RhY2sgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuaW1wb3J0IHsgRUZGRUNUX1RSQU5TUEFSRU5ULCBFTEVNRU5UX05PREUgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBhc3NpZ25fbm9kZXMgfSBmcm9tICcuLi90ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgeyBpc19yYXdfdGV4dF9lbGVtZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7Q29tbWVudCB8IEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gc3RyaW5nfSBnZXRfdGFnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzX3N2Z1xuICogQHBhcmFtIHt1bmRlZmluZWQgfCAoKGVsZW1lbnQ6IEVsZW1lbnQsIGFuY2hvcjogTm9kZSB8IG51bGwpID0+IHZvaWQpfSByZW5kZXJfZm4sXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8ICgoKSA9PiBzdHJpbmcpfSBnZXRfbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3VuZGVmaW5lZCB8IFtudW1iZXIsIG51bWJlcl19IGxvY2F0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnQobm9kZSwgZ2V0X3RhZywgaXNfc3ZnLCByZW5kZXJfZm4sIGdldF9uYW1lc3BhY2UsIGxvY2F0aW9uKSB7XG5cdGxldCB3YXNfaHlkcmF0aW5nID0gaHlkcmF0aW5nO1xuXG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRoeWRyYXRlX25leHQoKTtcblx0fVxuXG5cdHZhciBmaWxlbmFtZSA9IERFViAmJiBsb2NhdGlvbiAmJiBjb21wb25lbnRfY29udGV4dD8uZnVuY3Rpb25bRklMRU5BTUVdO1xuXG5cdC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cblx0dmFyIHRhZztcblxuXHQvKiogQHR5cGUge3N0cmluZyB8IG51bGx9ICovXG5cdHZhciBjdXJyZW50X3RhZztcblxuXHQvKiogQHR5cGUge251bGwgfCBFbGVtZW50fSAqL1xuXHR2YXIgZWxlbWVudCA9IG51bGw7XG5cblx0aWYgKGh5ZHJhdGluZyAmJiBoeWRyYXRlX25vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuXHRcdGVsZW1lbnQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChoeWRyYXRlX25vZGUpO1xuXHRcdGh5ZHJhdGVfbmV4dCgpO1xuXHR9XG5cblx0dmFyIGFuY2hvciA9IC8qKiBAdHlwZSB7VGVtcGxhdGVOb2RlfSAqLyAoaHlkcmF0aW5nID8gaHlkcmF0ZV9ub2RlIDogbm9kZSk7XG5cblx0LyoqIEB0eXBlIHtFZmZlY3QgfCBudWxsfSAqL1xuXHR2YXIgZWZmZWN0O1xuXG5cdC8qKlxuXHQgKiBUaGUga2V5ZWQgYHsjZWFjaCAuLi59YCBpdGVtIGJsb2NrLCBpZiBhbnksIHRoYXQgdGhpcyBlbGVtZW50IGlzIGluc2lkZS5cblx0ICogV2UgdHJhY2sgdGhpcyBzbyB3ZSBjYW4gc2V0IGl0IHdoZW4gY2hhbmdpbmcgdGhlIGVsZW1lbnQsIGFsbG93aW5nIGFueVxuXHQgKiBgYW5pbWF0ZTpgIGRpcmVjdGl2ZSB0byBiaW5kIGl0c2VsZiB0byB0aGUgY29ycmVjdCBibG9ja1xuXHQgKi9cblx0dmFyIGVhY2hfaXRlbV9ibG9jayA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXG5cdGJsb2NrKCgpID0+IHtcblx0XHRjb25zdCBuZXh0X3RhZyA9IGdldF90YWcoKSB8fCBudWxsO1xuXHRcdHZhciBucyA9IGdldF9uYW1lc3BhY2UgPyBnZXRfbmFtZXNwYWNlKCkgOiBpc19zdmcgfHwgbmV4dF90YWcgPT09ICdzdmcnID8gTkFNRVNQQUNFX1NWRyA6IG51bGw7XG5cblx0XHQvLyBBc3N1bXB0aW9uOiBOb29uZSBjaGFuZ2VzIHRoZSBuYW1lc3BhY2UgYnV0IG5vdCB0aGUgdGFnICh3aGF0IHdvdWxkIHRoYXQgZXZlbiBtZWFuPylcblx0XHRpZiAobmV4dF90YWcgPT09IHRhZykgcmV0dXJuO1xuXG5cdFx0Ly8gU2VlIGV4cGxhbmF0aW9uIG9mIGBlYWNoX2l0ZW1fYmxvY2tgIGFib3ZlXG5cdFx0dmFyIHByZXZpb3VzX2VhY2hfaXRlbSA9IGN1cnJlbnRfZWFjaF9pdGVtO1xuXHRcdHNldF9jdXJyZW50X2VhY2hfaXRlbShlYWNoX2l0ZW1fYmxvY2spO1xuXG5cdFx0aWYgKGVmZmVjdCkge1xuXHRcdFx0aWYgKG5leHRfdGFnID09PSBudWxsKSB7XG5cdFx0XHRcdC8vIHN0YXJ0IG91dHJvXG5cdFx0XHRcdHBhdXNlX2VmZmVjdChlZmZlY3QsICgpID0+IHtcblx0XHRcdFx0XHRlZmZlY3QgPSBudWxsO1xuXHRcdFx0XHRcdGN1cnJlbnRfdGFnID0gbnVsbDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKG5leHRfdGFnID09PSBjdXJyZW50X3RhZykge1xuXHRcdFx0XHQvLyBzYW1lIHRhZyBhcyBpcyBjdXJyZW50bHkgcmVuZGVyZWQgXHUyMDE0IGFib3J0IG91dHJvXG5cdFx0XHRcdHJlc3VtZV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRhZyBpcyBjaGFuZ2luZyBcdTIwMTQgZGVzdHJveSBpbW1lZGlhdGVseSwgcmVuZGVyIGNvbnRlbnRzIHdpdGhvdXQgaW50cm8gdHJhbnNpdGlvbnNcblx0XHRcdFx0ZGVzdHJveV9lZmZlY3QoZWZmZWN0KTtcblx0XHRcdFx0c2V0X3Nob3VsZF9pbnRybyhmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKG5leHRfdGFnICYmIG5leHRfdGFnICE9PSBjdXJyZW50X3RhZykge1xuXHRcdFx0ZWZmZWN0ID0gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0ZWxlbWVudCA9IGh5ZHJhdGluZ1xuXHRcdFx0XHRcdD8gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAoZWxlbWVudClcblx0XHRcdFx0XHQ6IG5zXG5cdFx0XHRcdFx0XHQ/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgbmV4dF90YWcpXG5cdFx0XHRcdFx0XHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dF90YWcpO1xuXG5cdFx0XHRcdGlmIChERVYgJiYgbG9jYXRpb24pIHtcblx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0ZWxlbWVudC5fX3N2ZWx0ZV9tZXRhID0ge1xuXHRcdFx0XHRcdFx0cGFyZW50OiBkZXZfc3RhY2ssXG5cdFx0XHRcdFx0XHRsb2M6IHtcblx0XHRcdFx0XHRcdFx0ZmlsZTogZmlsZW5hbWUsXG5cdFx0XHRcdFx0XHRcdGxpbmU6IGxvY2F0aW9uWzBdLFxuXHRcdFx0XHRcdFx0XHRjb2x1bW46IGxvY2F0aW9uWzFdXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbl9ub2RlcyhlbGVtZW50LCBlbGVtZW50KTtcblxuXHRcdFx0XHRpZiAocmVuZGVyX2ZuKSB7XG5cdFx0XHRcdFx0aWYgKGh5ZHJhdGluZyAmJiBpc19yYXdfdGV4dF9lbGVtZW50KG5leHRfdGFnKSkge1xuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCBoeWRyYXRpb24gZ2xpdGNoZXNcblx0XHRcdFx0XHRcdGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJZiBoeWRyYXRpbmcsIHVzZSB0aGUgZXhpc3Rpbmcgc3NyIGNvbW1lbnQgYXMgdGhlIGFuY2hvciBzbyB0aGF0IHRoZVxuXHRcdFx0XHRcdC8vIGlubmVyIG9wZW4gYW5kIGNsb3NlIG1ldGhvZHMgY2FuIHBpY2sgdXAgdGhlIGV4aXN0aW5nIG5vZGVzIGNvcnJlY3RseVxuXHRcdFx0XHRcdHZhciBjaGlsZF9hbmNob3IgPSAvKiogQHR5cGUge1RlbXBsYXRlTm9kZX0gKi8gKFxuXHRcdFx0XHRcdFx0aHlkcmF0aW5nID8gZ2V0X2ZpcnN0X2NoaWxkKGVsZW1lbnQpIDogZWxlbWVudC5hcHBlbmRDaGlsZChjcmVhdGVfdGV4dCgpKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2hpbGRfYW5jaG9yID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHNldF9oeWRyYXRpbmcoZmFsc2UpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2V0X2h5ZHJhdGVfbm9kZShjaGlsZF9hbmNob3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGBjaGlsZF9hbmNob3JgIGlzIHVuZGVmaW5lZCBpZiB0aGlzIGlzIGEgdm9pZCBlbGVtZW50LCBidXQgd2Ugc3RpbGxcblx0XHRcdFx0XHQvLyBuZWVkIHRvIGNhbGwgYHJlbmRlcl9mbmAgaW4gb3JkZXIgdG8gcnVuIGFjdGlvbnMgZXRjLiBJZiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdC8vIGNvbnRhaW5zIGNoaWxkcmVuLCBpdCdzIGEgdXNlciBlcnJvciAod2hpY2ggaXMgd2FybmVkIG9uIGVsc2V3aGVyZSlcblx0XHRcdFx0XHQvLyBhbmQgdGhlIERPTSB3aWxsIGJlIHNpbGVudGx5IGRpc2NhcmRlZFxuXHRcdFx0XHRcdHJlbmRlcl9mbihlbGVtZW50LCBjaGlsZF9hbmNob3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gd2UgZG8gdGhpcyBhZnRlciBjYWxsaW5nIGByZW5kZXJfZm5gIHNvIHRoYXQgY2hpbGQgZWZmZWN0cyBkb24ndCBvdmVycmlkZSBgbm9kZXMuZW5kYFxuXHRcdFx0XHQvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpLm5vZGVzX2VuZCA9IGVsZW1lbnQ7XG5cblx0XHRcdFx0YW5jaG9yLmJlZm9yZShlbGVtZW50KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRhZyA9IG5leHRfdGFnO1xuXHRcdGlmICh0YWcpIGN1cnJlbnRfdGFnID0gdGFnO1xuXHRcdHNldF9zaG91bGRfaW50cm8odHJ1ZSk7XG5cblx0XHRzZXRfY3VycmVudF9lYWNoX2l0ZW0ocHJldmlvdXNfZWFjaF9pdGVtKTtcblx0fSwgRUZGRUNUX1RSQU5TUEFSRU5UKTtcblxuXHRpZiAod2FzX2h5ZHJhdGluZykge1xuXHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdFx0c2V0X2h5ZHJhdGVfbm9kZShhbmNob3IpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyByZWdpc3Rlcl9zdHlsZSB9IGZyb20gJy4uL2Rldi9jc3MuanMnO1xuaW1wb3J0IHsgZWZmZWN0IH0gZnJvbSAnLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IGFuY2hvclxuICogQHBhcmFtIHt7IGhhc2g6IHN0cmluZywgY29kZTogc3RyaW5nIH19IGNzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kX3N0eWxlcyhhbmNob3IsIGNzcykge1xuXHQvLyBVc2UgYHF1ZXVlX21pY3JvX3Rhc2tgIHRvIGVuc3VyZSBgYW5jaG9yYCBpcyBpbiB0aGUgRE9NLCBvdGhlcndpc2UgZ2V0Um9vdE5vZGUoKSB3aWxsIHlpZWxkIHdyb25nIHJlc3VsdHNcblx0ZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgcm9vdCA9IGFuY2hvci5nZXRSb290Tm9kZSgpO1xuXG5cdFx0dmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3Rcblx0XHRcdD8gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdClcblx0XHRcdDogLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHJvb3QpLmhlYWQgPz8gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHJvb3Qub3duZXJEb2N1bWVudCkuaGVhZDtcblxuXHRcdC8vIEFsd2F5cyBxdWVyeWluZyB0aGUgRE9NIGlzIHJvdWdobHkgdGhlIHNhbWUgcGVyZiBhcyBhZGRpdGlvbmFsbHkgY2hlY2tpbmcgZm9yIHByZXNlbmNlIGluIGEgbWFwIGZpcnN0IGFzc3VtaW5nXG5cdFx0Ly8gdGhhdCB5b3UnbGwgZ2V0IGNhY2hlIGhpdHMgaGFsZiBvZiB0aGUgdGltZSwgc28gd2UganVzdCBhbHdheXMgcXVlcnkgdGhlIGRvbSBmb3Igc2ltcGxpY2l0eSBhbmQgY29kZSBzYXZpbmdzLlxuXHRcdGlmICghdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJyMnICsgY3NzLmhhc2gpKSB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdFx0XHRzdHlsZS5pZCA9IGNzcy5oYXNoO1xuXHRcdFx0c3R5bGUudGV4dENvbnRlbnQgPSBjc3MuY29kZTtcblxuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblxuXHRcdFx0aWYgKERFVikge1xuXHRcdFx0XHRyZWdpc3Rlcl9zdHlsZShjc3MuaGFzaCwgc3R5bGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBBY3Rpb25QYXlsb2FkIH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IGVmZmVjdCwgcmVuZGVyX2VmZmVjdCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBzYWZlX25vdF9lcXVhbCB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvZXF1YWxpdHkuanMnO1xuaW1wb3J0IHsgZGVlcF9yZWFkX3N0YXRlLCB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5cbi8qKlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKiBAcGFyYW0geyhkb206IEVsZW1lbnQsIHZhbHVlPzogUCkgPT4gQWN0aW9uUGF5bG9hZDxQPn0gYWN0aW9uXG4gKiBAcGFyYW0geygpID0+IFB9IFtnZXRfdmFsdWVdXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFjdGlvbihkb20sIGFjdGlvbiwgZ2V0X3ZhbHVlKSB7XG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHBheWxvYWQgPSB1bnRyYWNrKCgpID0+IGFjdGlvbihkb20sIGdldF92YWx1ZT8uKCkpIHx8IHt9KTtcblxuXHRcdGlmIChnZXRfdmFsdWUgJiYgcGF5bG9hZD8udXBkYXRlKSB7XG5cdFx0XHR2YXIgaW5pdGVkID0gZmFsc2U7XG5cdFx0XHQvKiogQHR5cGUge1B9ICovXG5cdFx0XHR2YXIgcHJldiA9IC8qKiBAdHlwZSB7YW55fSAqLyAoe30pOyAvLyBpbml0aWFsaXplIHdpdGggc29tZXRoaW5nIHNvIGl0J3MgbmV2ZXIgZXF1YWwgb24gZmlyc3QgcnVuXG5cblx0XHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBnZXRfdmFsdWUoKTtcblxuXHRcdFx0XHQvLyBBY3Rpb24ncyB1cGRhdGUgbWV0aG9kIGlzIGNvYXJzZS1ncmFpbmVkLCBpLmUuIHdoZW4gYW55dGhpbmcgaW4gdGhlIHBhc3NlZCB2YWx1ZSBjaGFuZ2VzLCB1cGRhdGUuXG5cdFx0XHRcdC8vIFRoaXMgd29ya3MgaW4gbGVnYWN5IG1vZGUgYmVjYXVzZSBvZiBtdXRhYmxlX3NvdXJjZSBiZWluZyB1cGRhdGVkIGFzIGEgd2hvbGUsIGJ1dCB3aGVuIHVzaW5nICRzdGF0ZVxuXHRcdFx0XHQvLyB0b2dldGhlciB3aXRoIGFjdGlvbnMgYW5kIG11dGF0aW9uLCBpdCB3b3VsZG4ndCBub3RpY2UgdGhlIGNoYW5nZSB3aXRob3V0IGEgZGVlcCByZWFkLlxuXHRcdFx0XHRkZWVwX3JlYWRfc3RhdGUodmFsdWUpO1xuXG5cdFx0XHRcdGlmIChpbml0ZWQgJiYgc2FmZV9ub3RfZXF1YWwocHJldiwgdmFsdWUpKSB7XG5cdFx0XHRcdFx0cHJldiA9IHZhbHVlO1xuXHRcdFx0XHRcdC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChwYXlsb2FkLnVwZGF0ZSkodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0aW5pdGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAocGF5bG9hZD8uZGVzdHJveSkge1xuXHRcdFx0cmV0dXJuICgpID0+IC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChwYXlsb2FkLmRlc3Ryb3kpKCk7XG5cdFx0fVxuXHR9KTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBibG9jaywgYnJhbmNoLCBlZmZlY3QsIGRlc3Ryb3lfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcblxuLy8gVE9ETyBpbiA2LjAgb3IgNy4wLCB3aGVuIHdlIHJlbW92ZSBsZWdhY3kgbW9kZSwgd2UgY2FuIHNpbXBsaWZ5IHRoaXMgYnlcbi8vIGdldHRpbmcgcmlkIG9mIHRoZSBibG9jay9icmFuY2ggc3R1ZmYgYW5kIGp1c3QgbGV0dGluZyB0aGUgZWZmZWN0IHJpcC5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvMTU5NjJcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7KCkgPT4gKG5vZGU6IEVsZW1lbnQpID0+IHZvaWR9IGdldF9mblxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoKG5vZGUsIGdldF9mbikge1xuXHQvKiogQHR5cGUge2ZhbHNlIHwgdW5kZWZpbmVkIHwgKChub2RlOiBFbGVtZW50KSA9PiB2b2lkKX0gKi9cblx0dmFyIGZuID0gdW5kZWZpbmVkO1xuXG5cdC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi9cblx0dmFyIGU7XG5cblx0YmxvY2soKCkgPT4ge1xuXHRcdGlmIChmbiAhPT0gKGZuID0gZ2V0X2ZuKCkpKSB7XG5cdFx0XHRpZiAoZSkge1xuXHRcdFx0XHRkZXN0cm95X2VmZmVjdChlKTtcblx0XHRcdFx0ZSA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmbikge1xuXHRcdFx0XHRlID0gYnJhbmNoKCgpID0+IHtcblx0XHRcdFx0XHRlZmZlY3QoKCkgPT4gLyoqIEB0eXBlIHsobm9kZTogRWxlbWVudCkgPT4gdm9pZH0gKi8gKGZuKShub2RlKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG4iLCAiY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiPF0vZztcbmNvbnN0IENPTlRFTlRfUkVHRVggPSAvWyY8XS9nO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc19hdHRyXVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlX2h0bWwodmFsdWUsIGlzX2F0dHIpIHtcblx0Y29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlID8/ICcnKTtcblxuXHRjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuXHRwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG5cblx0bGV0IGVzY2FwZWQgPSAnJztcblx0bGV0IGxhc3QgPSAwO1xuXG5cdHdoaWxlIChwYXR0ZXJuLnRlc3Qoc3RyKSkge1xuXHRcdGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG5cdFx0Y29uc3QgY2ggPSBzdHJbaV07XG5cdFx0ZXNjYXBlZCArPSBzdHIuc3Vic3RyaW5nKGxhc3QsIGkpICsgKGNoID09PSAnJicgPyAnJmFtcDsnIDogY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7Jyk7XG5cdFx0bGFzdCA9IGkgKyAxO1xuXHR9XG5cblx0cmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuIiwgImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbz1lLmxlbmd0aDtmb3IodD0wO3Q8bzt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpfWVsc2UgZm9yKGYgaW4gZSllW2ZdJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCIsbz1hcmd1bWVudHMubGVuZ3RoO2Y8bztmKyspKGU9YXJndW1lbnRzW2ZdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwgImltcG9ydCB7IGVzY2FwZV9odG1sIH0gZnJvbSAnLi4vLi4vZXNjYXBpbmcuanMnO1xuaW1wb3J0IHsgY2xzeCBhcyBfY2xzeCB9IGZyb20gJ2Nsc3gnO1xuXG4vKipcbiAqIGA8ZGl2IHRyYW5zbGF0ZT17ZmFsc2V9PmAgc2hvdWxkIGJlIHJlbmRlcmVkIGFzIGA8ZGl2IHRyYW5zbGF0ZT1cIm5vXCI+YCBhbmQgX25vdF9cbiAqIGA8ZGl2IHRyYW5zbGF0ZT1cImZhbHNlXCI+YCwgd2hpY2ggaXMgZXF1aXZhbGVudCB0byBgPGRpdiB0cmFuc2xhdGU9XCJ5ZXNcIj5gLiBUaGVyZVxuICogbWF5IGJlIG90aGVyIG9kZCBjYXNlcyB0aGF0IG5lZWQgdG8gYmUgYWRkZWQgdG8gdGhpcyBsaXN0IGluIGZ1dHVyZVxuICogQHR5cGUge1JlY29yZDxzdHJpbmcsIE1hcDxhbnksIHN0cmluZz4+fVxuICovXG5jb25zdCByZXBsYWNlbWVudHMgPSB7XG5cdHRyYW5zbGF0ZTogbmV3IE1hcChbXG5cdFx0W3RydWUsICd5ZXMnXSxcblx0XHRbZmFsc2UsICdubyddXG5cdF0pXG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbaXNfYm9vbGVhbl1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyKG5hbWUsIHZhbHVlLCBpc19ib29sZWFuID0gZmFsc2UpIHtcblx0aWYgKHZhbHVlID09IG51bGwgfHwgKCF2YWx1ZSAmJiBpc19ib29sZWFuKSkgcmV0dXJuICcnO1xuXHRjb25zdCBub3JtYWxpemVkID0gKG5hbWUgaW4gcmVwbGFjZW1lbnRzICYmIHJlcGxhY2VtZW50c1tuYW1lXS5nZXQodmFsdWUpKSB8fCB2YWx1ZTtcblx0Y29uc3QgYXNzaWdubWVudCA9IGlzX2Jvb2xlYW4gPyAnJyA6IGA9XCIke2VzY2FwZV9odG1sKG5vcm1hbGl6ZWQsIHRydWUpfVwiYDtcblx0cmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuXG4vKipcbiAqIFNtYWxsIHdyYXBwZXIgYXJvdW5kIGNsc3ggdG8gcHJlc2VydmUgU3ZlbHRlJ3MgKHdlaXJkKSBoYW5kbGluZyBvZiBmYWxzeSB2YWx1ZXMuXG4gKiBUT0RPIFN2ZWx0ZSA2IHJldmlzaXQgdGhpcywgYW5kIGxpa2VseSB0dXJuIGFsbCBmYWxzeSB2YWx1ZXMgaW50byB0aGUgZW1wdHkgc3RyaW5nICh3aGF0IGNsc3ggYWxzbyBkb2VzKVxuICogQHBhcmFtICB7YW55fSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xzeCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdHJldHVybiBfY2xzeCh2YWx1ZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHZhbHVlID8/ICcnO1xuXHR9XG59XG5cbmNvbnN0IHdoaXRlc3BhY2UgPSBbLi4uJyBcXHRcXG5cXHJcXGZcXHUwMGEwXFx1MDAwYlxcdWZlZmYnXTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gW2hhc2hdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGJvb2xlYW4+fSBbZGlyZWN0aXZlc11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fY2xhc3ModmFsdWUsIGhhc2gsIGRpcmVjdGl2ZXMpIHtcblx0dmFyIGNsYXNzbmFtZSA9IHZhbHVlID09IG51bGwgPyAnJyA6ICcnICsgdmFsdWU7XG5cblx0aWYgKGhhc2gpIHtcblx0XHRjbGFzc25hbWUgPSBjbGFzc25hbWUgPyBjbGFzc25hbWUgKyAnICcgKyBoYXNoIDogaGFzaDtcblx0fVxuXG5cdGlmIChkaXJlY3RpdmVzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGRpcmVjdGl2ZXMpIHtcblx0XHRcdGlmIChkaXJlY3RpdmVzW2tleV0pIHtcblx0XHRcdFx0Y2xhc3NuYW1lID0gY2xhc3NuYW1lID8gY2xhc3NuYW1lICsgJyAnICsga2V5IDoga2V5O1xuXHRcdFx0fSBlbHNlIGlmIChjbGFzc25hbWUubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBsZW4gPSBrZXkubGVuZ3RoO1xuXHRcdFx0XHR2YXIgYSA9IDA7XG5cblx0XHRcdFx0d2hpbGUgKChhID0gY2xhc3NuYW1lLmluZGV4T2Yoa2V5LCBhKSkgPj0gMCkge1xuXHRcdFx0XHRcdHZhciBiID0gYSArIGxlbjtcblxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdChhID09PSAwIHx8IHdoaXRlc3BhY2UuaW5jbHVkZXMoY2xhc3NuYW1lW2EgLSAxXSkpICYmXG5cdFx0XHRcdFx0XHQoYiA9PT0gY2xhc3NuYW1lLmxlbmd0aCB8fCB3aGl0ZXNwYWNlLmluY2x1ZGVzKGNsYXNzbmFtZVtiXSkpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRjbGFzc25hbWUgPSAoYSA9PT0gMCA/ICcnIDogY2xhc3NuYW1lLnN1YnN0cmluZygwLCBhKSkgKyBjbGFzc25hbWUuc3Vic3RyaW5nKGIgKyAxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YSA9IGI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNsYXNzbmFtZSA9PT0gJycgPyBudWxsIDogY2xhc3NuYW1lO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsYW55Pn0gc3R5bGVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGltcG9ydGFudFxuICovXG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHN0eWxlcywgaW1wb3J0YW50ID0gZmFsc2UpIHtcblx0dmFyIHNlcGFyYXRvciA9IGltcG9ydGFudCA/ICcgIWltcG9ydGFudDsnIDogJzsnO1xuXHR2YXIgY3NzID0gJyc7XG5cblx0Zm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuXHRcdHZhciB2YWx1ZSA9IHN0eWxlc1trZXldO1xuXHRcdGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJykge1xuXHRcdFx0Y3NzICs9ICcgJyArIGtleSArICc6ICcgKyB2YWx1ZSArIHNlcGFyYXRvcjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3NzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b19jc3NfbmFtZShuYW1lKSB7XG5cdGlmIChuYW1lWzBdICE9PSAnLScgfHwgbmFtZVsxXSAhPT0gJy0nKSB7XG5cdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fVxuXHRyZXR1cm4gbmFtZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55PiB8IFtSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+XX0gW3N0eWxlc11cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9fc3R5bGUodmFsdWUsIHN0eWxlcykge1xuXHRpZiAoc3R5bGVzKSB7XG5cdFx0dmFyIG5ld19zdHlsZSA9ICcnO1xuXG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLGFueT4gfCB1bmRlZmluZWR9ICovXG5cdFx0dmFyIG5vcm1hbF9zdHlsZXM7XG5cblx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsYW55PiB8IHVuZGVmaW5lZH0gKi9cblx0XHR2YXIgaW1wb3J0YW50X3N0eWxlcztcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcblx0XHRcdG5vcm1hbF9zdHlsZXMgPSBzdHlsZXNbMF07XG5cdFx0XHRpbXBvcnRhbnRfc3R5bGVzID0gc3R5bGVzWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxfc3R5bGVzID0gc3R5bGVzO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dmFsdWUgPSBTdHJpbmcodmFsdWUpXG5cdFx0XHRcdC5yZXBsYWNlQWxsKC9cXHMqXFwvXFwqLio/XFwqXFwvXFxzKi9nLCAnJylcblx0XHRcdFx0LnRyaW0oKTtcblxuXHRcdFx0LyoqIEB0eXBlIHtib29sZWFuIHwgJ1wiJyB8IFwiJ1wifSAqL1xuXHRcdFx0dmFyIGluX3N0ciA9IGZhbHNlO1xuXHRcdFx0dmFyIGluX2FwbyA9IDA7XG5cdFx0XHR2YXIgaW5fY29tbWVudCA9IGZhbHNlO1xuXG5cdFx0XHR2YXIgcmVzZXJ2ZWRfbmFtZXMgPSBbXTtcblxuXHRcdFx0aWYgKG5vcm1hbF9zdHlsZXMpIHtcblx0XHRcdFx0cmVzZXJ2ZWRfbmFtZXMucHVzaCguLi5PYmplY3Qua2V5cyhub3JtYWxfc3R5bGVzKS5tYXAodG9fY3NzX25hbWUpKTtcblx0XHRcdH1cblx0XHRcdGlmIChpbXBvcnRhbnRfc3R5bGVzKSB7XG5cdFx0XHRcdHJlc2VydmVkX25hbWVzLnB1c2goLi4uT2JqZWN0LmtleXMoaW1wb3J0YW50X3N0eWxlcykubWFwKHRvX2Nzc19uYW1lKSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdGFydF9pbmRleCA9IDA7XG5cdFx0XHR2YXIgbmFtZV9pbmRleCA9IC0xO1xuXG5cdFx0XHRjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gdmFsdWVbaV07XG5cblx0XHRcdFx0aWYgKGluX2NvbW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoYyA9PT0gJy8nICYmIHZhbHVlW2kgLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRcdFx0XHRpbl9jb21tZW50ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGluX3N0cikge1xuXHRcdFx0XHRcdGlmIChpbl9zdHIgPT09IGMpIHtcblx0XHRcdFx0XHRcdGluX3N0ciA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnLycgJiYgdmFsdWVbaSArIDFdID09PSAnKicpIHtcblx0XHRcdFx0XHRpbl9jb21tZW50ID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnXCInIHx8IGMgPT09IFwiJ1wiKSB7XG5cdFx0XHRcdFx0aW5fc3RyID0gYztcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnKCcpIHtcblx0XHRcdFx0XHRpbl9hcG8rKztcblx0XHRcdFx0fSBlbHNlIGlmIChjID09PSAnKScpIHtcblx0XHRcdFx0XHRpbl9hcG8tLTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaW5fY29tbWVudCAmJiBpbl9zdHIgPT09IGZhbHNlICYmIGluX2FwbyA9PT0gMCkge1xuXHRcdFx0XHRcdGlmIChjID09PSAnOicgJiYgbmFtZV9pbmRleCA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdG5hbWVfaW5kZXggPSBpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYyA9PT0gJzsnIHx8IGkgPT09IGxlbiAtIDEpIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lX2luZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgbmFtZSA9IHRvX2Nzc19uYW1lKHZhbHVlLnN1YnN0cmluZyhzdGFydF9pbmRleCwgbmFtZV9pbmRleCkudHJpbSgpKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXJlc2VydmVkX25hbWVzLmluY2x1ZGVzKG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGMgIT09ICc7Jykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eSA9IHZhbHVlLnN1YnN0cmluZyhzdGFydF9pbmRleCwgaSkudHJpbSgpO1xuXHRcdFx0XHRcdFx0XHRcdG5ld19zdHlsZSArPSAnICcgKyBwcm9wZXJ0eSArICc7Jztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydF9pbmRleCA9IGkgKyAxO1xuXHRcdFx0XHRcdFx0bmFtZV9pbmRleCA9IC0xO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChub3JtYWxfc3R5bGVzKSB7XG5cdFx0XHRuZXdfc3R5bGUgKz0gYXBwZW5kX3N0eWxlcyhub3JtYWxfc3R5bGVzKTtcblx0XHR9XG5cblx0XHRpZiAoaW1wb3J0YW50X3N0eWxlcykge1xuXHRcdFx0bmV3X3N0eWxlICs9IGFwcGVuZF9zdHlsZXMoaW1wb3J0YW50X3N0eWxlcywgdHJ1ZSk7XG5cdFx0fVxuXG5cdFx0bmV3X3N0eWxlID0gbmV3X3N0eWxlLnRyaW0oKTtcblx0XHRyZXR1cm4gbmV3X3N0eWxlID09PSAnJyA/IG51bGwgOiBuZXdfc3R5bGU7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiBTdHJpbmcodmFsdWUpO1xufVxuIiwgImltcG9ydCB7IHRvX2NsYXNzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2F0dHJpYnV0ZXMuanMnO1xuaW1wb3J0IHsgaHlkcmF0aW5nIH0gZnJvbSAnLi4vaHlkcmF0aW9uLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtib29sZWFuIHwgbnVtYmVyfSBpc19odG1sXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2hhc2hdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFtwcmV2X2NsYXNzZXNdXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFtuZXh0X2NsYXNzZXNdXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYm9vbGVhbj4gfCB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2xhc3MoZG9tLCBpc19odG1sLCB2YWx1ZSwgaGFzaCwgcHJldl9jbGFzc2VzLCBuZXh0X2NsYXNzZXMpIHtcblx0Ly8gQHRzLWV4cGVjdC1lcnJvciBuZWVkIHRvIGFkZCBfX2NsYXNzTmFtZSB0byBwYXRjaGVkIHByb3RvdHlwZVxuXHR2YXIgcHJldiA9IGRvbS5fX2NsYXNzTmFtZTtcblxuXHRpZiAoXG5cdFx0aHlkcmF0aW5nIHx8XG5cdFx0cHJldiAhPT0gdmFsdWUgfHxcblx0XHRwcmV2ID09PSB1bmRlZmluZWQgLy8gZm9yIGVkZ2UgY2FzZSBvZiBgY2xhc3M9e3VuZGVmaW5lZH1gXG5cdCkge1xuXHRcdHZhciBuZXh0X2NsYXNzX25hbWUgPSB0b19jbGFzcyh2YWx1ZSwgaGFzaCwgbmV4dF9jbGFzc2VzKTtcblxuXHRcdGlmICghaHlkcmF0aW5nIHx8IG5leHRfY2xhc3NfbmFtZSAhPT0gZG9tLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSkge1xuXHRcdFx0Ly8gUmVtb3ZpbmcgdGhlIGF0dHJpYnV0ZSB3aGVuIHRoZSB2YWx1ZSBpcyBvbmx5IGFuIGVtcHR5IHN0cmluZyBjYXVzZXNcblx0XHRcdC8vIHBlcmZvcm1hbmNlIGlzc3VlcyB2cyBzaW1wbHkgbWFraW5nIHRoZSBjbGFzc05hbWUgYW4gZW1wdHkgc3RyaW5nLiBTb1xuXHRcdFx0Ly8gd2Ugc2hvdWxkIG9ubHkgcmVtb3ZlIHRoZSBjbGFzcyBpZiB0aGUgdmFsdWUgaXMgbnVsbGlzaFxuXHRcdFx0Ly8gYW5kIHRoZXJlIG5vIGhhc2gvZGlyZWN0aXZlcyA6XG5cdFx0XHRpZiAobmV4dF9jbGFzc19uYW1lID09IG51bGwpIHtcblx0XHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNfaHRtbCkge1xuXHRcdFx0XHRkb20uY2xhc3NOYW1lID0gbmV4dF9jbGFzc19uYW1lO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9tLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBuZXh0X2NsYXNzX25hbWUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgbmVlZCB0byBhZGQgX19jbGFzc05hbWUgdG8gcGF0Y2hlZCBwcm90b3R5cGVcblx0XHRkb20uX19jbGFzc05hbWUgPSB2YWx1ZTtcblx0fSBlbHNlIGlmIChuZXh0X2NsYXNzZXMgJiYgcHJldl9jbGFzc2VzICE9PSBuZXh0X2NsYXNzZXMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gbmV4dF9jbGFzc2VzKSB7XG5cdFx0XHR2YXIgaXNfcHJlc2VudCA9ICEhbmV4dF9jbGFzc2VzW2tleV07XG5cblx0XHRcdGlmIChwcmV2X2NsYXNzZXMgPT0gbnVsbCB8fCBpc19wcmVzZW50ICE9PSAhIXByZXZfY2xhc3Nlc1trZXldKSB7XG5cdFx0XHRcdGRvbS5jbGFzc0xpc3QudG9nZ2xlKGtleSwgaXNfcHJlc2VudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5leHRfY2xhc3Nlcztcbn1cbiIsICJpbXBvcnQgeyB0b19zdHlsZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9hdHRyaWJ1dGVzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBkb21cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gcHJldlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBuZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByaW9yaXR5XVxuICovXG5mdW5jdGlvbiB1cGRhdGVfc3R5bGVzKGRvbSwgcHJldiA9IHt9LCBuZXh0LCBwcmlvcml0eSkge1xuXHRmb3IgKHZhciBrZXkgaW4gbmV4dCkge1xuXHRcdHZhciB2YWx1ZSA9IG5leHRba2V5XTtcblxuXHRcdGlmIChwcmV2W2tleV0gIT09IHZhbHVlKSB7XG5cdFx0XHRpZiAobmV4dFtrZXldID09IG51bGwpIHtcblx0XHRcdFx0ZG9tLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb20uc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgcHJpb3JpdHkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCAmIEVsZW1lbnRDU1NJbmxpbmVTdHlsZX0gZG9tXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHZhbHVlXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT4gfCBbUmVjb3JkPHN0cmluZywgYW55PiwgUmVjb3JkPHN0cmluZywgYW55Pl19IFtwcmV2X3N0eWxlc11cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55PiB8IFtSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+XX0gW25leHRfc3R5bGVzXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3N0eWxlKGRvbSwgdmFsdWUsIHByZXZfc3R5bGVzLCBuZXh0X3N0eWxlcykge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdHZhciBwcmV2ID0gZG9tLl9fc3R5bGU7XG5cblx0aWYgKGh5ZHJhdGluZyB8fCBwcmV2ICE9PSB2YWx1ZSkge1xuXHRcdHZhciBuZXh0X3N0eWxlX2F0dHIgPSB0b19zdHlsZSh2YWx1ZSwgbmV4dF9zdHlsZXMpO1xuXG5cdFx0aWYgKCFoeWRyYXRpbmcgfHwgbmV4dF9zdHlsZV9hdHRyICE9PSBkb20uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG5cdFx0XHRpZiAobmV4dF9zdHlsZV9hdHRyID09IG51bGwpIHtcblx0XHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gbmV4dF9zdHlsZV9hdHRyO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRkb20uX19zdHlsZSA9IHZhbHVlO1xuXHR9IGVsc2UgaWYgKG5leHRfc3R5bGVzKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobmV4dF9zdHlsZXMpKSB7XG5cdFx0XHR1cGRhdGVfc3R5bGVzKGRvbSwgcHJldl9zdHlsZXM/LlswXSwgbmV4dF9zdHlsZXNbMF0pO1xuXHRcdFx0dXBkYXRlX3N0eWxlcyhkb20sIHByZXZfc3R5bGVzPy5bMV0sIG5leHRfc3R5bGVzWzFdLCAnaW1wb3J0YW50Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHVwZGF0ZV9zdHlsZXMoZG9tLCBwcmV2X3N0eWxlcywgbmV4dF9zdHlsZXMpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXh0X3N0eWxlcztcbn1cbiIsICJpbXBvcnQgeyBlZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IGlzX2FycmF5IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vLi4vLi4vd2FybmluZ3MuanMnO1xuXG4vKipcbiAqIFNlbGVjdHMgdGhlIGNvcnJlY3Qgb3B0aW9uKHMpIChkZXBlbmRpbmcgb24gd2hldGhlciB0aGlzIGlzIGEgbXVsdGlwbGUgc2VsZWN0KVxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7SFRNTFNlbGVjdEVsZW1lbnR9IHNlbGVjdFxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBtb3VudGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlLCBtb3VudGluZyA9IGZhbHNlKSB7XG5cdGlmIChzZWxlY3QubXVsdGlwbGUpIHtcblx0XHQvLyBJZiB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwga2VlcCB0aGUgc2VsZWN0aW9uIGFzIGlzXG5cdFx0aWYgKHZhbHVlID09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vdCBhbiBhcnJheSwgd2FybiBhbmQga2VlcCB0aGUgc2VsZWN0aW9uIGFzIGlzXG5cdFx0aWYgKCFpc19hcnJheSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB3LnNlbGVjdF9tdWx0aXBsZV9pbnZhbGlkX3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCB1cGRhdGUgdGhlIHNlbGVjdGlvblxuXHRcdGZvciAodmFyIG9wdGlvbiBvZiBzZWxlY3Qub3B0aW9ucykge1xuXHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5jbHVkZXMoZ2V0X29wdGlvbl92YWx1ZShvcHRpb24pKTtcblx0XHR9XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXHRmb3IgKG9wdGlvbiBvZiBzZWxlY3Qub3B0aW9ucykge1xuXHRcdHZhciBvcHRpb25fdmFsdWUgPSBnZXRfb3B0aW9uX3ZhbHVlKG9wdGlvbik7XG5cdFx0aWYgKGlzKG9wdGlvbl92YWx1ZSwgdmFsdWUpKSB7XG5cdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0fVxuXG5cdGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHNlbGVjdC5zZWxlY3RlZEluZGV4ID0gLTE7IC8vIG5vIG9wdGlvbiBzaG91bGQgYmUgc2VsZWN0ZWRcblx0fVxufVxuXG4vKipcbiAqIFNlbGVjdHMgdGhlIGNvcnJlY3Qgb3B0aW9uKHMpIGlmIGB2YWx1ZWAgaXMgZ2l2ZW4sXG4gKiBhbmQgdGhlbiBzZXRzIHVwIGEgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gc3luYyB0aGVcbiAqIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBkb20gd2hlbiBpdCBjaGFuZ2VzLiBTdWNoXG4gKiBjaGFuZ2VzIGNvdWxkIGZvciBleGFtcGxlIG9jY3VyIHdoZW4gb3B0aW9ucyBhcmVcbiAqIGluc2lkZSBhbiBgI2VhY2hgIGJsb2NrLlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0X3NlbGVjdChzZWxlY3QpIHtcblx0dmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRzZWxlY3Rfb3B0aW9uKHNlbGVjdCwgc2VsZWN0Ll9fdmFsdWUpO1xuXHRcdC8vIERlbGliZXJhdGVseSBkb24ndCB1cGRhdGUgdGhlIHBvdGVudGlhbCBiaW5kaW5nIHZhbHVlLFxuXHRcdC8vIHRoZSBtb2RlbCBzaG91bGQgYmUgcHJlc2VydmVkIHVubGVzcyBleHBsaWNpdGx5IGNoYW5nZWRcblx0fSk7XG5cblx0b2JzZXJ2ZXIub2JzZXJ2ZShzZWxlY3QsIHtcblx0XHQvLyBMaXN0ZW4gdG8gb3B0aW9uIGVsZW1lbnQgY2hhbmdlc1xuXHRcdGNoaWxkTGlzdDogdHJ1ZSxcblx0XHRzdWJ0cmVlOiB0cnVlLCAvLyBiZWNhdXNlIG9mIDxvcHRncm91cD5cblx0XHQvLyBMaXN0ZW4gdG8gb3B0aW9uIGVsZW1lbnQgdmFsdWUgYXR0cmlidXRlIGNoYW5nZXNcblx0XHQvLyAoZG9lc24ndCBnZXQgbm90aWZpZWQgb2Ygc2VsZWN0IHZhbHVlIGNoYW5nZXMsXG5cdFx0Ly8gYmVjYXVzZSB0aGF0IHByb3BlcnR5IGlzIG5vdCByZWZsZWN0ZWQgYXMgYW4gYXR0cmlidXRlKVxuXHRcdGF0dHJpYnV0ZXM6IHRydWUsXG5cdFx0YXR0cmlidXRlRmlsdGVyOiBbJ3ZhbHVlJ11cblx0fSk7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3NlbGVjdF92YWx1ZShzZWxlY3QsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBtb3VudGluZyA9IHRydWU7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChzZWxlY3QsICdjaGFuZ2UnLCAoaXNfcmVzZXQpID0+IHtcblx0XHR2YXIgcXVlcnkgPSBpc19yZXNldCA/ICdbc2VsZWN0ZWRdJyA6ICc6Y2hlY2tlZCc7XG5cdFx0LyoqIEB0eXBlIHt1bmtub3dufSAqL1xuXHRcdHZhciB2YWx1ZTtcblxuXHRcdGlmIChzZWxlY3QubXVsdGlwbGUpIHtcblx0XHRcdHZhbHVlID0gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpLCBnZXRfb3B0aW9uX3ZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0LyoqIEB0eXBlIHtIVE1MT3B0aW9uRWxlbWVudCB8IG51bGx9ICovXG5cdFx0XHR2YXIgc2VsZWN0ZWRfb3B0aW9uID1cblx0XHRcdFx0c2VsZWN0LnF1ZXJ5U2VsZWN0b3IocXVlcnkpID8/XG5cdFx0XHRcdC8vIHdpbGwgZmFsbCBiYWNrIHRvIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24gaWYgbm8gb3B0aW9uIGlzIHNlbGVjdGVkXG5cdFx0XHRcdHNlbGVjdC5xdWVyeVNlbGVjdG9yKCdvcHRpb246bm90KFtkaXNhYmxlZF0pJyk7XG5cdFx0XHR2YWx1ZSA9IHNlbGVjdGVkX29wdGlvbiAmJiBnZXRfb3B0aW9uX3ZhbHVlKHNlbGVjdGVkX29wdGlvbik7XG5cdFx0fVxuXG5cdFx0c2V0KHZhbHVlKTtcblx0fSk7XG5cblx0Ly8gTmVlZHMgdG8gYmUgYW4gZWZmZWN0LCBub3QgYSByZW5kZXJfZWZmZWN0LCBzbyB0aGF0IGluIGNhc2Ugb2YgZWFjaCBsb29wcyB0aGUgbG9naWMgcnVucyBhZnRlciB0aGUgZWFjaCBibG9jayBoYXMgdXBkYXRlZFxuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IGdldCgpO1xuXHRcdHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpO1xuXG5cdFx0Ly8gTW91bnRpbmcgYW5kIHZhbHVlIHVuZGVmaW5lZCAtPiB0YWtlIHNlbGVjdGlvbiBmcm9tIGRvbVxuXHRcdGlmIChtb3VudGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHQvKiogQHR5cGUge0hUTUxPcHRpb25FbGVtZW50IHwgbnVsbH0gKi9cblx0XHRcdHZhciBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKTtcblx0XHRcdGlmIChzZWxlY3RlZF9vcHRpb24gIT09IG51bGwpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfb3B0aW9uX3ZhbHVlKHNlbGVjdGVkX29wdGlvbik7XG5cdFx0XHRcdHNldCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHNlbGVjdC5fX3ZhbHVlID0gdmFsdWU7XG5cdFx0bW91bnRpbmcgPSBmYWxzZTtcblx0fSk7XG5cblx0aW5pdF9zZWxlY3Qoc2VsZWN0KTtcbn1cblxuLyoqIEBwYXJhbSB7SFRNTE9wdGlvbkVsZW1lbnR9IG9wdGlvbiAqL1xuZnVuY3Rpb24gZ2V0X29wdGlvbl92YWx1ZShvcHRpb24pIHtcblx0Ly8gX192YWx1ZSBvbmx5IGV4aXN0cyBpZiB0aGUgPG9wdGlvbj4gaGFzIGEgdmFsdWUgYXR0cmlidXRlXG5cdGlmICgnX192YWx1ZScgaW4gb3B0aW9uKSB7XG5cdFx0cmV0dXJuIG9wdGlvbi5fX3ZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBvcHRpb24udmFsdWU7XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IEVmZmVjdCB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IGh5ZHJhdGluZywgc2V0X2h5ZHJhdGluZyB9IGZyb20gJy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvcnMsIGdldF9wcm90b3R5cGVfb2YgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlX2V2ZW50LCBkZWxlZ2F0ZSB9IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7IGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyLCBhdXRvZm9jdXMgfSBmcm9tICcuL21pc2MuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi8uLi93YXJuaW5ncy5qcyc7XG5pbXBvcnQgeyBMT0FESU5HX0FUVFJfU1lNQk9MIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgcXVldWVfaWRsZV90YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyBpc19jYXB0dXJlX2V2ZW50LCBpc19kZWxlZ2F0ZWQsIG5vcm1hbGl6ZV9hdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy5qcyc7XG5pbXBvcnQge1xuXHRhY3RpdmVfZWZmZWN0LFxuXHRhY3RpdmVfcmVhY3Rpb24sXG5cdGdldCxcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb25cbn0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBhdHRhY2ggfSBmcm9tICcuL2F0dGFjaG1lbnRzLmpzJztcbmltcG9ydCB7IGNsc3ggfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvYXR0cmlidXRlcy5qcyc7XG5pbXBvcnQgeyBzZXRfY2xhc3MgfSBmcm9tICcuL2NsYXNzLmpzJztcbmltcG9ydCB7IHNldF9zdHlsZSB9IGZyb20gJy4vc3R5bGUuanMnO1xuaW1wb3J0IHsgQVRUQUNITUVOVF9LRVksIE5BTUVTUEFDRV9IVE1MLCBVTklOSVRJQUxJWkVEIH0gZnJvbSAnLi4vLi4vLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJsb2NrLCBicmFuY2gsIGRlc3Ryb3lfZWZmZWN0LCBlZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgaW5pdF9zZWxlY3QsIHNlbGVjdF9vcHRpb24gfSBmcm9tICcuL2JpbmRpbmdzL3NlbGVjdC5qcyc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9hc3luYy5qcyc7XG5cbmV4cG9ydCBjb25zdCBDTEFTUyA9IFN5bWJvbCgnY2xhc3MnKTtcbmV4cG9ydCBjb25zdCBTVFlMRSA9IFN5bWJvbCgnc3R5bGUnKTtcblxuY29uc3QgSVNfQ1VTVE9NX0VMRU1FTlQgPSBTeW1ib2woJ2lzIGN1c3RvbSBlbGVtZW50Jyk7XG5jb25zdCBJU19IVE1MID0gU3ltYm9sKCdpcyBodG1sJyk7XG5cbi8qKlxuICogVGhlIHZhbHVlL2NoZWNrZWQgYXR0cmlidXRlIGluIHRoZSB0ZW1wbGF0ZSBhY3R1YWxseSBjb3JyZXNwb25kcyB0byB0aGUgZGVmYXVsdFZhbHVlIHByb3BlcnR5LCBzbyB3ZSBuZWVkXG4gKiB0byByZW1vdmUgaXQgdXBvbiBoeWRyYXRpb24gdG8gYXZvaWQgYSBidWcgd2hlbiBzb21lb25lIHJlc2V0cyB0aGUgZm9ybSB2YWx1ZS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlX2lucHV0X2RlZmF1bHRzKGlucHV0KSB7XG5cdGlmICghaHlkcmF0aW5nKSByZXR1cm47XG5cblx0dmFyIGFscmVhZHlfcmVtb3ZlZCA9IGZhbHNlO1xuXG5cdC8vIFdlIHRyeSBhbmQgcmVtb3ZlIHRoZSBkZWZhdWx0IGF0dHJpYnV0ZXMgbGF0ZXIsIHJhdGhlciB0aGFuIHN5bmMgZHVyaW5nIGh5ZHJhdGlvbi5cblx0Ly8gRG9pbmcgaXQgc3luYyBkdXJpbmcgaHlkcmF0aW9uIGhhcyBhIG5lZ2F0aXZlIGltcGFjdCBvbiBwZXJmb3JtYW5jZSwgYnV0IGRlZmVycmluZyB0aGVcblx0Ly8gd29yayBpbiBhbiBpZGxlIHRhc2sgYWxsZXZpYXRlcyB0aGlzIGdyZWF0bHkuIElmIGEgZm9ybSByZXNldCBldmVudCBjb21lcyBpbiBiZWZvcmVcblx0Ly8gdGhlIGlkbGUgY2FsbGJhY2ssIHRoZW4gd2UgZW5zdXJlIHRoZSBpbnB1dCBkZWZhdWx0cyBhcmUgY2xlYXJlZCBqdXN0IGJlZm9yZS5cblx0dmFyIHJlbW92ZV9kZWZhdWx0cyA9ICgpID0+IHtcblx0XHRpZiAoYWxyZWFkeV9yZW1vdmVkKSByZXR1cm47XG5cdFx0YWxyZWFkeV9yZW1vdmVkID0gdHJ1ZTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgYXR0cmlidXRlcyBidXQgcHJlc2VydmUgdGhlIHZhbHVlc1xuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGlucHV0LnZhbHVlO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ3ZhbHVlJywgbnVsbCk7XG5cdFx0XHRpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuXHRcdFx0dmFyIGNoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuXHRcdFx0c2V0X2F0dHJpYnV0ZShpbnB1dCwgJ2NoZWNrZWQnLCBudWxsKTtcblx0XHRcdGlucHV0LmNoZWNrZWQgPSBjaGVja2VkO1xuXHRcdH1cblx0fTtcblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGlucHV0Ll9fb25fciA9IHJlbW92ZV9kZWZhdWx0cztcblx0cXVldWVfaWRsZV90YXNrKHJlbW92ZV9kZWZhdWx0cyk7XG5cdGFkZF9mb3JtX3Jlc2V0X2xpc3RlbmVyKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF92YWx1ZShlbGVtZW50LCB2YWx1ZSkge1xuXHR2YXIgYXR0cmlidXRlcyA9IGdldF9hdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXG5cdGlmIChcblx0XHRhdHRyaWJ1dGVzLnZhbHVlID09PVxuXHRcdFx0KGF0dHJpYnV0ZXMudmFsdWUgPVxuXHRcdFx0XHQvLyB0cmVhdCBudWxsIGFuZCB1bmRlZmluZWQgdGhlIHNhbWUgZm9yIHRoZSBpbml0aWFsIHZhbHVlXG5cdFx0XHRcdHZhbHVlID8/IHVuZGVmaW5lZCkgfHxcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0Ly8gYHByb2dyZXNzYCBlbGVtZW50cyBhbHdheXMgbmVlZCB0aGVpciB2YWx1ZSBzZXQgd2hlbiBpdCdzIGAwYFxuXHRcdChlbGVtZW50LnZhbHVlID09PSB2YWx1ZSAmJiAodmFsdWUgIT09IDAgfHwgZWxlbWVudC5ub2RlTmFtZSAhPT0gJ1BST0dSRVNTJykpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0ZWxlbWVudC52YWx1ZSA9IHZhbHVlID8/ICcnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY2hlY2tlZChlbGVtZW50LCBjaGVja2VkKSB7XG5cdHZhciBhdHRyaWJ1dGVzID0gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCk7XG5cblx0aWYgKFxuXHRcdGF0dHJpYnV0ZXMuY2hlY2tlZCA9PT1cblx0XHQoYXR0cmlidXRlcy5jaGVja2VkID1cblx0XHRcdC8vIHRyZWF0IG51bGwgYW5kIHVuZGVmaW5lZCB0aGUgc2FtZSBmb3IgdGhlIGluaXRpYWwgdmFsdWVcblx0XHRcdGNoZWNrZWQgPz8gdW5kZWZpbmVkKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdGVsZW1lbnQuY2hlY2tlZCA9IGNoZWNrZWQ7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHNlbGVjdGVkYCBhdHRyaWJ1dGUgb24gYW4gYG9wdGlvbmAgZWxlbWVudC5cbiAqIE5vdCBzZXQgdGhyb3VnaCB0aGUgcHJvcGVydHkgYmVjYXVzZSB0aGF0IGRvZXNuJ3QgcmVmbGVjdCB0byB0aGUgRE9NLFxuICogd2hpY2ggbWVhbnMgaXQgd291bGRuJ3QgYmUgdGFrZW4gaW50byBhY2NvdW50IHdoZW4gYSBmb3JtIGlzIHJlc2V0LlxuICogQHBhcmFtIHtIVE1MT3B0aW9uRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X3NlbGVjdGVkKGVsZW1lbnQsIHNlbGVjdGVkKSB7XG5cdGlmIChzZWxlY3RlZCkge1xuXHRcdC8vIFRoZSBzZWxlY3RlZCBvcHRpb24gY291bGQndmUgY2hhbmdlZCB2aWEgdXNlciBzZWxlY3Rpb24sIGFuZFxuXHRcdC8vIHNldHRpbmcgdGhlIHZhbHVlIHdpdGhvdXQgdGhpcyBjaGVjayB3b3VsZCBzZXQgaXQgYmFjay5cblx0XHRpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnJyk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzZWxlY3RlZCcpO1xuXHR9XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgZGVmYXVsdCBjaGVja2VkIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgY2hlY2tlZCBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfZGVmYXVsdF9jaGVja2VkKGVsZW1lbnQsIGNoZWNrZWQpIHtcblx0Y29uc3QgZXhpc3RpbmdfdmFsdWUgPSBlbGVtZW50LmNoZWNrZWQ7XG5cdGVsZW1lbnQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuXHRlbGVtZW50LmNoZWNrZWQgPSBleGlzdGluZ192YWx1ZTtcbn1cblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBkZWZhdWx0IHZhbHVlIHByb3BlcnR5IHdpdGhvdXQgaW5mbHVlbmNpbmcgdGhlIGN1cnJlbnQgdmFsdWUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldF9kZWZhdWx0X3ZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG5cdGNvbnN0IGV4aXN0aW5nX3ZhbHVlID0gZWxlbWVudC52YWx1ZTtcblx0ZWxlbWVudC5kZWZhdWx0VmFsdWUgPSB2YWx1ZTtcblx0ZWxlbWVudC52YWx1ZSA9IGV4aXN0aW5nX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSB2YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcF93YXJuaW5nXVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZShlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlLCBza2lwX3dhcm5pbmcpIHtcblx0dmFyIGF0dHJpYnV0ZXMgPSBnZXRfYXR0cmlidXRlcyhlbGVtZW50KTtcblxuXHRpZiAoaHlkcmF0aW5nKSB7XG5cdFx0YXR0cmlidXRlc1thdHRyaWJ1dGVdID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblxuXHRcdGlmIChcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyYycgfHxcblx0XHRcdGF0dHJpYnV0ZSA9PT0gJ3NyY3NldCcgfHxcblx0XHRcdChhdHRyaWJ1dGUgPT09ICdocmVmJyAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSAnTElOSycpXG5cdFx0KSB7XG5cdFx0XHRpZiAoIXNraXBfd2FybmluZykge1xuXHRcdFx0XHRjaGVja19zcmNfaW5fZGV2X2h5ZHJhdGlvbihlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlID8/ICcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgcmVzZXQgdGhlc2UgYXR0cmlidXRlcywgdGhleSB3b3VsZCByZXN1bHQgaW4gYW5vdGhlciBuZXR3b3JrIHJlcXVlc3QsIHdoaWNoIHdlIHdhbnQgdG8gYXZvaWQuXG5cdFx0XHQvLyBXZSBhc3N1bWUgdGhleSBhcmUgdGhlIHNhbWUgYmV0d2VlbiBjbGllbnQgYW5kIHNlcnZlciBhcyBjaGVja2luZyBpZiB0aGV5IGFyZSBlcXVhbCBpcyBleHBlbnNpdmVcblx0XHRcdC8vICh3ZSBjYW4ndCBqdXN0IGNvbXBhcmUgdGhlIHN0cmluZ3MgYXMgdGhleSBjYW4gYmUgZGlmZmVyZW50IGJldHdlZW4gY2xpZW50IGFuZCBzZXJ2ZXIgYnV0IHJlc3VsdCBpbiB0aGVcblx0XHRcdC8vIHNhbWUgdXJsLCBzbyB3ZSB3b3VsZCBuZWVkIHRvIGNyZWF0ZSBoaWRkZW4gYW5jaG9yIGVsZW1lbnRzIHRvIGNvbXBhcmUgdGhlbSlcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblxuXHRpZiAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID09PSAoYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWUpKSByZXR1cm47XG5cblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ2xvYWRpbmcnKSB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdGVsZW1lbnRbTE9BRElOR19BVFRSX1NZTUJPTF0gPSB2YWx1ZTtcblx0fVxuXG5cdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIGdldF9zZXR0ZXJzKGVsZW1lbnQpLmluY2x1ZGVzKGF0dHJpYnV0ZSkpIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0ZWxlbWVudFthdHRyaWJ1dGVdID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfeGxpbmtfYXR0cmlidXRlKGRvbSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuXHRkb20uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuXHQvLyBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHNldHRpbmcgY3VzdG9tIGVsZW1lbnQgcHJvcHMsIHdoaWNoIGNhblxuXHQvLyBpbnZva2UgbGlmZWN5Y2xlIG1ldGhvZHMgb24gb3RoZXIgY3VzdG9tIGVsZW1lbnRzLCBkb2VzIG5vdCBhbHNvXG5cdC8vIGFzc29jaWF0ZSB0aG9zZSBsaWZlY3ljbGUgbWV0aG9kcyB3aXRoIHRoZSBjdXJyZW50IGFjdGl2ZSByZWFjdGlvblxuXHQvLyBvciBlZmZlY3Rcblx0dmFyIHByZXZpb3VzX3JlYWN0aW9uID0gYWN0aXZlX3JlYWN0aW9uO1xuXHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHQvLyBJZiB3ZSdyZSBoeWRyYXRpbmcgYnV0IHRoZSBjdXN0b20gZWxlbWVudCBpcyBmcm9tIFN2ZWx0ZSwgYW5kIGl0IGFscmVhZHkgc2NhZmZvbGRlZCxcblx0Ly8gdGhlbiBpdCBtaWdodCBydW4gYmxvY2sgbG9naWMgaW4gaHlkcmF0aW9uIG1vZGUsIHdoaWNoIHdlIGhhdmUgdG8gcHJldmVudC5cblx0bGV0IHdhc19oeWRyYXRpbmcgPSBoeWRyYXRpbmc7XG5cdGlmIChoeWRyYXRpbmcpIHtcblx0XHRzZXRfaHlkcmF0aW5nKGZhbHNlKTtcblx0fVxuXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24obnVsbCk7XG5cdHNldF9hY3RpdmVfZWZmZWN0KG51bGwpO1xuXG5cdHRyeSB7XG5cdFx0aWYgKFxuXHRcdFx0Ly8gYHN0eWxlYCBzaG91bGQgdXNlIGBzZXRfYXR0cmlidXRlYCByYXRoZXIgdGhhbiB0aGUgc2V0dGVyXG5cdFx0XHRwcm9wICE9PSAnc3R5bGUnICYmXG5cdFx0XHQvLyBEb24ndCBjb21wdXRlIHNldHRlcnMgZm9yIGN1c3RvbSBlbGVtZW50cyB3aGlsZSB0aGV5IGFyZW4ndCByZWdpc3RlcmVkIHlldCxcblx0XHRcdC8vIGJlY2F1c2UgZHVyaW5nIHRoZWlyIHVwZ3JhZGUvaW5zdGFudGlhdGlvbiB0aGV5IG1pZ2h0IGFkZCBtb3JlIHNldHRlcnMuXG5cdFx0XHQvLyBJbnN0ZWFkLCBmYWxsIGJhY2sgdG8gYSBzaW1wbGUgXCJhbiBvYmplY3QsIHRoZW4gc2V0IGFzIHByb3BlcnR5XCIgaGV1cmlzdGljLlxuXHRcdFx0KHNldHRlcnNfY2FjaGUuaGFzKG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpIHx8IG5vZGUubm9kZU5hbWUpIHx8XG5cdFx0XHQvLyBjdXN0b21FbGVtZW50cyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpbiBicm93c2VyIGV4dGVuc2lvbiBjb250ZXh0c1xuXHRcdFx0IWN1c3RvbUVsZW1lbnRzIHx8XG5cdFx0XHRjdXN0b21FbGVtZW50cy5nZXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2lzJykgfHwgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdD8gZ2V0X3NldHRlcnMobm9kZSkuaW5jbHVkZXMocHJvcClcblx0XHRcdFx0OiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuXHRcdCkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0bm9kZVtwcm9wXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBXZSBkaWQgZ2V0dGVycyBldGMgY2hlY2tzIGFscmVhZHksIHN0cmluZ2lmeSBiZWZvcmUgcGFzc2luZyB0byBzZXRfYXR0cmlidXRlXG5cdFx0XHQvLyB0byBlbnN1cmUgaXQgZG9lc24ndCBpbnZva2UgdGhlIHNhbWUgbG9naWMgYWdhaW4sIGFuZCBwb3RlbnRpYWxseSBwb3B1bGF0aW5nXG5cdFx0XHQvLyB0aGUgc2V0dGVycyBjYWNoZSB0b28gZWFybHkuXG5cdFx0XHRzZXRfYXR0cmlidXRlKG5vZGUsIHByb3AsIHZhbHVlID09IG51bGwgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSkpO1xuXHRcdH1cblx0fSBmaW5hbGx5IHtcblx0XHRzZXRfYWN0aXZlX3JlYWN0aW9uKHByZXZpb3VzX3JlYWN0aW9uKTtcblx0XHRzZXRfYWN0aXZlX2VmZmVjdChwcmV2aW91c19lZmZlY3QpO1xuXHRcdGlmICh3YXNfaHlkcmF0aW5nKSB7XG5cdFx0XHRzZXRfaHlkcmF0aW5nKHRydWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFNwcmVhZHMgYXR0cmlidXRlcyBvbnRvIGEgRE9NIGVsZW1lbnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIGN1cnJlbnRseSBzZXQgYXR0cmlidXRlc1xuICogQHBhcmFtIHtFbGVtZW50ICYgRWxlbWVudENTU0lubGluZVN0eWxlfSBlbGVtZW50XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT4gfCB1bmRlZmluZWR9IHByZXZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55Pn0gbmV4dCBOZXcgYXR0cmlidXRlcyAtIHRoaXMgZnVuY3Rpb24gbXV0YXRlcyB0aGlzIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtjc3NfaGFzaF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBfd2FybmluZ11cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMoZWxlbWVudCwgcHJldiwgbmV4dCwgY3NzX2hhc2gsIHNraXBfd2FybmluZyA9IGZhbHNlKSB7XG5cdHZhciBhdHRyaWJ1dGVzID0gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCk7XG5cblx0dmFyIGlzX2N1c3RvbV9lbGVtZW50ID0gYXR0cmlidXRlc1tJU19DVVNUT01fRUxFTUVOVF07XG5cdHZhciBwcmVzZXJ2ZV9hdHRyaWJ1dGVfY2FzZSA9ICFhdHRyaWJ1dGVzW0lTX0hUTUxdO1xuXG5cdC8vIElmIHdlJ3JlIGh5ZHJhdGluZyBidXQgdGhlIGN1c3RvbSBlbGVtZW50IGlzIGZyb20gU3ZlbHRlLCBhbmQgaXQgYWxyZWFkeSBzY2FmZm9sZGVkLFxuXHQvLyB0aGVuIGl0IG1pZ2h0IHJ1biBibG9jayBsb2dpYyBpbiBoeWRyYXRpb24gbW9kZSwgd2hpY2ggd2UgaGF2ZSB0byBwcmV2ZW50LlxuXHRsZXQgaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50ID0gaHlkcmF0aW5nICYmIGlzX2N1c3RvbV9lbGVtZW50O1xuXHRpZiAoaXNfaHlkcmF0aW5nX2N1c3RvbV9lbGVtZW50KSB7XG5cdFx0c2V0X2h5ZHJhdGluZyhmYWxzZSk7XG5cdH1cblxuXHR2YXIgY3VycmVudCA9IHByZXYgfHwge307XG5cdHZhciBpc19vcHRpb25fZWxlbWVudCA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ09QVElPTic7XG5cblx0Zm9yICh2YXIga2V5IGluIHByZXYpIHtcblx0XHRpZiAoIShrZXkgaW4gbmV4dCkpIHtcblx0XHRcdG5leHRba2V5XSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aWYgKG5leHQuY2xhc3MpIHtcblx0XHRuZXh0LmNsYXNzID0gY2xzeChuZXh0LmNsYXNzKTtcblx0fSBlbHNlIGlmIChjc3NfaGFzaCB8fCBuZXh0W0NMQVNTXSkge1xuXHRcdG5leHQuY2xhc3MgPSBudWxsOyAvKiBmb3JjZSBjYWxsIHRvIHNldF9jbGFzcygpICovXG5cdH1cblxuXHRpZiAobmV4dFtTVFlMRV0pIHtcblx0XHRuZXh0LnN0eWxlID8/PSBudWxsOyAvKiBmb3JjZSBjYWxsIHRvIHNldF9zdHlsZSgpICovXG5cdH1cblxuXHR2YXIgc2V0dGVycyA9IGdldF9zZXR0ZXJzKGVsZW1lbnQpO1xuXG5cdC8vIHNpbmNlIGtleSBpcyBjYXB0dXJlZCB3ZSB1c2UgY29uc3Rcblx0Zm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuXHRcdC8vIGxldCBpbnN0ZWFkIG9mIHZhciBiZWNhdXNlIHJlZmVyZW5jZWQgaW4gYSBjbG9zdXJlXG5cdFx0bGV0IHZhbHVlID0gbmV4dFtrZXldO1xuXG5cdFx0Ly8gVXAgaGVyZSBiZWNhdXNlIHdlIHdhbnQgdG8gZG8gdGhpcyBmb3IgdGhlIGluaXRpYWwgdmFsdWUsIHRvbywgZXZlbiBpZiBpdCdzIHVuZGVmaW5lZCxcblx0XHQvLyBhbmQgdGhpcyB3b3VsZG4ndCBiZSByZWFjaGVkIGluIGNhc2Ugb2YgdW5kZWZpbmVkIGJlY2F1c2Ugb2YgdGhlIGVxdWFsaXR5IGNoZWNrIGJlbG93XG5cdFx0aWYgKGlzX29wdGlvbl9lbGVtZW50ICYmIGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHQvLyBUaGUgPG9wdGlvbj4gZWxlbWVudCBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIHJlbW92aW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgbWVhbnNcblx0XHRcdC8vIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHRleHQgY29udGVudCBvZiB0aGUgb3B0aW9uIGVsZW1lbnQsIGFuZCBzZXR0aW5nIHRoZSB2YWx1ZVxuXHRcdFx0Ly8gdG8gbnVsbCBvciB1bmRlZmluZWQgbWVhbnMgdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgc3RyaW5nIFwibnVsbFwiIG9yIFwidW5kZWZpbmVkXCIuXG5cdFx0XHQvLyBUbyBhbGlnbiB3aXRoIGhvdyB3ZSBoYW5kbGUgdGhpcyBjYXNlIGluIG5vbi1zcHJlYWQtc2NlbmFyaW9zLCB0aGlzIGxvZ2ljIGlzIG5lZWRlZC5cblx0XHRcdC8vIFRoZXJlJ3MgYSBzdXBlci1lZGdlLWNhc2UgYnVnIGhlcmUgdGhhdCBpcyBsZWZ0IGluIGluIGZhdm9yIG9mIHNtYWxsZXIgY29kZSBzaXplOlxuXHRcdFx0Ly8gQmVjYXVzZSBvZiB0aGUgXCJzZXQgbWlzc2luZyBwcm9wcyB0byBudWxsXCIgbG9naWMgYWJvdmUsIHdlIGNhbid0IGRpZmZlcmVudGlhdGVcblx0XHRcdC8vIGJldHdlZW4gYSBtaXNzaW5nIHZhbHVlIGFuZCBhbiBleHBsaWNpdGx5IHNldCB2YWx1ZSBvZiBudWxsIG9yIHVuZGVmaW5lZC4gVGhhdCBtZWFuc1xuXHRcdFx0Ly8gdGhhdCBvbmNlIHNldCwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBvZiBhbiA8b3B0aW9uPiBlbGVtZW50IGNhbid0IGJlIHJlbW92ZWQuIFRoaXMgaXNcblx0XHRcdC8vIGEgdmVyeSByYXJlIGVkZ2UgY2FzZSwgYW5kIHJlbW92aW5nIHRoZSBhdHRyaWJ1dGUgYWx0b2dldGhlciBpc24ndCBwb3NzaWJsZSBlaXRoZXJcblx0XHRcdC8vIGZvciB0aGUgPG9wdGlvbiB2YWx1ZT17dW5kZWZpbmVkfT4gY2FzZSwgc28gd2UncmUgbm90IGxvc2luZyBhbnkgZnVuY3Rpb25hbGl0eSBoZXJlLlxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IGVsZW1lbnQuX192YWx1ZSA9ICcnO1xuXHRcdFx0Y3VycmVudFtrZXldID0gdmFsdWU7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG5cdFx0XHR2YXIgaXNfaHRtbCA9IGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cdFx0XHRzZXRfY2xhc3MoZWxlbWVudCwgaXNfaHRtbCwgdmFsdWUsIGNzc19oYXNoLCBwcmV2Py5bQ0xBU1NdLCBuZXh0W0NMQVNTXSk7XG5cdFx0XHRjdXJyZW50W2tleV0gPSB2YWx1ZTtcblx0XHRcdGN1cnJlbnRbQ0xBU1NdID0gbmV4dFtDTEFTU107XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHRzZXRfc3R5bGUoZWxlbWVudCwgdmFsdWUsIHByZXY/LltTVFlMRV0sIG5leHRbU1RZTEVdKTtcblx0XHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXHRcdFx0Y3VycmVudFtTVFlMRV0gPSBuZXh0W1NUWUxFXTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhciBwcmV2X3ZhbHVlID0gY3VycmVudFtrZXldO1xuXG5cdFx0Ly8gU2tpcCBpZiB2YWx1ZSBpcyB1bmNoYW5nZWQsIHVubGVzcyBpdCdzIGB1bmRlZmluZWRgIGFuZCB0aGUgZWxlbWVudCBzdGlsbCBoYXMgdGhlIGF0dHJpYnV0ZVxuXHRcdGlmICh2YWx1ZSA9PT0gcHJldl92YWx1ZSAmJiAhKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGN1cnJlbnRba2V5XSA9IHZhbHVlO1xuXG5cdFx0dmFyIHByZWZpeCA9IGtleVswXSArIGtleVsxXTsgLy8gdGhpcyBpcyBmYXN0ZXIgdGhhbiBrZXkuc2xpY2UoMCwgMilcblx0XHRpZiAocHJlZml4ID09PSAnJCQnKSBjb250aW51ZTtcblxuXHRcdGlmIChwcmVmaXggPT09ICdvbicpIHtcblx0XHRcdC8qKiBAdHlwZSB7eyBjYXB0dXJlPzogdHJ1ZSB9fSAqL1xuXHRcdFx0Y29uc3Qgb3B0cyA9IHt9O1xuXHRcdFx0Y29uc3QgZXZlbnRfaGFuZGxlX2tleSA9ICckJCcgKyBrZXk7XG5cdFx0XHRsZXQgZXZlbnRfbmFtZSA9IGtleS5zbGljZSgyKTtcblx0XHRcdHZhciBkZWxlZ2F0ZWQgPSBpc19kZWxlZ2F0ZWQoZXZlbnRfbmFtZSk7XG5cblx0XHRcdGlmIChpc19jYXB0dXJlX2V2ZW50KGV2ZW50X25hbWUpKSB7XG5cdFx0XHRcdGV2ZW50X25hbWUgPSBldmVudF9uYW1lLnNsaWNlKDAsIC03KTtcblx0XHRcdFx0b3B0cy5jYXB0dXJlID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZWxlZ2F0ZWQgJiYgcHJldl92YWx1ZSkge1xuXHRcdFx0XHQvLyBMaXN0ZW5pbmcgdG8gc2FtZSBldmVudCBidXQgZGlmZmVyZW50IGhhbmRsZXIgLT4gb3VyIGhhbmRsZSBmdW5jdGlvbiBiZWxvdyB0YWtlcyBjYXJlIG9mIHRoaXNcblx0XHRcdFx0Ly8gSWYgd2Ugd2VyZSB0byByZW1vdmUgYW5kIGFkZCBsaXN0ZW5lcnMgaW4gdGhpcyBjYXNlLCBpdCBjb3VsZCBoYXBwZW4gdGhhdCB0aGUgZXZlbnQgaXMgXCJzd2FsbG93ZWRcIlxuXHRcdFx0XHQvLyAodGhlIGJyb3dzZXIgc2VlbXMgdG8gbm90IGtub3cgeWV0IHRoYXQgYSBuZXcgb25lIGV4aXN0cyBub3cpIGFuZCBkb2Vzbid0IHJlYWNoIHRoZSBoYW5kbGVyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzExOTAzXG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSBjb250aW51ZTtcblxuXHRcdFx0XHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgY3VycmVudFtldmVudF9oYW5kbGVfa2V5XSwgb3B0cyk7XG5cdFx0XHRcdGN1cnJlbnRbZXZlbnRfaGFuZGxlX2tleV0gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoIWRlbGVnYXRlZCkge1xuXHRcdFx0XHRcdC8qKlxuXHRcdFx0XHRcdCAqIEB0aGlzIHthbnl9XG5cdFx0XHRcdFx0ICogQHBhcmFtIHtFdmVudH0gZXZ0XG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKGV2dCkge1xuXHRcdFx0XHRcdFx0Y3VycmVudFtrZXldLmNhbGwodGhpcywgZXZ0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdXJyZW50W2V2ZW50X2hhbmRsZV9rZXldID0gY3JlYXRlX2V2ZW50KGV2ZW50X25hbWUsIGVsZW1lbnQsIGhhbmRsZSwgb3B0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdGVsZW1lbnRbYF9fJHtldmVudF9uYW1lfWBdID0gdmFsdWU7XG5cdFx0XHRcdFx0ZGVsZWdhdGUoW2V2ZW50X25hbWVdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W2BfXyR7ZXZlbnRfbmFtZX1gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0Ly8gYXZvaWQgdXNpbmcgdGhlIHNldHRlclxuXHRcdFx0c2V0X2F0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ2F1dG9mb2N1cycpIHtcblx0XHRcdGF1dG9mb2N1cygvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZWxlbWVudCksIEJvb2xlYW4odmFsdWUpKTtcblx0XHR9IGVsc2UgaWYgKCFpc19jdXN0b21fZWxlbWVudCAmJiAoa2V5ID09PSAnX192YWx1ZScgfHwgKGtleSA9PT0gJ3ZhbHVlJyAmJiB2YWx1ZSAhPSBudWxsKSkpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgV2UncmUgbm90IHJ1bm5pbmcgdGhpcyBmb3IgY3VzdG9tIGVsZW1lbnRzIGJlY2F1c2UgX192YWx1ZSBpcyBhY3R1YWxseVxuXHRcdFx0Ly8gaG93IExpdCBzdG9yZXMgdGhlIGN1cnJlbnQgdmFsdWUgb24gdGhlIGVsZW1lbnQsIGFuZCBtZXNzaW5nIHdpdGggdGhhdCB3b3VsZCBicmVhayB0aGluZ3MuXG5cdFx0XHRlbGVtZW50LnZhbHVlID0gZWxlbWVudC5fX3ZhbHVlID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChrZXkgPT09ICdzZWxlY3RlZCcgJiYgaXNfb3B0aW9uX2VsZW1lbnQpIHtcblx0XHRcdHNldF9zZWxlY3RlZCgvKiogQHR5cGUge0hUTUxPcHRpb25FbGVtZW50fSAqLyAoZWxlbWVudCksIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5hbWUgPSBrZXk7XG5cdFx0XHRpZiAoIXByZXNlcnZlX2F0dHJpYnV0ZV9jYXNlKSB7XG5cdFx0XHRcdG5hbWUgPSBub3JtYWxpemVfYXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgaXNfZGVmYXVsdCA9IG5hbWUgPT09ICdkZWZhdWx0VmFsdWUnIHx8IG5hbWUgPT09ICdkZWZhdWx0Q2hlY2tlZCc7XG5cblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmICFpc19jdXN0b21fZWxlbWVudCAmJiAhaXNfZGVmYXVsdCkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzW2tleV0gPSBudWxsO1xuXG5cdFx0XHRcdGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdjaGVja2VkJykge1xuXHRcdFx0XHRcdC8vIHJlbW92aW5nIHZhbHVlL2NoZWNrZWQgYWxzbyByZW1vdmVzIGRlZmF1bHRWYWx1ZS9kZWZhdWx0Q2hlY2tlZCBcdTIwMTQgcHJlc2VydmVcblx0XHRcdFx0XHRsZXQgaW5wdXQgPSAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovIChlbGVtZW50KTtcblx0XHRcdFx0XHRjb25zdCB1c2VfZGVmYXVsdCA9IHByZXYgPT09IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ3ZhbHVlJykge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdFZhbHVlO1xuXHRcdFx0XHRcdFx0aW5wdXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdFx0XHRcdFx0aW5wdXQuZGVmYXVsdFZhbHVlID0gcHJldmlvdXM7XG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0XHRpbnB1dC52YWx1ZSA9IGlucHV0Ll9fdmFsdWUgPSB1c2VfZGVmYXVsdCA/IHByZXZpb3VzIDogbnVsbDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IHByZXZpb3VzID0gaW5wdXQuZGVmYXVsdENoZWNrZWQ7XG5cdFx0XHRcdFx0XHRpbnB1dC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0XHRcdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IHByZXZpb3VzO1xuXHRcdFx0XHRcdFx0aW5wdXQuY2hlY2tlZCA9IHVzZV9kZWZhdWx0ID8gcHJldmlvdXMgOiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aXNfZGVmYXVsdCB8fFxuXHRcdFx0XHQoc2V0dGVycy5pbmNsdWRlcyhuYW1lKSAmJiAoaXNfY3VzdG9tX2VsZW1lbnQgfHwgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRlbGVtZW50W25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdC8vIHJlbW92ZSBpdCBmcm9tIGF0dHJpYnV0ZXMncyBjYWNoZVxuXHRcdFx0XHRpZiAobmFtZSBpbiBhdHRyaWJ1dGVzKSBhdHRyaWJ1dGVzW25hbWVdID0gVU5JTklUSUFMSVpFRDtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHNldF9hdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUsIHNraXBfd2FybmluZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGlzX2h5ZHJhdGluZ19jdXN0b21fZWxlbWVudCkge1xuXHRcdHNldF9oeWRyYXRpbmcodHJ1ZSk7XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgJiBFbGVtZW50Q1NTSW5saW5lU3R5bGV9IGVsZW1lbnRcbiAqIEBwYXJhbSB7KC4uLmV4cHJlc3Npb25zOiBhbnkpID0+IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT59IGZuXG4gKiBAcGFyYW0ge0FycmF5PCgpID0+IGFueT59IHN5bmNcbiAqIEBwYXJhbSB7QXJyYXk8KCkgPT4gUHJvbWlzZTxhbnk+Pn0gYXN5bmNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3NzX2hhc2hdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwX3dhcm5pbmddXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRyaWJ1dGVfZWZmZWN0KFxuXHRlbGVtZW50LFxuXHRmbixcblx0c3luYyA9IFtdLFxuXHRhc3luYyA9IFtdLFxuXHRjc3NfaGFzaCxcblx0c2tpcF93YXJuaW5nID0gZmFsc2Vcbikge1xuXHRmbGF0dGVuKHN5bmMsIGFzeW5jLCAodmFsdWVzKSA9PiB7XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCBhbnk+IHwgdW5kZWZpbmVkfSAqL1xuXHRcdHZhciBwcmV2ID0gdW5kZWZpbmVkO1xuXG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3ltYm9sLCBFZmZlY3Q+fSAqL1xuXHRcdHZhciBlZmZlY3RzID0ge307XG5cblx0XHR2YXIgaXNfc2VsZWN0ID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCc7XG5cdFx0dmFyIGluaXRlZCA9IGZhbHNlO1xuXG5cdFx0YmxvY2soKCkgPT4ge1xuXHRcdFx0dmFyIG5leHQgPSBmbiguLi52YWx1ZXMubWFwKGdldCkpO1xuXHRcdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCBhbnk+fSAqL1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBzZXRfYXR0cmlidXRlcyhlbGVtZW50LCBwcmV2LCBuZXh0LCBjc3NfaGFzaCwgc2tpcF93YXJuaW5nKTtcblxuXHRcdFx0aWYgKGluaXRlZCAmJiBpc19zZWxlY3QgJiYgJ3ZhbHVlJyBpbiBuZXh0KSB7XG5cdFx0XHRcdHNlbGVjdF9vcHRpb24oLyoqIEB0eXBlIHtIVE1MU2VsZWN0RWxlbWVudH0gKi8gKGVsZW1lbnQpLCBuZXh0LnZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChsZXQgc3ltYm9sIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZWZmZWN0cykpIHtcblx0XHRcdFx0aWYgKCFuZXh0W3N5bWJvbF0pIGRlc3Ryb3lfZWZmZWN0KGVmZmVjdHNbc3ltYm9sXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAobGV0IHN5bWJvbCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG5leHQpKSB7XG5cdFx0XHRcdHZhciBuID0gbmV4dFtzeW1ib2xdO1xuXG5cdFx0XHRcdGlmIChzeW1ib2wuZGVzY3JpcHRpb24gPT09IEFUVEFDSE1FTlRfS0VZICYmICghcHJldiB8fCBuICE9PSBwcmV2W3N5bWJvbF0pKSB7XG5cdFx0XHRcdFx0aWYgKGVmZmVjdHNbc3ltYm9sXSkgZGVzdHJveV9lZmZlY3QoZWZmZWN0c1tzeW1ib2xdKTtcblx0XHRcdFx0XHRlZmZlY3RzW3N5bWJvbF0gPSBicmFuY2goKCkgPT4gYXR0YWNoKGVsZW1lbnQsICgpID0+IG4pKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGN1cnJlbnRbc3ltYm9sXSA9IG47XG5cdFx0XHR9XG5cblx0XHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdH0pO1xuXG5cdFx0aWYgKGlzX3NlbGVjdCkge1xuXHRcdFx0dmFyIHNlbGVjdCA9IC8qKiBAdHlwZSB7SFRNTFNlbGVjdEVsZW1lbnR9ICovIChlbGVtZW50KTtcblxuXHRcdFx0ZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0c2VsZWN0X29wdGlvbihzZWxlY3QsIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgYW55Pn0gKi8gKHByZXYpLnZhbHVlLCB0cnVlKTtcblx0XHRcdFx0aW5pdF9zZWxlY3Qoc2VsZWN0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGluaXRlZCA9IHRydWU7XG5cdH0pO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0X2F0dHJpYnV0ZXMoZWxlbWVudCkge1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPn0gKiovIChcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0ZWxlbWVudC5fX2F0dHJpYnV0ZXMgPz89IHtcblx0XHRcdFtJU19DVVNUT01fRUxFTUVOVF06IGVsZW1lbnQubm9kZU5hbWUuaW5jbHVkZXMoJy0nKSxcblx0XHRcdFtJU19IVE1MXTogZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE5BTUVTUEFDRV9IVE1MXG5cdFx0fVxuXHQpO1xufVxuXG4vKiogQHR5cGUge01hcDxzdHJpbmcsIHN0cmluZ1tdPn0gKi9cbnZhciBzZXR0ZXJzX2NhY2hlID0gbmV3IE1hcCgpO1xuXG4vKiogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50ICovXG5mdW5jdGlvbiBnZXRfc2V0dGVycyhlbGVtZW50KSB7XG5cdHZhciBjYWNoZV9rZXkgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaXMnKSB8fCBlbGVtZW50Lm5vZGVOYW1lO1xuXHR2YXIgc2V0dGVycyA9IHNldHRlcnNfY2FjaGUuZ2V0KGNhY2hlX2tleSk7XG5cdGlmIChzZXR0ZXJzKSByZXR1cm4gc2V0dGVycztcblx0c2V0dGVyc19jYWNoZS5zZXQoY2FjaGVfa2V5LCAoc2V0dGVycyA9IFtdKSk7XG5cblx0dmFyIGRlc2NyaXB0b3JzO1xuXHR2YXIgcHJvdG8gPSBlbGVtZW50OyAvLyBJbiB0aGUgY2FzZSBvZiBjdXN0b20gZWxlbWVudHMgdGhlcmUgbWlnaHQgYmUgc2V0dGVycyBvbiB0aGUgaW5zdGFuY2Vcblx0dmFyIGVsZW1lbnRfcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcblxuXHQvLyBTdG9wIGF0IEVsZW1lbnQsIGZyb20gdGhlcmUgb24gdGhlcmUncyBvbmx5IHVubmVjZXNzYXJ5IHNldHRlcnMgd2UncmUgbm90IGludGVyZXN0ZWQgaW5cblx0Ly8gRG8gbm90IHVzZSBjb250cnVjdG9yLm5hbWUgaGVyZSBhcyB0aGF0J3MgdW5yZWxpYWJsZSBpbiBzb21lIGJyb3dzZXIgZW52aXJvbm1lbnRzXG5cdHdoaWxlIChlbGVtZW50X3Byb3RvICE9PSBwcm90bykge1xuXHRcdGRlc2NyaXB0b3JzID0gZ2V0X2Rlc2NyaXB0b3JzKHByb3RvKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBkZXNjcmlwdG9ycykge1xuXHRcdFx0aWYgKGRlc2NyaXB0b3JzW2tleV0uc2V0KSB7XG5cdFx0XHRcdHNldHRlcnMucHVzaChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0X3Byb3RvdHlwZV9vZihwcm90byk7XG5cdH1cblxuXHRyZXR1cm4gc2V0dGVycztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrX3NyY19pbl9kZXZfaHlkcmF0aW9uKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcblx0aWYgKCFERVYpIHJldHVybjtcblx0aWYgKGF0dHJpYnV0ZSA9PT0gJ3NyY3NldCcgJiYgc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50LCB2YWx1ZSkpIHJldHVybjtcblx0aWYgKHNyY191cmxfZXF1YWwoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSA/PyAnJywgdmFsdWUpKSByZXR1cm47XG5cblx0dy5oeWRyYXRpb25fYXR0cmlidXRlX2NoYW5nZWQoXG5cdFx0YXR0cmlidXRlLFxuXHRcdGVsZW1lbnQub3V0ZXJIVE1MLnJlcGxhY2UoZWxlbWVudC5pbm5lckhUTUwsIGVsZW1lbnQuaW5uZXJIVE1MICYmICcuLi4nKSxcblx0XHRTdHJpbmcodmFsdWUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRfc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3JjX3VybF9lcXVhbChlbGVtZW50X3NyYywgdXJsKSB7XG5cdGlmIChlbGVtZW50X3NyYyA9PT0gdXJsKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIG5ldyBVUkwoZWxlbWVudF9zcmMsIGRvY3VtZW50LmJhc2VVUkkpLmhyZWYgPT09IG5ldyBVUkwodXJsLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmO1xufVxuXG4vKiogQHBhcmFtIHtzdHJpbmd9IHNyY3NldCAqL1xuZnVuY3Rpb24gc3BsaXRfc3Jjc2V0KHNyY3NldCkge1xuXHRyZXR1cm4gc3Jjc2V0LnNwbGl0KCcsJykubWFwKChzcmMpID0+IHNyYy50cmltKCkuc3BsaXQoJyAnKS5maWx0ZXIoQm9vbGVhbikpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNvdXJjZUVsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gc3Jjc2V0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3Jjc2V0X3VybF9lcXVhbChlbGVtZW50LCBzcmNzZXQpIHtcblx0dmFyIGVsZW1lbnRfdXJscyA9IHNwbGl0X3NyY3NldChlbGVtZW50LnNyY3NldCk7XG5cdHZhciB1cmxzID0gc3BsaXRfc3Jjc2V0KHNyY3NldCk7XG5cblx0cmV0dXJuIChcblx0XHR1cmxzLmxlbmd0aCA9PT0gZWxlbWVudF91cmxzLmxlbmd0aCAmJlxuXHRcdHVybHMuZXZlcnkoXG5cdFx0XHQoW3VybCwgd2lkdGhdLCBpKSA9PlxuXHRcdFx0XHR3aWR0aCA9PT0gZWxlbWVudF91cmxzW2ldWzFdICYmXG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBib3RoIHdheXMgYmVjYXVzZSBWaXRlIHdpbGwgY3JlYXRlIGFuIGEgZnVsbCBVUkwgd2l0aFxuXHRcdFx0XHQvLyBgbmV3IFVSTChhc3NldCwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmYCBmb3IgdGhlIGNsaWVudCB3aGVuIGBiYXNlOiAnLi8nYCwgYW5kIHRoZVxuXHRcdFx0XHQvLyByZWxhdGl2ZSBVUkxzIGluc2lkZSBzcmNzZXQgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IHJlc29sdmVkIHRvIGFic29sdXRlIFVSTHMgYnlcblx0XHRcdFx0Ly8gYnJvd3NlcnMgKGluIGNvbnRyYXN0IHRvIGltZy5zcmMpLiBUaGlzIG1lYW5zIGJvdGggU1NSIGFuZCBET00gY29kZSBjb3VsZFxuXHRcdFx0XHQvLyBjb250YWluIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTHMuXG5cdFx0XHRcdChzcmNfdXJsX2VxdWFsKGVsZW1lbnRfdXJsc1tpXVswXSwgdXJsKSB8fCBzcmNfdXJsX2VxdWFsKHVybCwgZWxlbWVudF91cmxzW2ldWzBdKSlcblx0XHQpXG5cdCk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBSYWYgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5cbmltcG9ydCB7IEJST1dTRVIgfSBmcm9tICdlc20tZW52JztcblxuY29uc3Qgbm93ID0gQlJPV1NFUiA/ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpIDogKCkgPT4gRGF0ZS5ub3coKTtcblxuLyoqIEB0eXBlIHtSYWZ9ICovXG5leHBvcnQgY29uc3QgcmFmID0ge1xuXHQvLyBkb24ndCBhY2Nlc3MgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGVhZ2VybHkgb3V0c2lkZSBtZXRob2Rcblx0Ly8gdGhpcyBhbGxvd3MgYmFzaWMgdGVzdGluZyBvZiB1c2VyIGNvZGUgd2l0aG91dCBKU0RPTVxuXHQvLyBidW5kZXIgd2lsbCBldmFsIGFuZCByZW1vdmUgdGVybmFyeSB3aGVuIHRoZSB1c2VyJ3MgYXBwIGlzIGJ1aWx0XG5cdHRpY2s6IC8qKiBAcGFyYW0ge2FueX0gXyAqLyAoXykgPT4gKEJST1dTRVIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBub29wKShfKSxcblx0bm93OiAoKSA9PiBub3coKSxcblx0dGFza3M6IG5ldyBTZXQoKVxufTtcbiIsICIvKiogQGltcG9ydCB7IFRhc2tDYWxsYmFjaywgVGFzaywgVGFza0VudHJ5IH0gZnJvbSAnI2NsaWVudCcgKi9cbmltcG9ydCB7IHJhZiB9IGZyb20gJy4vdGltaW5nLmpzJztcblxuLy8gVE9ETyBtb3ZlIHRoaXMgaW50byB0aW1pbmcuanMgd2hlcmUgaXQgcHJvYmFibHkgYmVsb25nc1xuXG4vKipcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBydW5fdGFza3MoKSB7XG5cdC8vIHVzZSBgcmFmLm5vdygpYCBpbnN0ZWFkIG9mIHRoZSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjayBhcmd1bWVudCwgYmVjYXVzZVxuXHQvLyBvdGhlcndpc2UgdGhpbmdzIGNhbiBnZXQgd29ua3kgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9wdWxsLzE0NTQxXG5cdGNvbnN0IG5vdyA9IHJhZi5ub3coKTtcblxuXHRyYWYudGFza3MuZm9yRWFjaCgodGFzaykgPT4ge1xuXHRcdGlmICghdGFzay5jKG5vdykpIHtcblx0XHRcdHJhZi50YXNrcy5kZWxldGUodGFzayk7XG5cdFx0XHR0YXNrLmYoKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSAhPT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICogQHBhcmFtIHtUYXNrQ2FsbGJhY2t9IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7VGFza31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcblx0LyoqIEB0eXBlIHtUYXNrRW50cnl9ICovXG5cdGxldCB0YXNrO1xuXG5cdGlmIChyYWYudGFza3Muc2l6ZSA9PT0gMCkge1xuXHRcdHJhZi50aWNrKHJ1bl90YXNrcyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHByb21pc2U6IG5ldyBQcm9taXNlKChmdWxmaWxsKSA9PiB7XG5cdFx0XHRyYWYudGFza3MuYWRkKCh0YXNrID0geyBjOiBjYWxsYmFjaywgZjogZnVsZmlsbCB9KSk7XG5cdFx0fSksXG5cdFx0YWJvcnQoKSB7XG5cdFx0XHRyYWYudGFza3MuZGVsZXRlKHRhc2spO1xuXHRcdH1cblx0fTtcbn1cbiIsICIvKiogQGltcG9ydCB7IEFuaW1hdGVGbiwgQW5pbWF0aW9uLCBBbmltYXRpb25Db25maWcsIEVhY2hJdGVtLCBFZmZlY3QsIFRyYW5zaXRpb25GbiwgVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcjY2xpZW50JyAqL1xuaW1wb3J0IHsgbm9vcCwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGFjdGl2ZV9yZWFjdGlvbixcblx0c2V0X2FjdGl2ZV9lZmZlY3QsXG5cdHNldF9hY3RpdmVfcmVhY3Rpb24sXG5cdHVudHJhY2tcbn0gZnJvbSAnLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBsb29wIH0gZnJvbSAnLi4vLi4vbG9vcC5qcyc7XG5pbXBvcnQgeyBzaG91bGRfaW50cm8gfSBmcm9tICcuLi8uLi9yZW5kZXIuanMnO1xuaW1wb3J0IHsgY3VycmVudF9lYWNoX2l0ZW0gfSBmcm9tICcuLi9ibG9ja3MvZWFjaC5qcyc7XG5pbXBvcnQgeyBUUkFOU0lUSU9OX0dMT0JBTCwgVFJBTlNJVElPTl9JTiwgVFJBTlNJVElPTl9PVVQgfSBmcm9tICcuLi8uLi8uLi8uLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgQkxPQ0tfRUZGRUNULCBFRkZFQ1RfUkFOLCBFRkZFQ1RfVFJBTlNQQVJFTlQgfSBmcm9tICcjY2xpZW50L2NvbnN0YW50cyc7XG5pbXBvcnQgeyBxdWV1ZV9taWNyb190YXNrIH0gZnJvbSAnLi4vdGFzay5qcyc7XG5pbXBvcnQgeyB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQgfSBmcm9tICcuL2JpbmRpbmdzL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geydpbnRyb3N0YXJ0JyB8ICdpbnRyb2VuZCcgfCAnb3V0cm9zdGFydCcgfCAnb3V0cm9lbmQnfSB0eXBlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgdHlwZSkge1xuXHR3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQoKCkgPT4ge1xuXHRcdGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQodHlwZSkpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByb3BlcnR5IHRvIHRoZSBjYW1lbC1jYXNlIGZvcm1hdCBleHBlY3RlZCBieSBFbGVtZW50LmFuaW1hdGUoKSwgS2V5ZnJhbWVFZmZlY3QoKSwgYW5kIEtleWZyYW1lRWZmZWN0LnNldEtleWZyYW1lcygpLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjc3NfcHJvcGVydHlfdG9fY2FtZWxjYXNlKHN0eWxlKSB7XG5cdC8vIGluIGNvbXBsaWFuY2Ugd2l0aCBzcGVjXG5cdGlmIChzdHlsZSA9PT0gJ2Zsb2F0JykgcmV0dXJuICdjc3NGbG9hdCc7XG5cdGlmIChzdHlsZSA9PT0gJ29mZnNldCcpIHJldHVybiAnY3NzT2Zmc2V0JztcblxuXHQvLyBkbyBub3QgcmVuYW1lIGN1c3RvbSBAcHJvcGVydGllc1xuXHRpZiAoc3R5bGUuc3RhcnRzV2l0aCgnLS0nKSkgcmV0dXJuIHN0eWxlO1xuXG5cdGNvbnN0IHBhcnRzID0gc3R5bGUuc3BsaXQoJy0nKTtcblx0aWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRzWzBdO1xuXHRyZXR1cm4gKFxuXHRcdHBhcnRzWzBdICtcblx0XHRwYXJ0c1xuXHRcdFx0LnNsaWNlKDEpXG5cdFx0XHQubWFwKC8qKiBAcGFyYW0ge2FueX0gd29yZCAqLyAod29yZCkgPT4gd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSlcblx0XHRcdC5qb2luKCcnKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NcbiAqIEByZXR1cm5zIHtLZXlmcmFtZX1cbiAqL1xuZnVuY3Rpb24gY3NzX3RvX2tleWZyYW1lKGNzcykge1xuXHQvKiogQHR5cGUge0tleWZyYW1lfSAqL1xuXHRjb25zdCBrZXlmcmFtZSA9IHt9O1xuXHRjb25zdCBwYXJ0cyA9IGNzcy5zcGxpdCgnOycpO1xuXHRmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcblx0XHRjb25zdCBbcHJvcGVydHksIHZhbHVlXSA9IHBhcnQuc3BsaXQoJzonKTtcblx0XHRpZiAoIXByb3BlcnR5IHx8IHZhbHVlID09PSB1bmRlZmluZWQpIGJyZWFrO1xuXG5cdFx0Y29uc3QgZm9ybWF0dGVkX3Byb3BlcnR5ID0gY3NzX3Byb3BlcnR5X3RvX2NhbWVsY2FzZShwcm9wZXJ0eS50cmltKCkpO1xuXHRcdGtleWZyYW1lW2Zvcm1hdHRlZF9wcm9wZXJ0eV0gPSB2YWx1ZS50cmltKCk7XG5cdH1cblx0cmV0dXJuIGtleWZyYW1lO1xufVxuXG4vKiogQHBhcmFtIHtudW1iZXJ9IHQgKi9cbmNvbnN0IGxpbmVhciA9ICh0KSA9PiB0O1xuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUga2V5ZWQgYHsjZWFjaCAuLi59YCBibG9ja3MgKGFzIGAkLmFuaW1hdGlvbiguLi4pYCkuIFRoaXMgY3JlYXRlcyBhbiBhbmltYXRpb24gbWFuYWdlclxuICogYW5kIGF0dGFjaGVzIGl0IHRvIHRoZSBibG9jaywgc28gdGhhdCBtb3ZlcyBjYW4gYmUgYW5pbWF0ZWQgZm9sbG93aW5nIHJlY29uY2lsaWF0aW9uLlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiBBbmltYXRlRm48UCB8IHVuZGVmaW5lZD59IGdldF9mblxuICogQHBhcmFtIHsoKCkgPT4gUCkgfCBudWxsfSBnZXRfcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmltYXRpb24oZWxlbWVudCwgZ2V0X2ZuLCBnZXRfcGFyYW1zKSB7XG5cdHZhciBpdGVtID0gLyoqIEB0eXBlIHtFYWNoSXRlbX0gKi8gKGN1cnJlbnRfZWFjaF9pdGVtKTtcblxuXHQvKiogQHR5cGUge0RPTVJlY3R9ICovXG5cdHZhciBmcm9tO1xuXG5cdC8qKiBAdHlwZSB7RE9NUmVjdH0gKi9cblx0dmFyIHRvO1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgYW5pbWF0aW9uO1xuXG5cdC8qKiBAdHlwZSB7bnVsbCB8IHsgcG9zaXRpb246IHN0cmluZywgd2lkdGg6IHN0cmluZywgaGVpZ2h0OiBzdHJpbmcsIHRyYW5zZm9ybTogc3RyaW5nIH19ICovXG5cdHZhciBvcmlnaW5hbF9zdHlsZXMgPSBudWxsO1xuXG5cdGl0ZW0uYSA/Pz0ge1xuXHRcdGVsZW1lbnQsXG5cdFx0bWVhc3VyZSgpIHtcblx0XHRcdGZyb20gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0fSxcblx0XHRhcHBseSgpIHtcblx0XHRcdGFuaW1hdGlvbj8uYWJvcnQoKTtcblxuXHRcdFx0dG8gPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZnJvbS5sZWZ0ICE9PSB0by5sZWZ0IHx8XG5cdFx0XHRcdGZyb20ucmlnaHQgIT09IHRvLnJpZ2h0IHx8XG5cdFx0XHRcdGZyb20udG9wICE9PSB0by50b3AgfHxcblx0XHRcdFx0ZnJvbS5ib3R0b20gIT09IHRvLmJvdHRvbVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IG9wdGlvbnMgPSBnZXRfZm4oKSh0aGlzLmVsZW1lbnQsIHsgZnJvbSwgdG8gfSwgZ2V0X3BhcmFtcz8uKCkpO1xuXG5cdFx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGUodGhpcy5lbGVtZW50LCBvcHRpb25zLCB1bmRlZmluZWQsIDEsICgpID0+IHtcblx0XHRcdFx0XHRhbmltYXRpb24/LmFib3J0KCk7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGZpeCgpIHtcblx0XHRcdC8vIElmIGFuIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHJ1bm5pbmcsIHRyYW5zZm9ybWluZyB0aGUgZWxlbWVudCBpcyBsaWtlbHkgdG8gZmFpbCxcblx0XHRcdC8vIGJlY2F1c2UgdGhlIHN0eWxlcyBhcHBsaWVkIGJ5IHRoZSBhbmltYXRpb24gdGFrZSBwcmVjZWRlbmNlLiBJbiB0aGUgY2FzZSBvZiBjcm9zc2ZhZGUsXG5cdFx0XHQvLyB0aGF0IG1lYW5zIHRoZSBgdHJhbnNsYXRlKC4uLilgIG9mIHRoZSBjcm9zc2ZhZGUgdHJhbnNpdGlvbiBvdmVycnVsZXMgdGhlIGB0cmFuc2xhdGUoLi4uKWBcblx0XHRcdC8vIHdlIHdvdWxkIGFwcGx5IGJlbG93LCBsZWFkaW5nIHRvIHRoZSBlbGVtZW50IGp1bXBpbmcgc29tZXdoZXJlIHRvIHRoZSB0b3AgbGVmdC5cblx0XHRcdGlmIChlbGVtZW50LmdldEFuaW1hdGlvbnMoKS5sZW5ndGgpIHJldHVybjtcblxuXHRcdFx0Ly8gSXQncyBpbXBvcnRhbnQgdG8gZGVzdHJ1Y3R1cmUgdGhlc2UgdG8gZ2V0IGZpeGVkIHZhbHVlcyAtIHRoZSBvYmplY3QgaXRzZWxmIGhhcyBnZXR0ZXJzLFxuXHRcdFx0Ly8gYW5kIGNoYW5naW5nIHRoZSBzdHlsZSB0byAnYWJzb2x1dGUnIGNhbiBmb3IgZXhhbXBsZSBpbmZsdWVuY2UgdGhlIHdpZHRoLlxuXHRcdFx0dmFyIHsgcG9zaXRpb24sIHdpZHRoLCBoZWlnaHQgfSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cblx0XHRcdGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyAmJiBwb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuXHRcdFx0XHR2YXIgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgU1ZHRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlO1xuXG5cdFx0XHRcdG9yaWdpbmFsX3N0eWxlcyA9IHtcblx0XHRcdFx0XHRwb3NpdGlvbjogc3R5bGUucG9zaXRpb24sXG5cdFx0XHRcdFx0d2lkdGg6IHN0eWxlLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuXHRcdFx0XHRcdHRyYW5zZm9ybTogc3R5bGUudHJhbnNmb3JtXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRcdHZhciB0byA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0aWYgKGZyb20ubGVmdCAhPT0gdG8ubGVmdCB8fCBmcm9tLnRvcCAhPT0gdG8udG9wKSB7XG5cdFx0XHRcdFx0dmFyIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtmcm9tLmxlZnQgLSB0by5sZWZ0fXB4LCAke2Zyb20udG9wIC0gdG8udG9wfXB4KWA7XG5cdFx0XHRcdFx0c3R5bGUudHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID8gYCR7c3R5bGUudHJhbnNmb3JtfSAke3RyYW5zZm9ybX1gIDogdHJhbnNmb3JtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHR1bmZpeCgpIHtcblx0XHRcdGlmIChvcmlnaW5hbF9zdHlsZXMpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9ICovIChlbGVtZW50KS5zdHlsZTtcblxuXHRcdFx0XHRzdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsX3N0eWxlcy5wb3NpdGlvbjtcblx0XHRcdFx0c3R5bGUud2lkdGggPSBvcmlnaW5hbF9zdHlsZXMud2lkdGg7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IG9yaWdpbmFsX3N0eWxlcy5oZWlnaHQ7XG5cdFx0XHRcdHN0eWxlLnRyYW5zZm9ybSA9IG9yaWdpbmFsX3N0eWxlcy50cmFuc2Zvcm07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIGluIHRoZSBjYXNlIG9mIGEgYDxzdmVsdGU6ZWxlbWVudD5gLCBpdCdzIHBvc3NpYmxlIGZvciBgJC5hbmltYXRpb24oLi4uKWAgdG8gYmUgY2FsbGVkXG5cdC8vIHdoZW4gYW4gYW5pbWF0aW9uIG1hbmFnZXIgYWxyZWFkeSBleGlzdHMsIGlmIHRoZSB0YWcgY2hhbmdlcy4gaW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvXG5cdC8vIHN3YXAgb3V0IHRoZSBlbGVtZW50IHJhdGhlciB0aGFuIGNyZWF0aW5nIGEgbmV3IG1hbmFnZXIsIGluIGNhc2UgaXQgaGFwcGVuZWQgYXQgdGhlIHNhbWVcblx0Ly8gbW9tZW50IGFzIGEgcmVjb25jaWxpYXRpb25cblx0aXRlbS5hLmVsZW1lbnQgPSBlbGVtZW50O1xufVxuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUgYmxvY2sgZWZmZWN0cyBhcyBgJC50cmFuc2l0aW9uKC4uLilgLiBUaGlzIGNyZWF0ZXMgYSB0cmFuc2l0aW9uIG1hbmFnZXIgYW5kXG4gKiBhdHRhY2hlcyBpdCB0byB0aGUgY3VycmVudCBlZmZlY3QgXHUyMDE0IGxhdGVyLCBpbnNpZGUgYHBhdXNlX2VmZmVjdGAgYW5kIGByZXN1bWVfZWZmZWN0YCwgd2VcbiAqIHVzZSB0aGlzIHRvIGNyZWF0ZSBgaW50cm9gIGFuZCBgb3V0cm9gIHRyYW5zaXRpb25zLlxuICogQHRlbXBsYXRlIFBcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiBUcmFuc2l0aW9uRm48UCB8IHVuZGVmaW5lZD59IGdldF9mblxuICogQHBhcmFtIHsoKCkgPT4gUCkgfCBudWxsfSBnZXRfcGFyYW1zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zaXRpb24oZmxhZ3MsIGVsZW1lbnQsIGdldF9mbiwgZ2V0X3BhcmFtcykge1xuXHR2YXIgaXNfaW50cm8gPSAoZmxhZ3MgJiBUUkFOU0lUSU9OX0lOKSAhPT0gMDtcblx0dmFyIGlzX291dHJvID0gKGZsYWdzICYgVFJBTlNJVElPTl9PVVQpICE9PSAwO1xuXHR2YXIgaXNfYm90aCA9IGlzX2ludHJvICYmIGlzX291dHJvO1xuXHR2YXIgaXNfZ2xvYmFsID0gKGZsYWdzICYgVFJBTlNJVElPTl9HTE9CQUwpICE9PSAwO1xuXG5cdC8qKiBAdHlwZSB7J2luJyB8ICdvdXQnIHwgJ2JvdGgnfSAqL1xuXHR2YXIgZGlyZWN0aW9uID0gaXNfYm90aCA/ICdib3RoJyA6IGlzX2ludHJvID8gJ2luJyA6ICdvdXQnO1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uQ29uZmlnIHwgKChvcHRzOiB7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIH0pID0+IEFuaW1hdGlvbkNvbmZpZykgfCB1bmRlZmluZWR9ICovXG5cdHZhciBjdXJyZW50X29wdGlvbnM7XG5cblx0dmFyIGluZXJ0ID0gZWxlbWVudC5pbmVydDtcblxuXHQvKipcblx0ICogVGhlIGRlZmF1bHQgb3ZlcmZsb3cgc3R5bGUsIHN0YXNoZWQgc28gd2UgY2FuIHJldmVydCBjaGFuZ2VzIGR1cmluZyB0aGUgdHJhbnNpdGlvblxuXHQgKiB0aGF0IGFyZSBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBTYWZhcmkgPDE4IGJ1Z1xuXHQgKiBUT0RPIDYuMCByZW1vdmUgdGhpcywgaWYgb2xkZXIgdmVyc2lvbnMgb2YgU2FmYXJpIGhhdmUgZGllZCBvdXQgZW5vdWdoXG5cdCAqL1xuXHR2YXIgb3ZlcmZsb3cgPSBlbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuXG5cdC8qKiBAdHlwZSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSAqL1xuXHR2YXIgaW50cm87XG5cblx0LyoqIEB0eXBlIHtBbmltYXRpb24gfCB1bmRlZmluZWR9ICovXG5cdHZhciBvdXRybztcblxuXHRmdW5jdGlvbiBnZXRfb3B0aW9ucygpIHtcblx0XHRyZXR1cm4gd2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KCgpID0+IHtcblx0XHRcdC8vIElmIGEgdHJhbnNpdGlvbiBpcyBzdGlsbCBvbmdvaW5nLCB3ZSB1c2UgdGhlIGV4aXN0aW5nIG9wdGlvbnMgcmF0aGVyIHRoYW4gZ2VuZXJhdGluZ1xuXHRcdFx0Ly8gbmV3IG9uZXMuIFRoaXMgZW5zdXJlcyB0aGF0IHJldmVyc2libGUgdHJhbnNpdGlvbnMgcmV2ZXJzZSBzbW9vdGhseSwgcmF0aGVyIHRoYW5cblx0XHRcdC8vIGp1bXBpbmcgdG8gYSBuZXcgc3BvdCBiZWNhdXNlIChmb3IgZXhhbXBsZSkgYSBkaWZmZXJlbnQgYGR1cmF0aW9uYCB3YXMgdXNlZFxuXHRcdFx0cmV0dXJuIChjdXJyZW50X29wdGlvbnMgPz89IGdldF9mbigpKGVsZW1lbnQsIGdldF9wYXJhbXM/LigpID8/IC8qKiBAdHlwZSB7UH0gKi8gKHt9KSwge1xuXHRcdFx0XHRkaXJlY3Rpb25cblx0XHRcdH0pKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKiBAdHlwZSB7VHJhbnNpdGlvbk1hbmFnZXJ9ICovXG5cdHZhciB0cmFuc2l0aW9uID0ge1xuXHRcdGlzX2dsb2JhbCxcblx0XHRpbigpIHtcblx0XHRcdGVsZW1lbnQuaW5lcnQgPSBpbmVydDtcblxuXHRcdFx0aWYgKCFpc19pbnRybykge1xuXHRcdFx0XHRvdXRybz8uYWJvcnQoKTtcblx0XHRcdFx0b3V0cm8/LnJlc2V0Py4oKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzX291dHJvKSB7XG5cdFx0XHRcdC8vIGlmIHdlIGludHJvIHRoZW4gb3V0cm8gdGhlbiBpbnRybyBhZ2Fpbiwgd2Ugd2FudCB0byBhYm9ydCB0aGUgZmlyc3QgaW50cm8sXG5cdFx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmlkaXJlY3Rpb25hbCB0cmFuc2l0aW9uXG5cdFx0XHRcdGludHJvPy5hYm9ydCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnaW50cm9zdGFydCcpO1xuXG5cdFx0XHRpbnRybyA9IGFuaW1hdGUoZWxlbWVudCwgZ2V0X29wdGlvbnMoKSwgb3V0cm8sIDEsICgpID0+IHtcblx0XHRcdFx0ZGlzcGF0Y2hfZXZlbnQoZWxlbWVudCwgJ2ludHJvZW5kJyk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHdlIGNhbmNlbCB0aGUgYW5pbWF0aW9uIHRvIHByZXZlbnQgbGVha2luZ1xuXHRcdFx0XHRpbnRybz8uYWJvcnQoKTtcblx0XHRcdFx0aW50cm8gPSBjdXJyZW50X29wdGlvbnMgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0ZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRvdXQoZm4pIHtcblx0XHRcdGlmICghaXNfb3V0cm8pIHtcblx0XHRcdFx0Zm4/LigpO1xuXHRcdFx0XHRjdXJyZW50X29wdGlvbnMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbWVudC5pbmVydCA9IHRydWU7XG5cblx0XHRcdGRpc3BhdGNoX2V2ZW50KGVsZW1lbnQsICdvdXRyb3N0YXJ0Jyk7XG5cblx0XHRcdG91dHJvID0gYW5pbWF0ZShlbGVtZW50LCBnZXRfb3B0aW9ucygpLCBpbnRybywgMCwgKCkgPT4ge1xuXHRcdFx0XHRkaXNwYXRjaF9ldmVudChlbGVtZW50LCAnb3V0cm9lbmQnKTtcblx0XHRcdFx0Zm4/LigpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0XHRzdG9wOiAoKSA9PiB7XG5cdFx0XHRpbnRybz8uYWJvcnQoKTtcblx0XHRcdG91dHJvPy5hYm9ydCgpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgZSA9IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdCk7XG5cblx0KGUudHJhbnNpdGlvbnMgPz89IFtdKS5wdXNoKHRyYW5zaXRpb24pO1xuXG5cdC8vIGlmIHRoaXMgaXMgYSBsb2NhbCB0cmFuc2l0aW9uLCB3ZSBvbmx5IHdhbnQgdG8gcnVuIGl0IGlmIHRoZSBwYXJlbnQgKGJyYW5jaCkgZWZmZWN0J3Ncblx0Ly8gcGFyZW50IChibG9jaykgZWZmZWN0IGlzIHdoZXJlIHRoZSBzdGF0ZSBjaGFuZ2UgaGFwcGVuZWQuIHdlIGNhbiBkZXRlcm1pbmUgdGhhdCBieVxuXHQvLyBsb29raW5nIGF0IHdoZXRoZXIgdGhlIGJsb2NrIGVmZmVjdCBpcyBjdXJyZW50bHkgaW5pdGlhbGl6aW5nXG5cdGlmIChpc19pbnRybyAmJiBzaG91bGRfaW50cm8pIHtcblx0XHR2YXIgcnVuID0gaXNfZ2xvYmFsO1xuXG5cdFx0aWYgKCFydW4pIHtcblx0XHRcdHZhciBibG9jayA9IC8qKiBAdHlwZSB7RWZmZWN0IHwgbnVsbH0gKi8gKGUucGFyZW50KTtcblxuXHRcdFx0Ly8gc2tpcCBvdmVyIHRyYW5zcGFyZW50IGJsb2NrcyAoZS5nLiBzbmlwcGV0cywgZWxzZS1pZiBibG9ja3MpXG5cdFx0XHR3aGlsZSAoYmxvY2sgJiYgKGJsb2NrLmYgJiBFRkZFQ1RfVFJBTlNQQVJFTlQpICE9PSAwKSB7XG5cdFx0XHRcdHdoaWxlICgoYmxvY2sgPSBibG9jay5wYXJlbnQpKSB7XG5cdFx0XHRcdFx0aWYgKChibG9jay5mICYgQkxPQ0tfRUZGRUNUKSAhPT0gMCkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cnVuID0gIWJsb2NrIHx8IChibG9jay5mICYgRUZGRUNUX1JBTikgIT09IDA7XG5cdFx0fVxuXG5cdFx0aWYgKHJ1bikge1xuXHRcdFx0ZWZmZWN0KCgpID0+IHtcblx0XHRcdFx0dW50cmFjaygoKSA9PiB0cmFuc2l0aW9uLmluKCkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQW5pbWF0ZXMgYW4gZWxlbWVudCwgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7QW5pbWF0aW9uQ29uZmlnIHwgKChvcHRzOiB7IGRpcmVjdGlvbjogJ2luJyB8ICdvdXQnIH0pID0+IEFuaW1hdGlvbkNvbmZpZyl9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW5pbWF0aW9uIHwgdW5kZWZpbmVkfSBjb3VudGVycGFydCBUaGUgY29ycmVzcG9uZGluZyBpbnRyby9vdXRybyB0byB0aGlzIG91dHJvL2ludHJvXG4gKiBAcGFyYW0ge251bWJlcn0gdDIgVGhlIHRhcmdldCBgdGAgdmFsdWUgXHUyMDE0IGAxYCBmb3IgaW50cm8sIGAwYCBmb3Igb3V0cm9cbiAqIEBwYXJhbSB7KCgpID0+IHZvaWQpfSBvbl9maW5pc2ggQ2FsbGVkIGFmdGVyIHN1Y2Nlc3NmdWxseSBjb21wbGV0aW5nIHRoZSBhbmltYXRpb25cbiAqIEByZXR1cm5zIHtBbmltYXRpb259XG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoZWxlbWVudCwgb3B0aW9ucywgY291bnRlcnBhcnQsIHQyLCBvbl9maW5pc2gpIHtcblx0dmFyIGlzX2ludHJvID0gdDIgPT09IDE7XG5cblx0aWYgKGlzX2Z1bmN0aW9uKG9wdGlvbnMpKSB7XG5cdFx0Ly8gSW4gdGhlIGNhc2Ugb2YgYSBkZWZlcnJlZCB0cmFuc2l0aW9uIChzdWNoIGFzIGBjcm9zc2ZhZGVgKSwgYG9wdGlvbmAgd2lsbCBiZVxuXHRcdC8vIGEgZnVuY3Rpb24gcmF0aGVyIHRoYW4gYW4gYEFuaW1hdGlvbkNvbmZpZ2AuIFdlIG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uXG5cdFx0Ly8gb25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQuLi5cblx0XHQvKiogQHR5cGUge0FuaW1hdGlvbn0gKi9cblx0XHR2YXIgYTtcblx0XHR2YXIgYWJvcnRlZCA9IGZhbHNlO1xuXG5cdFx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0XHRpZiAoYWJvcnRlZCkgcmV0dXJuO1xuXHRcdFx0dmFyIG8gPSBvcHRpb25zKHsgZGlyZWN0aW9uOiBpc19pbnRybyA/ICdpbicgOiAnb3V0JyB9KTtcblx0XHRcdGEgPSBhbmltYXRlKGVsZW1lbnQsIG8sIGNvdW50ZXJwYXJ0LCB0Miwgb25fZmluaXNoKTtcblx0XHR9KTtcblxuXHRcdC8vIC4uLmJ1dCB3ZSB3YW50IHRvIGRvIHNvIHdpdGhvdXQgdXNpbmcgYGFzeW5jYC9gYXdhaXRgIGV2ZXJ5d2hlcmUsIHNvXG5cdFx0Ly8gd2UgcmV0dXJuIGEgZmFjYWRlIHRoYXQgYWxsb3dzIGV2ZXJ5dGhpbmcgdG8gcmVtYWluIHN5bmNocm9ub3VzXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFib3J0OiAoKSA9PiB7XG5cdFx0XHRcdGFib3J0ZWQgPSB0cnVlO1xuXHRcdFx0XHRhPy5hYm9ydCgpO1xuXHRcdFx0fSxcblx0XHRcdGRlYWN0aXZhdGU6ICgpID0+IGEuZGVhY3RpdmF0ZSgpLFxuXHRcdFx0cmVzZXQ6ICgpID0+IGEucmVzZXQoKSxcblx0XHRcdHQ6ICgpID0+IGEudCgpXG5cdFx0fTtcblx0fVxuXG5cdGNvdW50ZXJwYXJ0Py5kZWFjdGl2YXRlKCk7XG5cblx0aWYgKCFvcHRpb25zPy5kdXJhdGlvbikge1xuXHRcdG9uX2ZpbmlzaCgpO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFib3J0OiBub29wLFxuXHRcdFx0ZGVhY3RpdmF0ZTogbm9vcCxcblx0XHRcdHJlc2V0OiBub29wLFxuXHRcdFx0dDogKCkgPT4gdDJcblx0XHR9O1xuXHR9XG5cblx0Y29uc3QgeyBkZWxheSA9IDAsIGNzcywgdGljaywgZWFzaW5nID0gbGluZWFyIH0gPSBvcHRpb25zO1xuXG5cdHZhciBrZXlmcmFtZXMgPSBbXTtcblxuXHRpZiAoaXNfaW50cm8gJiYgY291bnRlcnBhcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdGlmICh0aWNrKSB7XG5cdFx0XHR0aWNrKDAsIDEpOyAvLyBUT0RPIHB1dCBpbiBuZXN0ZWQgZWZmZWN0LCB0byBhdm9pZCBpbnRlcmxlYXZlZCByZWFkcy93cml0ZXM/XG5cdFx0fVxuXG5cdFx0aWYgKGNzcykge1xuXHRcdFx0dmFyIHN0eWxlcyA9IGNzc190b19rZXlmcmFtZShjc3MoMCwgMSkpO1xuXHRcdFx0a2V5ZnJhbWVzLnB1c2goc3R5bGVzLCBzdHlsZXMpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBnZXRfdCA9ICgpID0+IDEgLSB0MjtcblxuXHQvLyBjcmVhdGUgYSBkdW1teSBhbmltYXRpb24gdGhhdCBsYXN0cyBhcyBsb25nIGFzIHRoZSBkZWxheSAoYnV0IHdpdGggd2hhdGV2ZXIgZGV2dG9vbHNcblx0Ly8gbXVsdGlwbGllciBpcyBpbiBlZmZlY3QpLiBpbiB0aGUgY29tbW9uIGNhc2UgdGhhdCBpdCBpcyBgMGAsIHdlIGtlZXAgaXQgYW55d2F5IHNvIHRoYXRcblx0Ly8gdGhlIENTUyBrZXlmcmFtZXMgYXJlbid0IGNyZWF0ZWQgdW50aWwgdGhlIERPTSBpcyB1cGRhdGVkXG5cdC8vXG5cdC8vIGZpbGwgZm9yd2FyZHMgdG8gcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIHJlbmRlcmluZyB3aXRob3V0IHN0eWxlcyBhcHBsaWVkXG5cdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8xNDczMlxuXHR2YXIgYW5pbWF0aW9uID0gZWxlbWVudC5hbmltYXRlKGtleWZyYW1lcywgeyBkdXJhdGlvbjogZGVsYXksIGZpbGw6ICdmb3J3YXJkcycgfSk7XG5cblx0YW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuXHRcdC8vIHJlbW92ZSBkdW1teSBhbmltYXRpb24gZnJvbSB0aGUgc3RhY2sgdG8gcHJldmVudCBjb25mbGljdCB3aXRoIG1haW4gYW5pbWF0aW9uXG5cdFx0YW5pbWF0aW9uLmNhbmNlbCgpO1xuXG5cdFx0Ly8gZm9yIGJpZGlyZWN0aW9uYWwgdHJhbnNpdGlvbnMsIHdlIHN0YXJ0IGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24sXG5cdFx0Ly8gcmF0aGVyIHRoYW4gZG9pbmcgYSBmdWxsIGludHJvL291dHJvXG5cdFx0dmFyIHQxID0gY291bnRlcnBhcnQ/LnQoKSA/PyAxIC0gdDI7XG5cdFx0Y291bnRlcnBhcnQ/LmFib3J0KCk7XG5cblx0XHR2YXIgZGVsdGEgPSB0MiAtIHQxO1xuXHRcdHZhciBkdXJhdGlvbiA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAob3B0aW9ucy5kdXJhdGlvbikgKiBNYXRoLmFicyhkZWx0YSk7XG5cdFx0dmFyIGtleWZyYW1lcyA9IFtdO1xuXG5cdFx0aWYgKGR1cmF0aW9uID4gMCkge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBXaGV0aGVyIG9yIG5vdCB0aGUgQ1NTIGluY2x1ZGVzIGBvdmVyZmxvdzogaGlkZGVuYCwgaW4gd2hpY2ggY2FzZSB3ZSBuZWVkIHRvXG5cdFx0XHQgKiBhZGQgaXQgYXMgYW4gaW5saW5lIHN0eWxlIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIDwxOCBidWdcblx0XHRcdCAqIFRPRE8gNi4wIHJlbW92ZSB0aGlzLCBpZiBwb3NzaWJsZVxuXHRcdFx0ICovXG5cdFx0XHR2YXIgbmVlZHNfb3ZlcmZsb3dfaGlkZGVuID0gZmFsc2U7XG5cblx0XHRcdGlmIChjc3MpIHtcblx0XHRcdFx0dmFyIG4gPSBNYXRoLmNlaWwoZHVyYXRpb24gLyAoMTAwMCAvIDYwKSk7IC8vIGBuYCBtdXN0IGJlIGFuIGludGVnZXIsIG9yIHdlIHJpc2sgbWlzc2luZyB0aGUgYHQyYCB2YWx1ZVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IG47IGkgKz0gMSkge1xuXHRcdFx0XHRcdHZhciB0ID0gdDEgKyBkZWx0YSAqIGVhc2luZyhpIC8gbik7XG5cdFx0XHRcdFx0dmFyIHN0eWxlcyA9IGNzc190b19rZXlmcmFtZShjc3ModCwgMSAtIHQpKTtcblx0XHRcdFx0XHRrZXlmcmFtZXMucHVzaChzdHlsZXMpO1xuXG5cdFx0XHRcdFx0bmVlZHNfb3ZlcmZsb3dfaGlkZGVuIHx8PSBzdHlsZXMub3ZlcmZsb3cgPT09ICdoaWRkZW4nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZWVkc19vdmVyZmxvd19oaWRkZW4pIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGVsZW1lbnQpLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cdFx0XHR9XG5cblx0XHRcdGdldF90ID0gKCkgPT4ge1xuXHRcdFx0XHR2YXIgdGltZSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoXG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtnbG9iYWxUaGlzLkFuaW1hdGlvbn0gKi8gKGFuaW1hdGlvbikuY3VycmVudFRpbWVcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRyZXR1cm4gdDEgKyBkZWx0YSAqIGVhc2luZyh0aW1lIC8gZHVyYXRpb24pO1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRpY2spIHtcblx0XHRcdFx0bG9vcCgoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGFuaW1hdGlvbi5wbGF5U3RhdGUgIT09ICdydW5uaW5nJykgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0dmFyIHQgPSBnZXRfdCgpO1xuXHRcdFx0XHRcdHRpY2sodCwgMSAtIHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFuaW1hdGlvbiA9IGVsZW1lbnQuYW5pbWF0ZShrZXlmcmFtZXMsIHsgZHVyYXRpb24sIGZpbGw6ICdmb3J3YXJkcycgfSk7XG5cblx0XHRhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG5cdFx0XHRnZXRfdCA9ICgpID0+IHQyO1xuXHRcdFx0dGljaz8uKHQyLCAxIC0gdDIpO1xuXHRcdFx0b25fZmluaXNoKCk7XG5cdFx0fTtcblx0fTtcblxuXHRyZXR1cm4ge1xuXHRcdGFib3J0OiAoKSA9PiB7XG5cdFx0XHRpZiAoYW5pbWF0aW9uKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi5jYW5jZWwoKTtcblx0XHRcdFx0Ly8gVGhpcyBwcmV2ZW50cyBtZW1vcnkgbGVha3MgaW4gQ2hyb21pdW1cblx0XHRcdFx0YW5pbWF0aW9uLmVmZmVjdCA9IG51bGw7XG5cdFx0XHRcdC8vIFRoaXMgcHJldmVudHMgb25maW5pc2ggdG8gYmUgbGF1bmNoZWQgYWZ0ZXIgY2FuY2VsKCksXG5cdFx0XHRcdC8vIHdoaWNoIGNhbiBoYXBwZW4gaW4gc29tZSByYXJlIGNhc2VzXG5cdFx0XHRcdC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8xMzY4MVxuXHRcdFx0XHRhbmltYXRpb24ub25maW5pc2ggPSBub29wO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVhY3RpdmF0ZTogKCkgPT4ge1xuXHRcdFx0b25fZmluaXNoID0gbm9vcDtcblx0XHR9LFxuXHRcdHJlc2V0OiAoKSA9PiB7XG5cdFx0XHRpZiAodDIgPT09IDApIHtcblx0XHRcdFx0dGljaz8uKDEsIDApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dDogKCkgPT4gZ2V0X3QoKVxuXHR9O1xufVxuIiwgImltcG9ydCB7IGxpc3RlbiB9IGZyb20gJy4vc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyhhY3RpdmVFbGVtZW50OiBFbGVtZW50IHwgbnVsbCkgPT4gdm9pZH0gdXBkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfYWN0aXZlX2VsZW1lbnQodXBkYXRlKSB7XG5cdGxpc3Rlbihkb2N1bWVudCwgWydmb2N1c2luJywgJ2ZvY3Vzb3V0J10sIChldmVudCkgPT4ge1xuXHRcdGlmIChldmVudCAmJiBldmVudC50eXBlID09PSAnZm9jdXNvdXQnICYmIC8qKiBAdHlwZSB7Rm9jdXNFdmVudH0gKi8gKGV2ZW50KS5yZWxhdGVkVGFyZ2V0KSB7XG5cdFx0XHQvLyBUaGUgdGVzdHMgc3RpbGwgcGFzcyBpZiB3ZSByZW1vdmUgdGhpcywgYmVjYXVzZSBvZiBKU0RPTSBsaW1pdGF0aW9ucywgYnV0IGl0IGlzIG5lY2Vzc2FyeVxuXHRcdFx0Ly8gdG8gYXZvaWQgdGVtcG9yYXJpbHkgcmVzZXR0aW5nIHRvIGBkb2N1bWVudC5ib2R5YFxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHVwZGF0ZShkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblx0fSk7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBCYXRjaCB9IGZyb20gJy4uLy4uLy4uL3JlYWN0aXZpdHkvYmF0Y2guanMnICovXG5pbXBvcnQgeyBERVYgfSBmcm9tICdlc20tZW52JztcbmltcG9ydCB7IHJlbmRlcl9lZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uLy4uLy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBpcyB9IGZyb20gJy4uLy4uLy4uL3Byb3h5LmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi8uLi90YXNrLmpzJztcbmltcG9ydCB7IGh5ZHJhdGluZyB9IGZyb20gJy4uLy4uL2h5ZHJhdGlvbi5qcyc7XG5pbXBvcnQgeyB0aWNrLCB1bnRyYWNrIH0gZnJvbSAnLi4vLi4vLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyBpc19ydW5lcyB9IGZyb20gJy4uLy4uLy4uL2NvbnRleHQuanMnO1xuaW1wb3J0IHsgY3VycmVudF9iYXRjaCwgcHJldmlvdXNfYmF0Y2ggfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2JhdGNoLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3ZhbHVlKGlucHV0LCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgYmF0Y2hlcyA9IG5ldyBXZWFrU2V0KCk7XG5cblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2lucHV0JywgYXN5bmMgKGlzX3Jlc2V0KSA9PiB7XG5cdFx0aWYgKERFViAmJiBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XG5cdFx0XHQvLyBUT0RPIHNob3VsZCB0aGlzIGhhcHBlbiBpbiBwcm9kIHRvbz9cblx0XHRcdGUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0LyoqIEB0eXBlIHthbnl9ICovXG5cdFx0dmFyIHZhbHVlID0gaXNfcmVzZXQgPyBpbnB1dC5kZWZhdWx0VmFsdWUgOiBpbnB1dC52YWx1ZTtcblx0XHR2YWx1ZSA9IGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpID8gdG9fbnVtYmVyKHZhbHVlKSA6IHZhbHVlO1xuXHRcdHNldCh2YWx1ZSk7XG5cblx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0YmF0Y2hlcy5hZGQoY3VycmVudF9iYXRjaCk7XG5cdFx0fVxuXG5cdFx0Ly8gQmVjYXVzZSBgeyNlYWNoIC4uLn1gIGJsb2NrcyB3b3JrIGJ5IHVwZGF0aW5nIHNvdXJjZXMgaW5zaWRlIHRoZSBmbHVzaCxcblx0XHQvLyB3ZSBuZWVkIHRvIHdhaXQgYSB0aWNrIGJlZm9yZSBjaGVja2luZyB0byBzZWUgaWYgd2Ugc2hvdWxkIGZvcmNpYmx5XG5cdFx0Ly8gdXBkYXRlIHRoZSBpbnB1dCBhbmQgcmVzZXQgdGhlIHNlbGVjdGlvbiBzdGF0ZVxuXHRcdGF3YWl0IHRpY2soKTtcblxuXHRcdC8vIFJlc3BlY3QgYW55IHZhbGlkYXRpb24gaW4gYWNjZXNzb3JzXG5cdFx0aWYgKHZhbHVlICE9PSAodmFsdWUgPSBnZXQoKSkpIHtcblx0XHRcdHZhciBzdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0O1xuXHRcdFx0dmFyIGVuZCA9IGlucHV0LnNlbGVjdGlvbkVuZDtcblxuXHRcdFx0Ly8gdGhlIHZhbHVlIGlzIGNvZXJjZWQgb24gYXNzaWdubWVudFxuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZSA/PyAnJztcblxuXHRcdFx0Ly8gUmVzdG9yZSBzZWxlY3Rpb25cblx0XHRcdGlmIChlbmQgIT09IG51bGwpIHtcblx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcblx0XHRcdFx0aW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0aWYgKFxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCxcblx0XHQvLyB0aGVuIHVzZSB0aGUgdXBkYXRlZCB2YWx1ZSBmcm9tIHRoZSBpbnB1dCBpbnN0ZWFkLlxuXHRcdChoeWRyYXRpbmcgJiYgaW5wdXQuZGVmYXVsdFZhbHVlICE9PSBpbnB1dC52YWx1ZSkgfHxcblx0XHQvLyBJZiBkZWZhdWx0VmFsdWUgaXMgc2V0LCB0aGVuIHZhbHVlID09IGRlZmF1bHRWYWx1ZVxuXHRcdC8vIFRPRE8gU3ZlbHRlIDY6IHJlbW92ZSBpbnB1dC52YWx1ZSBjaGVjayBhbmQgc2V0IHRvIGVtcHR5IHN0cmluZz9cblx0XHQodW50cmFjayhnZXQpID09IG51bGwgJiYgaW5wdXQudmFsdWUpXG5cdCkge1xuXHRcdHNldChpc19udW1iZXJsaWtlX2lucHV0KGlucHV0KSA/IHRvX251bWJlcihpbnB1dC52YWx1ZSkgOiBpbnB1dC52YWx1ZSk7XG5cblx0XHRpZiAoY3VycmVudF9iYXRjaCAhPT0gbnVsbCkge1xuXHRcdFx0YmF0Y2hlcy5hZGQoY3VycmVudF9iYXRjaCk7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKERFViAmJiBpbnB1dC50eXBlID09PSAnY2hlY2tib3gnKSB7XG5cdFx0XHQvLyBUT0RPIHNob3VsZCB0aGlzIGhhcHBlbiBpbiBwcm9kIHRvbz9cblx0XHRcdGUuYmluZF9pbnZhbGlkX2NoZWNrYm94X3ZhbHVlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cblx0XHRpZiAoaW5wdXQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcblx0XHRcdC8vIHdlIG5lZWQgYm90aCwgYmVjYXVzZSBpbiBub24tYXN5bmMgbW9kZSwgcmVuZGVyIGVmZmVjdHMgcnVuIGJlZm9yZSBwcmV2aW91c19iYXRjaCBpcyBzZXRcblx0XHRcdHZhciBiYXRjaCA9IC8qKiBAdHlwZSB7QmF0Y2h9ICovIChwcmV2aW91c19iYXRjaCA/PyBjdXJyZW50X2JhdGNoKTtcblxuXHRcdFx0Ly8gTmV2ZXIgcmV3cml0ZSB0aGUgY29udGVudHMgb2YgYSBmb2N1c2VkIGlucHV0LiBXZSBjYW4gZ2V0IGhlcmUgaWYsIGZvciBleGFtcGxlLFxuXHRcdFx0Ly8gYW4gdXBkYXRlIGlzIGRlZmVycmVkIGJlY2F1c2Ugb2YgYXN5bmMgd29yayBkZXBlbmRpbmcgb24gdGhlIGlucHV0OlxuXHRcdFx0Ly9cblx0XHRcdC8vIDxpbnB1dCBiaW5kOnZhbHVlPXtxdWVyeX0+XG5cdFx0XHQvLyA8cD57YXdhaXQgZmluZChxdWVyeSl9PC9wPlxuXHRcdFx0aWYgKGJhdGNoZXMuaGFzKGJhdGNoKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpICYmIHZhbHVlID09PSB0b19udW1iZXIoaW5wdXQudmFsdWUpKSB7XG5cdFx0XHQvLyBoYW5kbGVzIDAgdnMgMDAgY2FzZSAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzk5NTkpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGlucHV0LnR5cGUgPT09ICdkYXRlJyAmJiAhdmFsdWUgJiYgIWlucHV0LnZhbHVlKSB7XG5cdFx0XHQvLyBIYW5kbGVzIHRoZSBjYXNlIHdoZXJlIGEgdGVtcG9yYXJpbHkgaW52YWxpZCBkYXRlIGlzIHNldCAod2hpbGUgdHlwaW5nLCBmb3IgZXhhbXBsZSB3aXRoIGEgbGVhZGluZyAwIGZvciB0aGUgZGF5KVxuXHRcdFx0Ly8gYW5kIHByZXZlbnRzIHRoaXMgc3RhdGUgZnJvbSBjbGVhcmluZyB0aGUgb3RoZXIgcGFydHMgb2YgdGhlIGRhdGUgaW5wdXQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy83ODk3KVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGRvbid0IHNldCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGlmIGl0J3MgdGhlIHNhbWUgdG8gYWxsb3dcblx0XHQvLyBtaW5sZW5ndGggdG8gd29yayBwcm9wZXJseVxuXHRcdGlmICh2YWx1ZSAhPT0gaW5wdXQudmFsdWUpIHtcblx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgdGhlIHZhbHVlIGlzIGNvZXJjZWQgb24gYXNzaWdubWVudFxuXHRcdFx0aW5wdXQudmFsdWUgPSB2YWx1ZSA/PyAnJztcblx0XHR9XG5cdH0pO1xufVxuXG4vKiogQHR5cGUge1NldDxIVE1MSW5wdXRFbGVtZW50W10+fSAqL1xuY29uc3QgcGVuZGluZyA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnRbXX0gaW5wdXRzXG4gKiBAcGFyYW0ge251bGwgfCBbbnVtYmVyXX0gZ3JvdXBfaW5kZXhcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bn0gZ2V0XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93bikgPT4gdm9pZH0gc2V0XG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZ3JvdXAoaW5wdXRzLCBncm91cF9pbmRleCwgaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdHZhciBpc19jaGVja2JveCA9IGlucHV0LmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAnY2hlY2tib3gnO1xuXHR2YXIgYmluZGluZ19ncm91cCA9IGlucHV0cztcblxuXHQvLyBuZWVkcyB0byBiZSBsZXQgb3IgcmVsYXRlZCBjb2RlIGlzbid0IHRyZWVzaGFrZW4gb3V0IGlmIGl0J3MgYWx3YXlzIGZhbHNlXG5cdGxldCBoeWRyYXRpb25fbWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRpZiAoZ3JvdXBfaW5kZXggIT09IG51bGwpIHtcblx0XHRmb3IgKHZhciBpbmRleCBvZiBncm91cF9pbmRleCkge1xuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0YmluZGluZ19ncm91cCA9IGJpbmRpbmdfZ3JvdXBbaW5kZXhdID8/PSBbXTtcblx0XHR9XG5cdH1cblxuXHRiaW5kaW5nX2dyb3VwLnB1c2goaW5wdXQpO1xuXG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoXG5cdFx0aW5wdXQsXG5cdFx0J2NoYW5nZScsXG5cdFx0KCkgPT4ge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dmFyIHZhbHVlID0gaW5wdXQuX192YWx1ZTtcblxuXHRcdFx0aWYgKGlzX2NoZWNrYm94KSB7XG5cdFx0XHRcdHZhbHVlID0gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoYmluZGluZ19ncm91cCwgdmFsdWUsIGlucHV0LmNoZWNrZWQpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXQodmFsdWUpO1xuXHRcdH0sXG5cdFx0Ly8gVE9ETyBiZXR0ZXIgZGVmYXVsdCB2YWx1ZSBoYW5kbGluZ1xuXHRcdCgpID0+IHNldChpc19jaGVja2JveCA/IFtdIDogbnVsbClcblx0KTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblxuXHRcdC8vIElmIHdlIGFyZSBoeWRyYXRpbmcgYW5kIHRoZSB2YWx1ZSBoYXMgc2luY2UgY2hhbmdlZCwgdGhlbiB1c2UgdGhlIHVwZGF0ZSB2YWx1ZVxuXHRcdC8vIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0aWYgKGh5ZHJhdGluZyAmJiBpbnB1dC5kZWZhdWx0Q2hlY2tlZCAhPT0gaW5wdXQuY2hlY2tlZCkge1xuXHRcdFx0aHlkcmF0aW9uX21pc21hdGNoID0gdHJ1ZTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoaXNfY2hlY2tib3gpIHtcblx0XHRcdHZhbHVlID0gdmFsdWUgfHwgW107XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRpbnB1dC5jaGVja2VkID0gdmFsdWUuaW5jbHVkZXMoaW5wdXQuX192YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdGlucHV0LmNoZWNrZWQgPSBpcyhpbnB1dC5fX3ZhbHVlLCB2YWx1ZSk7XG5cdFx0fVxuXHR9KTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0dmFyIGluZGV4ID0gYmluZGluZ19ncm91cC5pbmRleE9mKGlucHV0KTtcblxuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdGJpbmRpbmdfZ3JvdXAuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmICghcGVuZGluZy5oYXMoYmluZGluZ19ncm91cCkpIHtcblx0XHRwZW5kaW5nLmFkZChiaW5kaW5nX2dyb3VwKTtcblxuXHRcdHF1ZXVlX21pY3JvX3Rhc2soKCkgPT4ge1xuXHRcdFx0Ly8gbmVjZXNzYXJ5IHRvIG1haW50YWluIGJpbmRpbmcgZ3JvdXAgb3JkZXIgaW4gYWxsIGluc2VydGlvbiBzY2VuYXJpb3Ncblx0XHRcdGJpbmRpbmdfZ3JvdXAuc29ydCgoYSwgYikgPT4gKGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgPT09IDQgPyAtMSA6IDEpKTtcblx0XHRcdHBlbmRpbmcuZGVsZXRlKGJpbmRpbmdfZ3JvdXApO1xuXHRcdH0pO1xuXHR9XG5cblx0cXVldWVfbWljcm9fdGFzaygoKSA9PiB7XG5cdFx0aWYgKGh5ZHJhdGlvbl9taXNtYXRjaCkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXG5cdFx0XHRpZiAoaXNfY2hlY2tib3gpIHtcblx0XHRcdFx0dmFsdWUgPSBnZXRfYmluZGluZ19ncm91cF92YWx1ZShiaW5kaW5nX2dyb3VwLCB2YWx1ZSwgaW5wdXQuY2hlY2tlZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaHlkcmF0aW9uX2lucHV0ID0gYmluZGluZ19ncm91cC5maW5kKChpbnB1dCkgPT4gaW5wdXQuY2hlY2tlZCk7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0dmFsdWUgPSBoeWRyYXRpb25faW5wdXQ/Ll9fdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdHNldCh2YWx1ZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0geygpID0+IHVua25vd259IGdldFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2NoZWNrZWQoaW5wdXQsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdGxpc3Rlbl90b19ldmVudF9hbmRfcmVzZXRfZXZlbnQoaW5wdXQsICdjaGFuZ2UnLCAoaXNfcmVzZXQpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBpc19yZXNldCA/IGlucHV0LmRlZmF1bHRDaGVja2VkIDogaW5wdXQuY2hlY2tlZDtcblx0XHRzZXQodmFsdWUpO1xuXHR9KTtcblxuXHRpZiAoXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLFxuXHRcdC8vIHRoZW4gdXNlIHRoZSB1cGRhdGUgdmFsdWUgZnJvbSB0aGUgaW5wdXQgaW5zdGVhZC5cblx0XHQoaHlkcmF0aW5nICYmIGlucHV0LmRlZmF1bHRDaGVja2VkICE9PSBpbnB1dC5jaGVja2VkKSB8fFxuXHRcdC8vIElmIGRlZmF1bHRDaGVja2VkIGlzIHNldCwgdGhlbiBjaGVja2VkID09IGRlZmF1bHRDaGVja2VkXG5cdFx0dW50cmFjayhnZXQpID09IG51bGxcblx0KSB7XG5cdFx0c2V0KGlucHV0LmNoZWNrZWQpO1xuXHR9XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIHZhbHVlID0gZ2V0KCk7XG5cdFx0aW5wdXQuY2hlY2tlZCA9IEJvb2xlYW4odmFsdWUpO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtBcnJheTxIVE1MSW5wdXRFbGVtZW50Pn0gZ3JvdXBcbiAqIEBwYXJhbSB7Vn0gX192YWx1ZVxuICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gKiBAcmV0dXJucyB7VltdfVxuICovXG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuXHQvKiogQHR5cGUge1NldDxWPn0gKi9cblx0dmFyIHZhbHVlID0gbmV3IFNldCgpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0dmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghY2hlY2tlZCkge1xuXHRcdHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcblx0fVxuXG5cdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlzX251bWJlcmxpa2VfaW5wdXQoaW5wdXQpIHtcblx0dmFyIHR5cGUgPSBpbnB1dC50eXBlO1xuXHRyZXR1cm4gdHlwZSA9PT0gJ251bWJlcicgfHwgdHlwZSA9PT0gJ3JhbmdlJztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9fbnVtYmVyKHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7KCkgPT4gRmlsZUxpc3QgfCBudWxsfSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiBGaWxlTGlzdCB8IG51bGwpID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9maWxlcyhpbnB1dCwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0bGlzdGVuX3RvX2V2ZW50X2FuZF9yZXNldF9ldmVudChpbnB1dCwgJ2NoYW5nZScsICgpID0+IHtcblx0XHRzZXQoaW5wdXQuZmlsZXMpO1xuXHR9KTtcblxuXHRpZiAoXG5cdFx0Ly8gSWYgd2UgYXJlIGh5ZHJhdGluZyBhbmQgdGhlIHZhbHVlIGhhcyBzaW5jZSBjaGFuZ2VkLFxuXHRcdC8vIHRoZW4gdXNlIHRoZSB1cGRhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IGluc3RlYWQuXG5cdFx0aHlkcmF0aW5nICYmXG5cdFx0aW5wdXQuZmlsZXNcblx0KSB7XG5cdFx0c2V0KGlucHV0LmZpbGVzKTtcblx0fVxuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGlucHV0LmZpbGVzID0gZ2V0KCk7XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IHJlbmRlcl9lZmZlY3QsIGVmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGlzdGVuIH0gZnJvbSAnLi9zaGFyZWQuanMnO1xuXG4vKiogQHBhcmFtIHtUaW1lUmFuZ2VzfSByYW5nZXMgKi9cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuXHR2YXIgYXJyYXkgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdGFycmF5LnB1c2goeyBzdGFydDogcmFuZ2VzLnN0YXJ0KGkpLCBlbmQ6IHJhbmdlcy5lbmQoaSkgfSk7XG5cdH1cblxuXHRyZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KCkgPT4gbnVtYmVyIHwgdW5kZWZpbmVkfSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiBudW1iZXIpID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2N1cnJlbnRfdGltZShtZWRpYSwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0LyoqIEB0eXBlIHtudW1iZXJ9ICovXG5cdHZhciByYWZfaWQ7XG5cdC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXHR2YXIgdmFsdWU7XG5cblx0Ly8gSWRlYWxseSwgbGlzdGVuaW5nIHRvIHRpbWV1cGRhdGUgd291bGQgYmUgZW5vdWdoLCBidXQgaXQgZmlyZXMgdG9vIGluZnJlcXVlbnRseSBmb3IgdGhlIGN1cnJlbnRUaW1lXG5cdC8vIGJpbmRpbmcsIHdoaWNoIGlzIHdoeSB3ZSB1c2UgYSByYWYgbG9vcCwgdG9vLiBXZSBhZGRpdGlvbmFsbHkgc3RpbGwgbGlzdGVuIHRvIHRpbWV1cGRhdGUgYmVjYXVzZVxuXHQvLyB0aGUgdXNlciBjb3VsZCBiZSBzY3J1YmJpbmcgdGhyb3VnaCB0aGUgdmlkZW8gdXNpbmcgdGhlIG5hdGl2ZSBjb250cm9scyB3aGVuIHRoZSBtZWRpYSBpcyBwYXVzZWQuXG5cdHZhciBjYWxsYmFjayA9ICgpID0+IHtcblx0XHRjYW5jZWxBbmltYXRpb25GcmFtZShyYWZfaWQpO1xuXG5cdFx0aWYgKCFtZWRpYS5wYXVzZWQpIHtcblx0XHRcdHJhZl9pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG5cdFx0fVxuXG5cdFx0dmFyIG5leHRfdmFsdWUgPSBtZWRpYS5jdXJyZW50VGltZTtcblx0XHRpZiAodmFsdWUgIT09IG5leHRfdmFsdWUpIHtcblx0XHRcdHNldCgodmFsdWUgPSBuZXh0X3ZhbHVlKSk7XG5cdFx0fVxuXHR9O1xuXG5cdHJhZl9pZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG5cdG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCBjYWxsYmFjayk7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIG5leHRfdmFsdWUgPSBOdW1iZXIoZ2V0KCkpO1xuXG5cdFx0aWYgKHZhbHVlICE9PSBuZXh0X3ZhbHVlICYmICFpc05hTigvKiogQHR5cGUge2FueX0gKi8gKG5leHRfdmFsdWUpKSkge1xuXHRcdFx0bWVkaWEuY3VycmVudFRpbWUgPSB2YWx1ZSA9IG5leHRfdmFsdWU7XG5cdFx0fVxuXHR9KTtcblxuXHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmX2lkKTtcblx0XHRtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgY2FsbGJhY2spO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoYXJyYXk6IEFycmF5PHsgc3RhcnQ6IG51bWJlcjsgZW5kOiBudW1iZXIgfT4pID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9idWZmZXJlZChtZWRpYSwgc2V0KSB7XG5cdC8qKiBAdHlwZSB7eyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlcjsgfVtdfSAqL1xuXHR2YXIgY3VycmVudDtcblxuXHQvLyBgYnVmZmVyZWRgIGNhbiB1cGRhdGUgd2l0aG91dCBlbWl0dGluZyBhbnkgZXZlbnQsIHNvIHdlIGNoZWNrIGl0IG9uIHZhcmlvdXMgZXZlbnRzLlxuXHQvLyBCeSBzcGVjcywgYGJ1ZmZlcmVkYCBhbHdheXMgcmV0dXJucyBhIG5ldyBvYmplY3QsIHNvIHdlIGhhdmUgdG8gY29tcGFyZSBkZWVwbHkuXG5cdGxpc3RlbihtZWRpYSwgWydsb2FkZWRtZXRhZGF0YScsICdwcm9ncmVzcycsICd0aW1ldXBkYXRlJywgJ3NlZWtpbmcnXSwgKCkgPT4ge1xuXHRcdHZhciByYW5nZXMgPSBtZWRpYS5idWZmZXJlZDtcblxuXHRcdGlmIChcblx0XHRcdCFjdXJyZW50IHx8XG5cdFx0XHRjdXJyZW50Lmxlbmd0aCAhPT0gcmFuZ2VzLmxlbmd0aCB8fFxuXHRcdFx0Y3VycmVudC5zb21lKChyYW5nZSwgaSkgPT4gcmFuZ2VzLnN0YXJ0KGkpICE9PSByYW5nZS5zdGFydCB8fCByYW5nZXMuZW5kKGkpICE9PSByYW5nZS5lbmQpXG5cdFx0KSB7XG5cdFx0XHRjdXJyZW50ID0gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKTtcblx0XHRcdHNldChjdXJyZW50KTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geyhhcnJheTogQXJyYXk8eyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlciB9PikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3NlZWthYmxlKG1lZGlhLCBzZXQpIHtcblx0bGlzdGVuKG1lZGlhLCBbJ2xvYWRlZG1ldGFkYXRhJ10sICgpID0+IHNldCh0aW1lX3Jhbmdlc190b19hcnJheShtZWRpYS5zZWVrYWJsZSkpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoYXJyYXk6IEFycmF5PHsgc3RhcnQ6IG51bWJlcjsgZW5kOiBudW1iZXIgfT4pID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9wbGF5ZWQobWVkaWEsIHNldCkge1xuXHRsaXN0ZW4obWVkaWEsIFsndGltZXVwZGF0ZSddLCAoKSA9PiBzZXQodGltZV9yYW5nZXNfdG9fYXJyYXkobWVkaWEucGxheWVkKSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geyhzZWVraW5nOiBib29sZWFuKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfc2Vla2luZyhtZWRpYSwgc2V0KSB7XG5cdGxpc3RlbihtZWRpYSwgWydzZWVraW5nJywgJ3NlZWtlZCddLCAoKSA9PiBzZXQobWVkaWEuc2Vla2luZykpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geyhzZWVraW5nOiBib29sZWFuKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfZW5kZWQobWVkaWEsIHNldCkge1xuXHRsaXN0ZW4obWVkaWEsIFsndGltZXVwZGF0ZScsICdlbmRlZCddLCAoKSA9PiBzZXQobWVkaWEuZW5kZWQpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsocmVhZHlfc3RhdGU6IG51bWJlcikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3JlYWR5X3N0YXRlKG1lZGlhLCBzZXQpIHtcblx0bGlzdGVuKFxuXHRcdG1lZGlhLFxuXHRcdFsnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZGVkZGF0YScsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdlbXB0aWVkJ10sXG5cdFx0KCkgPT4gc2V0KG1lZGlhLnJlYWR5U3RhdGUpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KCkgPT4gbnVtYmVyIHwgdW5kZWZpbmVkfSBnZXRcbiAqIEBwYXJhbSB7KHBsYXliYWNrX3JhdGU6IG51bWJlcikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3BsYXliYWNrX3JhdGUobWVkaWEsIGdldCwgc2V0ID0gZ2V0KSB7XG5cdC8vIE5lZWRzIHRvIGhhcHBlbiBhZnRlciBlbGVtZW50IGlzIGluc2VydGVkIGludG8gdGhlIGRvbSAod2hpY2ggaXMgZ3VhcmFudGVlZCBieSB1c2luZyBlZmZlY3QpLFxuXHQvLyBlbHNlIHBsYXliYWNrIHdpbGwgYmUgc2V0IGJhY2sgdG8gMSBieSB0aGUgYnJvd3NlclxuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IE51bWJlcihnZXQoKSk7XG5cblx0XHRpZiAodmFsdWUgIT09IG1lZGlhLnBsYXliYWNrUmF0ZSAmJiAhaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRtZWRpYS5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFN0YXJ0IGxpc3RlbmluZyB0byByYXRlY2hhbmdlIGV2ZW50cyBhZnRlciB0aGUgZWxlbWVudCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBkb20sXG5cdC8vIGVsc2UgcGxheWJhY2sgd2lsbCBiZSBzZXQgdG8gMSBieSB0aGUgYnJvd3NlclxuXHRlZmZlY3QoKCkgPT4ge1xuXHRcdGxpc3RlbihtZWRpYSwgWydyYXRlY2hhbmdlJ10sICgpID0+IHtcblx0XHRcdHNldChtZWRpYS5wbGF5YmFja1JhdGUpO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxWaWRlb0VsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50fSBtZWRpYVxuICogQHBhcmFtIHsoKSA9PiBib29sZWFuIHwgdW5kZWZpbmVkfSBnZXRcbiAqIEBwYXJhbSB7KHBhdXNlZDogYm9vbGVhbikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3BhdXNlZChtZWRpYSwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIHBhdXNlZCA9IGdldCgpO1xuXG5cdHZhciB1cGRhdGUgPSAoKSA9PiB7XG5cdFx0aWYgKHBhdXNlZCAhPT0gbWVkaWEucGF1c2VkKSB7XG5cdFx0XHRzZXQoKHBhdXNlZCA9IG1lZGlhLnBhdXNlZCkpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBJZiBzb21lb25lIHN3aXRjaGVzIHRoZSBzcmMgd2hpbGUgbWVkaWEgaXMgcGxheWluZywgdGhlIHBsYXllciB3aWxsIHBhdXNlLlxuXHQvLyBMaXN0ZW4gdG8gdGhlIGNhbnBsYXkgZXZlbnQgdG8gZ2V0IG5vdGlmaWVkIG9mIHRoaXMgc2l0dWF0aW9uLlxuXHRsaXN0ZW4obWVkaWEsIFsncGxheScsICdwYXVzZScsICdjYW5wbGF5J10sIHVwZGF0ZSwgcGF1c2VkID09IG51bGwpO1xuXG5cdC8vIE5lZWRzIHRvIGJlIGFuIGVmZmVjdCB0byBlbnN1cmUgbWVkaWEgZWxlbWVudCBpcyBtb3VudGVkOiBlbHNlLCBpZiBwYXVzZWQgaXMgYGZhbHNlYCAoaS5lLiBzaG91bGQgcGxheSByaWdodCBhd2F5KVxuXHQvLyBhIFwiVGhlIHBsYXkoKSByZXF1ZXN0IHdhcyBpbnRlcnJ1cHRlZCBieSBhIG5ldyBsb2FkIHJlcXVlc3RcIiBlcnJvciB3b3VsZCBiZSB0aHJvd24gYmVjYXVzZSB0aGUgcmVzb3VyY2UgaXNuJ3QgbG9hZGVkIHlldC5cblx0ZWZmZWN0KCgpID0+IHtcblx0XHRpZiAoKHBhdXNlZCA9ICEhZ2V0KCkpICE9PSBtZWRpYS5wYXVzZWQpIHtcblx0XHRcdGlmIChwYXVzZWQpIHtcblx0XHRcdFx0bWVkaWEucGF1c2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1lZGlhLnBsYXkoKS5jYXRjaCgoKSA9PiB7XG5cdFx0XHRcdFx0c2V0KChwYXVzZWQgPSB0cnVlKSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVmlkZW9FbGVtZW50IHwgSFRNTEF1ZGlvRWxlbWVudH0gbWVkaWFcbiAqIEBwYXJhbSB7KCkgPT4gbnVtYmVyIHwgdW5kZWZpbmVkfSBnZXRcbiAqIEBwYXJhbSB7KHZvbHVtZTogbnVtYmVyKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfdm9sdW1lKG1lZGlhLCBnZXQsIHNldCA9IGdldCkge1xuXHR2YXIgY2FsbGJhY2sgPSAoKSA9PiB7XG5cdFx0c2V0KG1lZGlhLnZvbHVtZSk7XG5cdH07XG5cblx0aWYgKGdldCgpID09IG51bGwpIHtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG5cblx0bGlzdGVuKG1lZGlhLCBbJ3ZvbHVtZWNoYW5nZSddLCBjYWxsYmFjaywgZmFsc2UpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9IE51bWJlcihnZXQoKSk7XG5cblx0XHRpZiAodmFsdWUgIT09IG1lZGlhLnZvbHVtZSAmJiAhaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRtZWRpYS52b2x1bWUgPSB2YWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFZpZGVvRWxlbWVudCB8IEhUTUxBdWRpb0VsZW1lbnR9IG1lZGlhXG4gKiBAcGFyYW0geygpID0+IGJvb2xlYW4gfCB1bmRlZmluZWR9IGdldFxuICogQHBhcmFtIHsobXV0ZWQ6IGJvb2xlYW4pID0+IHZvaWR9IHNldFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9tdXRlZChtZWRpYSwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGNhbGxiYWNrID0gKCkgPT4ge1xuXHRcdHNldChtZWRpYS5tdXRlZCk7XG5cdH07XG5cblx0aWYgKGdldCgpID09IG51bGwpIHtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG5cblx0bGlzdGVuKG1lZGlhLCBbJ3ZvbHVtZWNoYW5nZSddLCBjYWxsYmFjaywgZmFsc2UpO1xuXG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdHZhciB2YWx1ZSA9ICEhZ2V0KCk7XG5cblx0XHRpZiAobWVkaWEubXV0ZWQgIT09IHZhbHVlKSBtZWRpYS5tdXRlZCA9IHZhbHVlO1xuXHR9KTtcbn1cbiIsICJpbXBvcnQgeyBsaXN0ZW4gfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsob25saW5lOiBib29sZWFuKSA9PiB2b2lkfSB1cGRhdGVcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9vbmxpbmUodXBkYXRlKSB7XG5cdGxpc3Rlbih3aW5kb3csIFsnb25saW5lJywgJ29mZmxpbmUnXSwgKCkgPT4ge1xuXHRcdHVwZGF0ZShuYXZpZ2F0b3Iub25MaW5lKTtcblx0fSk7XG59XG4iLCAiaW1wb3J0IHsgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZ2V0X2Rlc2NyaXB0b3IgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIE1ha2VzIGFuIGBleHBvcnRgZWQgKG5vbi1wcm9wKSB2YXJpYWJsZSBhdmFpbGFibGUgb24gdGhlIGAkJHByb3BzYCBvYmplY3RcbiAqIHNvIHRoYXQgY29uc3VtZXJzIGNhbiBkbyBgYmluZDp4YCBvbiB0aGUgY29tcG9uZW50LlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3Byb3AocHJvcHMsIHByb3AsIHZhbHVlKSB7XG5cdHZhciBkZXNjID0gZ2V0X2Rlc2NyaXB0b3IocHJvcHMsIHByb3ApO1xuXG5cdGlmIChkZXNjICYmIGRlc2Muc2V0KSB7XG5cdFx0cHJvcHNbcHJvcF0gPSB2YWx1ZTtcblx0XHR0ZWFyZG93bigoKSA9PiB7XG5cdFx0XHRwcm9wc1twcm9wXSA9IG51bGw7XG5cdFx0fSk7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBlZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBSZXNpemUgb2JzZXJ2ZXIgc2luZ2xldG9uLlxuICogT25lIGxpc3RlbmVyIHBlciBlbGVtZW50IG9ubHkhXG4gKiBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2cvYmxpbmstZGV2L2MvejZpZW5PTlViNUEvbS9GNS1WY1VadEJBQUpcbiAqL1xuY2xhc3MgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24ge1xuXHQvKiogKi9cblx0I2xpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0LyoqIEB0eXBlIHtSZXNpemVPYnNlcnZlciB8IHVuZGVmaW5lZH0gKi9cblx0I29ic2VydmVyO1xuXG5cdC8qKiBAdHlwZSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSAqL1xuXHQjb3B0aW9ucztcblxuXHQvKiogQHN0YXRpYyAqL1xuXHRzdGF0aWMgZW50cmllcyA9IG5ldyBXZWFrTWFwKCk7XG5cblx0LyoqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJPcHRpb25zfSBvcHRpb25zICovXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHR0aGlzLiNvcHRpb25zID0gb3B0aW9ucztcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHsoZW50cnk6IFJlc2l6ZU9ic2VydmVyRW50cnkpID0+IGFueX0gbGlzdGVuZXJcblx0ICovXG5cdG9ic2VydmUoZWxlbWVudCwgbGlzdGVuZXIpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy4jbGlzdGVuZXJzLmdldChlbGVtZW50KSB8fCBuZXcgU2V0KCk7XG5cdFx0bGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG5cblx0XHR0aGlzLiNsaXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVycyk7XG5cdFx0dGhpcy4jZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMuI29wdGlvbnMpO1xuXG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpO1xuXHRcdFx0bGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG5cblx0XHRcdGlmIChsaXN0ZW5lcnMuc2l6ZSA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuXHRcdFx0XHQvKiogQHR5cGUge1Jlc2l6ZU9ic2VydmVyfSAqLyAodGhpcy4jb2JzZXJ2ZXIpLnVub2JzZXJ2ZShlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0I2dldE9ic2VydmVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLiNvYnNlcnZlciA/P1xuXHRcdFx0KHRoaXMuI29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKFxuXHRcdFx0XHQvKiogQHBhcmFtIHthbnl9IGVudHJpZXMgKi8gKGVudHJpZXMpID0+IHtcblx0XHRcdFx0XHRmb3IgKHZhciBlbnRyeSBvZiBlbnRyaWVzKSB7XG5cdFx0XHRcdFx0XHRSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGxpc3RlbmVyIG9mIHRoaXMuI2xpc3RlbmVycy5nZXQoZW50cnkudGFyZ2V0KSB8fCBbXSkge1xuXHRcdFx0XHRcdFx0XHRsaXN0ZW5lcihlbnRyeSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpKVxuXHRcdCk7XG5cdH1cbn1cblxudmFyIHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdjb250ZW50LWJveCdcbn0pO1xuXG52YXIgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uKHtcblx0Ym94OiAnYm9yZGVyLWJveCdcbn0pO1xuXG52YXIgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oe1xuXHRib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnXG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7J2NvbnRlbnRSZWN0JyB8ICdjb250ZW50Qm94U2l6ZScgfCAnYm9yZGVyQm94U2l6ZScgfCAnZGV2aWNlUGl4ZWxDb250ZW50Qm94U2l6ZSd9IHR5cGVcbiAqIEBwYXJhbSB7KGVudHJ5OiBrZXlvZiBSZXNpemVPYnNlcnZlckVudHJ5KSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfcmVzaXplX29ic2VydmVyKGVsZW1lbnQsIHR5cGUsIHNldCkge1xuXHR2YXIgb2JzZXJ2ZXIgPVxuXHRcdHR5cGUgPT09ICdjb250ZW50UmVjdCcgfHwgdHlwZSA9PT0gJ2NvbnRlbnRCb3hTaXplJ1xuXHRcdFx0PyByZXNpemVfb2JzZXJ2ZXJfY29udGVudF9ib3hcblx0XHRcdDogdHlwZSA9PT0gJ2JvcmRlckJveFNpemUnXG5cdFx0XHRcdD8gcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3hcblx0XHRcdFx0OiByZXNpemVfb2JzZXJ2ZXJfZGV2aWNlX3BpeGVsX2NvbnRlbnRfYm94O1xuXG5cdHZhciB1bnN1YiA9IG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgLyoqIEBwYXJhbSB7YW55fSBlbnRyeSAqLyAoZW50cnkpID0+IHNldChlbnRyeVt0eXBlXSkpO1xuXHR0ZWFyZG93bih1bnN1Yik7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsnY2xpZW50V2lkdGgnIHwgJ2NsaWVudEhlaWdodCcgfCAnb2Zmc2V0V2lkdGgnIHwgJ29mZnNldEhlaWdodCd9IHR5cGVcbiAqIEBwYXJhbSB7KHNpemU6IG51bWJlcikgPT4gdm9pZH0gc2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX2VsZW1lbnRfc2l6ZShlbGVtZW50LCB0eXBlLCBzZXQpIHtcblx0dmFyIHVuc3ViID0gcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3gub2JzZXJ2ZShlbGVtZW50LCAoKSA9PiBzZXQoZWxlbWVudFt0eXBlXSkpO1xuXG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0Ly8gVGhlIHVwZGF0ZSBjb3VsZCBjb250YWluIHJlYWRzIHdoaWNoIHNob3VsZCBiZSBpZ25vcmVkXG5cdFx0dW50cmFjaygoKSA9PiBzZXQoZWxlbWVudFt0eXBlXSkpO1xuXHRcdHJldHVybiB1bnN1Yjtcblx0fSk7XG59XG4iLCAiaW1wb3J0IHsgU1RBVEVfU1lNQk9MIH0gZnJvbSAnI2NsaWVudC9jb25zdGFudHMnO1xuaW1wb3J0IHsgZWZmZWN0LCByZW5kZXJfZWZmZWN0IH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IHVudHJhY2sgfSBmcm9tICcuLi8uLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IHF1ZXVlX21pY3JvX3Rhc2sgfSBmcm9tICcuLi8uLi90YXNrLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYm91bmRfdmFsdWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudF9vcl9jb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc19ib3VuZF90aGlzKGJvdW5kX3ZhbHVlLCBlbGVtZW50X29yX2NvbXBvbmVudCkge1xuXHRyZXR1cm4gKFxuXHRcdGJvdW5kX3ZhbHVlID09PSBlbGVtZW50X29yX2NvbXBvbmVudCB8fCBib3VuZF92YWx1ZT8uW1NUQVRFX1NZTUJPTF0gPT09IGVsZW1lbnRfb3JfY29tcG9uZW50XG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGVsZW1lbnRfb3JfY29tcG9uZW50XG4gKiBAcGFyYW0geyh2YWx1ZTogdW5rbm93biwgLi4ucGFydHM6IHVua25vd25bXSkgPT4gdm9pZH0gdXBkYXRlXG4gKiBAcGFyYW0geyguLi5wYXJ0czogdW5rbm93bltdKSA9PiB1bmtub3dufSBnZXRfdmFsdWVcbiAqIEBwYXJhbSB7KCkgPT4gdW5rbm93bltdfSBbZ2V0X3BhcnRzXSBTZXQgaWYgdGhlIHRoaXMgYmluZGluZyBpcyB1c2VkIGluc2lkZSBhbiBlYWNoIGJsb2NrLFxuICogXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5zIGFsbCB0aGUgcGFydHMgb2YgdGhlIGVhY2ggYmxvY2sgY29udGV4dCB0aGF0IGFyZSB1c2VkIGluIHRoZSBleHByZXNzaW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfdGhpcyhlbGVtZW50X29yX2NvbXBvbmVudCA9IHt9LCB1cGRhdGUsIGdldF92YWx1ZSwgZ2V0X3BhcnRzKSB7XG5cdGVmZmVjdCgoKSA9PiB7XG5cdFx0LyoqIEB0eXBlIHt1bmtub3duW119ICovXG5cdFx0dmFyIG9sZF9wYXJ0cztcblxuXHRcdC8qKiBAdHlwZSB7dW5rbm93bltdfSAqL1xuXHRcdHZhciBwYXJ0cztcblxuXHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0b2xkX3BhcnRzID0gcGFydHM7XG5cdFx0XHQvLyBXZSBvbmx5IHRyYWNrIGNoYW5nZXMgdG8gdGhlIHBhcnRzLCBub3QgdGhlIHZhbHVlIGl0c2VsZiB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZXJ1bnMuXG5cdFx0XHRwYXJ0cyA9IGdldF9wYXJ0cz8uKCkgfHwgW107XG5cblx0XHRcdHVudHJhY2soKCkgPT4ge1xuXHRcdFx0XHRpZiAoZWxlbWVudF9vcl9jb21wb25lbnQgIT09IGdldF92YWx1ZSguLi5wYXJ0cykpIHtcblx0XHRcdFx0XHR1cGRhdGUoZWxlbWVudF9vcl9jb21wb25lbnQsIC4uLnBhcnRzKTtcblx0XHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGVmZmVjdCByZXJ1biAoY2F1c2U6IGVhY2ggYmxvY2sgY29udGV4dCBjaGFuZ2VzKSwgdGhlbiBudWxsZml5IHRoZSBiaW5kaW5nIGF0XG5cdFx0XHRcdFx0Ly8gdGhlIHByZXZpb3VzIHBvc2l0aW9uIGlmIGl0IGlzbid0IGFscmVhZHkgdGFrZW4gb3ZlciBieSBhIGRpZmZlcmVudCBlZmZlY3QuXG5cdFx0XHRcdFx0aWYgKG9sZF9wYXJ0cyAmJiBpc19ib3VuZF90aGlzKGdldF92YWx1ZSguLi5vbGRfcGFydHMpLCBlbGVtZW50X29yX2NvbXBvbmVudCkpIHtcblx0XHRcdFx0XHRcdHVwZGF0ZShudWxsLCAuLi5vbGRfcGFydHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKCkgPT4ge1xuXHRcdFx0Ly8gV2UgY2Fubm90IHVzZSBlZmZlY3RzIGluIHRoZSB0ZWFyZG93biBwaGFzZSwgd2Ugd2UgdXNlIGEgbWljcm90YXNrIGluc3RlYWQuXG5cdFx0XHRxdWV1ZV9taWNyb190YXNrKCgpID0+IHtcblx0XHRcdFx0aWYgKHBhcnRzICYmIGlzX2JvdW5kX3RoaXMoZ2V0X3ZhbHVlKC4uLnBhcnRzKSwgZWxlbWVudF9vcl9jb21wb25lbnQpKSB7XG5cdFx0XHRcdFx0dXBkYXRlKG51bGwsIC4uLnBhcnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG5cblx0cmV0dXJuIGVsZW1lbnRfb3JfY29tcG9uZW50O1xufVxuIiwgImltcG9ydCB7IHJlbmRlcl9lZmZlY3QsIHRlYXJkb3duIH0gZnJvbSAnLi4vLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IGxpc3RlbiB9IGZyb20gJy4vc2hhcmVkLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geydpbm5lckhUTUwnIHwgJ3RleHRDb250ZW50JyB8ICdpbm5lclRleHQnfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9jb250ZW50X2VkaXRhYmxlKHByb3BlcnR5LCBlbGVtZW50LCBnZXQsIHNldCA9IGdldCkge1xuXHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRzZXQoZWxlbWVudFtwcm9wZXJ0eV0pO1xuXHR9KTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHR2YXIgdmFsdWUgPSBnZXQoKTtcblxuXHRcdGlmIChlbGVtZW50W3Byb3BlcnR5XSAhPT0gdmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0dmFyIG5vbl9udWxsX3ZhbHVlID0gZWxlbWVudFtwcm9wZXJ0eV07XG5cdFx0XHRcdHNldChub25fbnVsbF92YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdGVsZW1lbnRbcHJvcGVydHldID0gdmFsdWUgKyAnJztcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHZvaWR9IHNldFxuICogQHBhcmFtIHsoKSA9PiB1bmtub3dufSBbZ2V0XVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3Byb3BlcnR5KHByb3BlcnR5LCBldmVudF9uYW1lLCBlbGVtZW50LCBzZXQsIGdldCkge1xuXHR2YXIgaGFuZGxlciA9ICgpID0+IHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c2V0KGVsZW1lbnRbcHJvcGVydHldKTtcblx0fTtcblxuXHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRfbmFtZSwgaGFuZGxlcik7XG5cblx0aWYgKGdldCkge1xuXHRcdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0ZWxlbWVudFtwcm9wZXJ0eV0gPSBnZXQoKTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRoYW5kbGVyKCk7XG5cdH1cblxuXHQvLyBAdHMtaWdub3JlXG5cdGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5IHx8IGVsZW1lbnQgPT09IHdpbmRvdyB8fCBlbGVtZW50ID09PSBkb2N1bWVudCkge1xuXHRcdHRlYXJkb3duKCgpID0+IHtcblx0XHRcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudF9uYW1lLCBoYW5kbGVyKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7KHZhbHVlOiB1bmtub3duKSA9PiB2b2lkfSBzZXRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZF9mb2N1c2VkKGVsZW1lbnQsIHNldCkge1xuXHRsaXN0ZW4oZWxlbWVudCwgWydmb2N1cycsICdibHVyJ10sICgpID0+IHtcblx0XHRzZXQoZWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cdH0pO1xufVxuIiwgImltcG9ydCB7IGVmZmVjdCwgcmVuZGVyX2VmZmVjdCwgdGVhcmRvd24gfSBmcm9tICcuLi8uLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgbGlzdGVuLCB3aXRob3V0X3JlYWN0aXZlX2NvbnRleHQgfSBmcm9tICcuL3NoYXJlZC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHsneCcgfCAneSd9IHR5cGVcbiAqIEBwYXJhbSB7KCkgPT4gbnVtYmVyfSBnZXRcbiAqIEBwYXJhbSB7KHZhbHVlOiBudW1iZXIpID0+IHZvaWR9IHNldFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kX3dpbmRvd19zY3JvbGwodHlwZSwgZ2V0LCBzZXQgPSBnZXQpIHtcblx0dmFyIGlzX3Njcm9sbGluZ194ID0gdHlwZSA9PT0gJ3gnO1xuXG5cdHZhciB0YXJnZXRfaGFuZGxlciA9ICgpID0+XG5cdFx0d2l0aG91dF9yZWFjdGl2ZV9jb250ZXh0KCgpID0+IHtcblx0XHRcdHNjcm9sbGluZyA9IHRydWU7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhciwgMTAwKTsgLy8gVE9ETyB1c2Ugc2Nyb2xsZW5kIGV2ZW50IGlmIHN1cHBvcnRlZCAob3Igd2hlbiBzdXBwb3J0ZWQgZXZlcnl3aGVyZT8pXG5cblx0XHRcdHNldCh3aW5kb3dbaXNfc2Nyb2xsaW5nX3ggPyAnc2Nyb2xsWCcgOiAnc2Nyb2xsWSddKTtcblx0XHR9KTtcblxuXHRhZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0YXJnZXRfaGFuZGxlciwge1xuXHRcdHBhc3NpdmU6IHRydWVcblx0fSk7XG5cblx0dmFyIHNjcm9sbGluZyA9IGZhbHNlO1xuXG5cdC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD59ICovXG5cdHZhciB0aW1lb3V0O1xuXHR2YXIgY2xlYXIgPSAoKSA9PiB7XG5cdFx0c2Nyb2xsaW5nID0gZmFsc2U7XG5cdH07XG5cdHZhciBmaXJzdCA9IHRydWU7XG5cblx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0dmFyIGxhdGVzdF92YWx1ZSA9IGdldCgpO1xuXHRcdC8vIERvbid0IHNjcm9sbCB0byB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgYWNjZXNzaWJpbGl0eSByZWFzb25zXG5cdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoIXNjcm9sbGluZyAmJiBsYXRlc3RfdmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0c2Nyb2xsaW5nID0gdHJ1ZTtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRcdGlmIChpc19zY3JvbGxpbmdfeCkge1xuXHRcdFx0XHRzY3JvbGxUbyhsYXRlc3RfdmFsdWUsIHdpbmRvdy5zY3JvbGxZKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNjcm9sbFRvKHdpbmRvdy5zY3JvbGxYLCBsYXRlc3RfdmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQoY2xlYXIsIDEwMCk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBCcm93c2VycyBkb24ndCBmaXJlIHRoZSBzY3JvbGwgZXZlbnQgZm9yIHRoZSBpbml0aWFsIHNjcm9sbCBwb3NpdGlvbiB3aGVuIHNjcm9sbCBzdHlsZSBpc24ndCBzZXQgdG8gc21vb3RoXG5cdGVmZmVjdCh0YXJnZXRfaGFuZGxlcik7XG5cblx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRhcmdldF9oYW5kbGVyKTtcblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsnaW5uZXJXaWR0aCcgfCAnaW5uZXJIZWlnaHQnIHwgJ291dGVyV2lkdGgnIHwgJ291dGVySGVpZ2h0J30gdHlwZVxuICogQHBhcmFtIHsoc2l6ZTogbnVtYmVyKSA9PiB2b2lkfSBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRfd2luZG93X3NpemUodHlwZSwgc2V0KSB7XG5cdGxpc3Rlbih3aW5kb3csIFsncmVzaXplJ10sICgpID0+IHdpdGhvdXRfcmVhY3RpdmVfY29udGV4dCgoKSA9PiBzZXQod2luZG93W3R5cGVdKSkpO1xufVxuIiwgImltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgdXNlcl9wcmVfZWZmZWN0IH0gZnJvbSAnLi4vLi4vcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG9uIH0gZnJvbSAnLi4vZWxlbWVudHMvZXZlbnRzLmpzJztcblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHRydXN0ZWRgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRpZiAoZXZlbnQuaXNUcnVzdGVkKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc2VsZmAgZXZlbnQgbW9kaWZpZXJcbiAqIEBkZXByZWNhdGVkXG4gKiBAcGFyYW0geyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IEFycmF5PHVua25vd24+KSA9PiB2b2lkfSBmblxuICogQHJldHVybnMgeyhldmVudDogRXZlbnQsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGYoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc3RvcFByb3BhZ2F0aW9uYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYG9uY2VgIGV2ZW50IG1vZGlmaWVyXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4gdm9pZH0gZm5cbiAqIEByZXR1cm5zIHsoZXZlbnQ6IEV2ZW50LCAuLi5hcmdzOiB1bmtub3duW10pID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmNlKGZuKSB7XG5cdHZhciByYW4gPSBmYWxzZTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRpZiAocmFuKSByZXR1cm47XG5cdFx0cmFuID0gdHJ1ZTtcblxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gZm4/LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9O1xufVxuXG4vKipcbiAqIFN1YnN0aXR1dGUgZm9yIHRoZSBgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uYCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRcdHZhciBldmVudCA9IC8qKiBAdHlwZSB7RXZlbnR9ICovIChhcmdzWzBdKTtcblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIGZuPy5hcHBseSh0aGlzLCBhcmdzKTtcblx0fTtcbn1cblxuLyoqXG4gKiBTdWJzdGl0dXRlIGZvciB0aGUgYHByZXZlbnREZWZhdWx0YCBldmVudCBtb2RpZmllclxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogQXJyYXk8dW5rbm93bj4pID0+IHZvaWR9IGZuXG4gKiBAcmV0dXJucyB7KGV2ZW50OiBFdmVudCwgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0dmFyIGV2ZW50ID0gLyoqIEB0eXBlIHtFdmVudH0gKi8gKGFyZ3NbMF0pO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBmbj8uYXBwbHkodGhpcywgYXJncyk7XG5cdH07XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBwYXNzaXZlYCBldmVudCBtb2RpZmllciwgaW1wbGVtZW50ZWQgYXMgYW4gYWN0aW9uXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtbZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKCkgPT4gRXZlbnRMaXN0ZW5lcl19IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhc3NpdmUobm9kZSwgW2V2ZW50LCBoYW5kbGVyXSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdHJldHVybiBvbihub2RlLCBldmVudCwgaGFuZGxlcigpID8/IG5vb3AsIHtcblx0XHRcdHBhc3NpdmU6IHRydWVcblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogU3Vic3RpdHV0ZSBmb3IgdGhlIGBub25wYXNzaXZlYCBldmVudCBtb2RpZmllciwgaW1wbGVtZW50ZWQgYXMgYW4gYWN0aW9uXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtbZXZlbnQ6IHN0cmluZywgaGFuZGxlcjogKCkgPT4gRXZlbnRMaXN0ZW5lcl19IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vbnBhc3NpdmUobm9kZSwgW2V2ZW50LCBoYW5kbGVyXSkge1xuXHR1c2VyX3ByZV9lZmZlY3QoKCkgPT4ge1xuXHRcdHJldHVybiBvbihub2RlLCBldmVudCwgaGFuZGxlcigpID8/IG5vb3AsIHtcblx0XHRcdHBhc3NpdmU6IGZhbHNlXG5cdFx0fSk7XG5cdH0pO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29udGV4dExlZ2FjeSB9IGZyb20gJyNjbGllbnQnICovXG5pbXBvcnQgeyBydW4sIHJ1bl9hbGwgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgY29tcG9uZW50X2NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0LmpzJztcbmltcG9ydCB7IGRlcml2ZWQgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7IHVzZXJfcHJlX2VmZmVjdCwgdXNlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgZGVlcF9yZWFkX3N0YXRlLCBnZXQsIHVudHJhY2sgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcblxuLyoqXG4gKiBMZWdhY3ktbW9kZSBvbmx5OiBDYWxsIGBvbk1vdW50YCBjYWxsYmFja3MgYW5kIHNldCB1cCBgYmVmb3JlVXBkYXRlYC9gYWZ0ZXJVcGRhdGVgIGVmZmVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ltbXV0YWJsZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXQoaW1tdXRhYmxlID0gZmFsc2UpIHtcblx0Y29uc3QgY29udGV4dCA9IC8qKiBAdHlwZSB7Q29tcG9uZW50Q29udGV4dExlZ2FjeX0gKi8gKGNvbXBvbmVudF9jb250ZXh0KTtcblxuXHRjb25zdCBjYWxsYmFja3MgPSBjb250ZXh0LmwudTtcblx0aWYgKCFjYWxsYmFja3MpIHJldHVybjtcblxuXHRsZXQgcHJvcHMgPSAoKSA9PiBkZWVwX3JlYWRfc3RhdGUoY29udGV4dC5zKTtcblxuXHRpZiAoaW1tdXRhYmxlKSB7XG5cdFx0bGV0IHZlcnNpb24gPSAwO1xuXHRcdGxldCBwcmV2ID0gLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqLyAoe30pO1xuXG5cdFx0Ly8gSW4gbGVnYWN5IGltbXV0YWJsZSBtb2RlLCBiZWZvcmUvYWZ0ZXJVcGRhdGUgb25seSBmaXJlIGlmIHRoZSBvYmplY3QgaWRlbnRpdHkgb2YgYSBwcm9wIGNoYW5nZXNcblx0XHRjb25zdCBkID0gZGVyaXZlZCgoKSA9PiB7XG5cdFx0XHRsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgcHJvcHMgPSBjb250ZXh0LnM7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuXHRcdFx0XHRpZiAocHJvcHNba2V5XSAhPT0gcHJldltrZXldKSB7XG5cdFx0XHRcdFx0cHJldltrZXldID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNoYW5nZWQpIHZlcnNpb24rKztcblx0XHRcdHJldHVybiB2ZXJzaW9uO1xuXHRcdH0pO1xuXG5cdFx0cHJvcHMgPSAoKSA9PiBnZXQoZCk7XG5cdH1cblxuXHQvLyBiZWZvcmVVcGRhdGVcblx0aWYgKGNhbGxiYWNrcy5iLmxlbmd0aCkge1xuXHRcdHVzZXJfcHJlX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcyk7XG5cdFx0XHRydW5fYWxsKGNhbGxiYWNrcy5iKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIG9uTW91bnQgKG11c3QgcnVuIGJlZm9yZSBhZnRlclVwZGF0ZSlcblx0dXNlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGNvbnN0IGZucyA9IHVudHJhY2soKCkgPT4gY2FsbGJhY2tzLm0ubWFwKHJ1bikpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuXHRcdFx0XHRpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Zm4oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xuXG5cdC8vIGFmdGVyVXBkYXRlXG5cdGlmIChjYWxsYmFja3MuYS5sZW5ndGgpIHtcblx0XHR1c2VyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRvYnNlcnZlX2FsbChjb250ZXh0LCBwcm9wcyk7XG5cdFx0XHRydW5fYWxsKGNhbGxiYWNrcy5hKTtcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEludm9rZSB0aGUgZ2V0dGVyIG9mIGFsbCBzaWduYWxzIGFzc29jaWF0ZWQgd2l0aCBhIGNvbXBvbmVudFxuICogc28gdGhleSBjYW4gYmUgcmVnaXN0ZXJlZCB0byB0aGUgZWZmZWN0IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGluLlxuICogQHBhcmFtIHtDb21wb25lbnRDb250ZXh0TGVnYWN5fSBjb250ZXh0XG4gKiBAcGFyYW0geygoKSA9PiB2b2lkKX0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZV9hbGwoY29udGV4dCwgcHJvcHMpIHtcblx0aWYgKGNvbnRleHQubC5zKSB7XG5cdFx0Zm9yIChjb25zdCBzaWduYWwgb2YgY29udGV4dC5sLnMpIGdldChzaWduYWwpO1xuXHR9XG5cblx0cHJvcHMoKTtcbn1cbiIsICJpbXBvcnQgeyBzZXQsIHNvdXJjZSB9IGZyb20gJy4uLy4uL3JlYWN0aXZpdHkvc291cmNlcy5qcyc7XG5pbXBvcnQgeyBnZXQgfSBmcm9tICcuLi8uLi9ydW50aW1lLmpzJztcbmltcG9ydCB7IGlzX2FycmF5IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL3V0aWxzLmpzJztcblxuLyoqXG4gKiBVbmRlciBzb21lIGNpcmN1bXN0YW5jZXMsIGltcG9ydHMgbWF5IGJlIHJlYWN0aXZlIGluIGxlZ2FjeSBtb2RlLiBJbiB0aGF0IGNhc2UsXG4gKiB0aGV5IHNob3VsZCBiZSB1c2luZyBgcmVhY3RpdmVfaW1wb3J0YCBhcyBwYXJ0IG9mIHRoZSB0cmFuc2Zvcm1hdGlvblxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFjdGl2ZV9pbXBvcnQoZm4pIHtcblx0dmFyIHMgPSBzb3VyY2UoMCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0c2V0KHMsIGdldChzKSArIDEpO1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50c1swXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0KHMpO1xuXHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIEB0aGlzIHthbnl9XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSAkJHByb3BzXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWJibGVfZXZlbnQoJCRwcm9wcywgZXZlbnQpIHtcblx0dmFyIGV2ZW50cyA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb25bXSB8IEZ1bmN0aW9uPn0gKi8gKCQkcHJvcHMuJCRldmVudHMpPy5bXG5cdFx0ZXZlbnQudHlwZVxuXHRdO1xuXG5cdHZhciBjYWxsYmFja3MgPSBpc19hcnJheShldmVudHMpID8gZXZlbnRzLnNsaWNlKCkgOiBldmVudHMgPT0gbnVsbCA/IFtdIDogW2V2ZW50c107XG5cblx0Zm9yICh2YXIgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0Ly8gUHJlc2VydmUgXCJ0aGlzXCIgY29udGV4dFxuXHRcdGZuLmNhbGwodGhpcywgZXZlbnQpO1xuXHR9XG59XG5cbi8qKlxuICogVXNlZCB0byBzaW11bGF0ZSBgJG9uYCBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZSB3aGVuIGBjb21wYXRpYmlsaXR5LmNvbXBvbmVudEFwaSA9PT0gNGBcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gJCRwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50X2NhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRfbGVnYWN5X2V2ZW50X2xpc3RlbmVyKCQkcHJvcHMsIGV2ZW50X25hbWUsIGV2ZW50X2NhbGxiYWNrKSB7XG5cdCQkcHJvcHMuJCRldmVudHMgfHw9IHt9O1xuXHQkJHByb3BzLiQkZXZlbnRzW2V2ZW50X25hbWVdIHx8PSBbXTtcblx0JCRwcm9wcy4kJGV2ZW50c1tldmVudF9uYW1lXS5wdXNoKGV2ZW50X2NhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNpbXVsYXRlIGAkc2V0YCBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZSB3aGVuIGBjb21wYXRpYmlsaXR5LmNvbXBvbmVudEFwaSA9PT0gNGAuXG4gKiBOZWVkcyBjb21wb25lbnQgYWNjZXNzb3JzIHNvIHRoYXQgaXQgY2FuIGNhbGwgdGhlIHNldHRlciBvZiB0aGUgcHJvcC4gVGhlcmVmb3JlIGRvZXNuJ3RcbiAqIHdvcmsgZm9yIHVwZGF0aW5nIHByb3BzIGluIGAkJHByb3BzYCBvciBgJCRyZXN0UHJvcHNgLlxuICogQHRoaXMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59ICQkbmV3X3Byb3BzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfbGVnYWN5X3Byb3BzKCQkbmV3X3Byb3BzKSB7XG5cdGZvciAodmFyIGtleSBpbiAkJG5ld19wcm9wcykge1xuXHRcdGlmIChrZXkgaW4gdGhpcykge1xuXHRcdFx0dGhpc1trZXldID0gJCRuZXdfcHJvcHNba2V5XTtcblx0XHR9XG5cdH1cbn1cbiIsICIvKiogQGltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnLi9wdWJsaWMnICovXG5pbXBvcnQgeyB1bnRyYWNrIH0gZnJvbSAnLi4vaW5kZXgtY2xpZW50LmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi9pbnRlcm5hbC9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1JlYWRhYmxlPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBydW5cbiAqIEBwYXJhbSB7KHZhbHVlOiBUKSA9PiB2b2lkfSBbaW52YWxpZGF0ZV1cbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCBydW4sIGludmFsaWRhdGUpIHtcblx0aWYgKHN0b3JlID09IG51bGwpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0cnVuKHVuZGVmaW5lZCk7XG5cblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0aWYgKGludmFsaWRhdGUpIGludmFsaWRhdGUodW5kZWZpbmVkKTtcblxuXHRcdHJldHVybiBub29wO1xuXHR9XG5cblx0Ly8gU3ZlbHRlIHN0b3JlIHRha2VzIGEgcHJpdmF0ZSBzZWNvbmQgYXJndW1lbnRcblx0Ly8gU3RhcnRTdG9wTm90aWZpZXIgY291bGQgbXV0YXRlIHN0YXRlLCBhbmQgd2Ugd2FudCB0byBzaWxlbmNlIHRoZSBjb3JyZXNwb25kaW5nIHZhbGlkYXRpb24gZXJyb3Jcblx0Y29uc3QgdW5zdWIgPSB1bnRyYWNrKCgpID0+XG5cdFx0c3RvcmUuc3Vic2NyaWJlKFxuXHRcdFx0cnVuLFxuXHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0aW52YWxpZGF0ZVxuXHRcdClcblx0KTtcblxuXHQvLyBBbHNvIHN1cHBvcnQgUnhKU1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gZml4IHRoaXMgaW4gdGhlIHR5cGVzP1xuXHRyZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG4iLCAiLyoqIEBpbXBvcnQgeyBSZWFkYWJsZSwgU3RhcnRTdG9wTm90aWZpZXIsIFN1YnNjcmliZXIsIFVuc3Vic2NyaWJlciwgVXBkYXRlciwgV3JpdGFibGUgfSBmcm9tICcuLi9wdWJsaWMuanMnICovXG4vKiogQGltcG9ydCB7IFN0b3JlcywgU3RvcmVzVmFsdWVzLCBTdWJzY3JpYmVJbnZhbGlkYXRlVHVwbGUgfSBmcm9tICcuLi9wcml2YXRlLmpzJyAqL1xuaW1wb3J0IHsgbm9vcCwgcnVuX2FsbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgeyBzYWZlX25vdF9lcXVhbCB9IGZyb20gJy4uLy4uL2ludGVybmFsL2NsaWVudC9yZWFjdGl2aXR5L2VxdWFsaXR5LmpzJztcbmltcG9ydCB7IHN1YnNjcmliZV90b19zdG9yZSB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPGFueT4gfCBhbnk+fVxuICovXG5jb25zdCBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBSZWFkYWJsZWAgc3RvcmUgdGhhdCBhbGxvd3MgcmVhZGluZyBieSBzdWJzY3JpcHRpb24uXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gW3ZhbHVlXSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPFQ+fSBbc3RhcnRdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkYWJsZSh2YWx1ZSwgc3RhcnQpIHtcblx0cmV0dXJuIHtcblx0XHRzdWJzY3JpYmU6IHdyaXRhYmxlKHZhbHVlLCBzdGFydCkuc3Vic2NyaWJlXG5cdH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBbdmFsdWVdIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXI8VD59IFtzdGFydF1cbiAqIEByZXR1cm5zIHtXcml0YWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyaXRhYmxlKHZhbHVlLCBzdGFydCA9IG5vb3ApIHtcblx0LyoqIEB0eXBlIHtVbnN1YnNjcmliZXIgfCBudWxsfSAqL1xuXHRsZXQgc3RvcCA9IG51bGw7XG5cblx0LyoqIEB0eXBlIHtTZXQ8U3Vic2NyaWJlSW52YWxpZGF0ZVR1cGxlPFQ+Pn0gKi9cblx0Y29uc3Qgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7VH0gbmV3X3ZhbHVlXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0ZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuXHRcdGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuXHRcdFx0dmFsdWUgPSBuZXdfdmFsdWU7XG5cdFx0XHRpZiAoc3RvcCkge1xuXHRcdFx0XHQvLyBzdG9yZSBpcyByZWFkeVxuXHRcdFx0XHRjb25zdCBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG5cdFx0XHRcdGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBzdWJzY3JpYmVycykge1xuXHRcdFx0XHRcdHN1YnNjcmliZXJbMV0oKTtcblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLnB1c2goc3Vic2NyaWJlciwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChydW5fcXVldWUpIHtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJfcXVldWUubGVuZ3RoOyBpICs9IDIpIHtcblx0XHRcdFx0XHRcdHN1YnNjcmliZXJfcXVldWVbaV1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtpICsgMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtVcGRhdGVyPFQ+fSBmblxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuXHRcdHNldChmbigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1N1YnNjcmliZXI8VD59IHJ1blxuXHQgKiBAcGFyYW0geygpID0+IHZvaWR9IFtpbnZhbGlkYXRlXVxuXHQgKiBAcmV0dXJucyB7VW5zdWJzY3JpYmVyfVxuXHQgKi9cblx0ZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcblx0XHQvKiogQHR5cGUge1N1YnNjcmliZUludmFsaWRhdGVUdXBsZTxUPn0gKi9cblx0XHRjb25zdCBzdWJzY3JpYmVyID0gW3J1biwgaW52YWxpZGF0ZV07XG5cdFx0c3Vic2NyaWJlcnMuYWRkKHN1YnNjcmliZXIpO1xuXHRcdGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG5cdFx0XHRzdG9wID0gc3RhcnQoc2V0LCB1cGRhdGUpIHx8IG5vb3A7XG5cdFx0fVxuXHRcdHJ1bigvKiogQHR5cGUge1R9ICovICh2YWx1ZSkpO1xuXHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cdFx0XHRpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCAmJiBzdG9wKSB7XG5cdFx0XHRcdHN0b3AoKTtcblx0XHRcdFx0c3RvcCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5cbi8qKlxuICogRGVyaXZlZCB2YWx1ZSBzdG9yZSBieSBzeW5jaHJvbml6aW5nIG9uZSBvciBtb3JlIHJlYWRhYmxlIHN0b3JlcyBhbmRcbiAqIGFwcGx5aW5nIGFuIGFnZ3JlZ2F0aW9uIGZ1bmN0aW9uIG92ZXIgaXRzIGlucHV0IHZhbHVlcy5cbiAqXG4gKiBAdGVtcGxhdGUge1N0b3Jlc30gU1xuICogQHRlbXBsYXRlIFRcbiAqIEBvdmVybG9hZFxuICogQHBhcmFtIHtTfSBzdG9yZXNcbiAqIEBwYXJhbSB7KHZhbHVlczogU3RvcmVzVmFsdWVzPFM+LCBzZXQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgdXBkYXRlOiAoZm46IFVwZGF0ZXI8VD4pID0+IHZvaWQpID0+IFVuc3Vic2NyaWJlciB8IHZvaWR9IGZuXG4gKiBAcGFyYW0ge1R9IFtpbml0aWFsX3ZhbHVlXVxuICogQHJldHVybnMge1JlYWRhYmxlPFQ+fVxuICovXG4vKipcbiAqIERlcml2ZWQgdmFsdWUgc3RvcmUgYnkgc3luY2hyb25pemluZyBvbmUgb3IgbW9yZSByZWFkYWJsZSBzdG9yZXMgYW5kXG4gKiBhcHBseWluZyBhbiBhZ2dyZWdhdGlvbiBmdW5jdGlvbiBvdmVyIGl0cyBpbnB1dCB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAb3ZlcmxvYWRcbiAqIEBwYXJhbSB7U30gc3RvcmVzXG4gKiBAcGFyYW0geyh2YWx1ZXM6IFN0b3Jlc1ZhbHVlczxTPikgPT4gVH0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbi8qKlxuICogQHRlbXBsYXRlIHtTdG9yZXN9IFNcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1N9IHN0b3Jlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7VH0gW2luaXRpYWxfdmFsdWVdXG4gKiBAcmV0dXJucyB7UmVhZGFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcblx0Y29uc3Qgc2luZ2xlID0gIUFycmF5LmlzQXJyYXkoc3RvcmVzKTtcblx0LyoqIEB0eXBlIHtBcnJheTxSZWFkYWJsZTxhbnk+Pn0gKi9cblx0Y29uc3Qgc3RvcmVzX2FycmF5ID0gc2luZ2xlID8gW3N0b3Jlc10gOiBzdG9yZXM7XG5cdGlmICghc3RvcmVzX2FycmF5LmV2ZXJ5KEJvb2xlYW4pKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkKCkgZXhwZWN0cyBzdG9yZXMgYXMgaW5wdXQsIGdvdCBhIGZhbHN5IHZhbHVlJyk7XG5cdH1cblx0Y29uc3QgYXV0byA9IGZuLmxlbmd0aCA8IDI7XG5cdHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0LCB1cGRhdGUpID0+IHtcblx0XHRsZXQgc3RhcnRlZCA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7VFtdfSAqL1xuXHRcdGNvbnN0IHZhbHVlcyA9IFtdO1xuXHRcdGxldCBwZW5kaW5nID0gMDtcblx0XHRsZXQgY2xlYW51cCA9IG5vb3A7XG5cdFx0Y29uc3Qgc3luYyA9ICgpID0+IHtcblx0XHRcdGlmIChwZW5kaW5nKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNsZWFudXAoKTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0LCB1cGRhdGUpO1xuXHRcdFx0aWYgKGF1dG8pIHtcblx0XHRcdFx0c2V0KHJlc3VsdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbnVwID0gdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJyA/IHJlc3VsdCA6IG5vb3A7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcCgoc3RvcmUsIGkpID0+XG5cdFx0XHRzdWJzY3JpYmVfdG9fc3RvcmUoXG5cdFx0XHRcdHN0b3JlLFxuXHRcdFx0XHQodmFsdWUpID0+IHtcblx0XHRcdFx0XHR2YWx1ZXNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRwZW5kaW5nICY9IH4oMSA8PCBpKTtcblx0XHRcdFx0XHRpZiAoc3RhcnRlZCkge1xuXHRcdFx0XHRcdFx0c3luYygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdHBlbmRpbmcgfD0gMSA8PCBpO1xuXHRcdFx0XHR9XG5cdFx0XHQpXG5cdFx0KTtcblx0XHRzdGFydGVkID0gdHJ1ZTtcblx0XHRzeW5jKCk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0b3AoKSB7XG5cdFx0XHRydW5fYWxsKHVuc3Vic2NyaWJlcnMpO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0Ly8gV2UgbmVlZCB0byBzZXQgdGhpcyB0byBmYWxzZSBiZWNhdXNlIGNhbGxiYWNrcyBjYW4gc3RpbGwgaGFwcGVuIGRlc3BpdGUgaGF2aW5nIHVuc3Vic2NyaWJlZDpcblx0XHRcdC8vIENhbGxiYWNrcyBtaWdodCBhbHJlYWR5IGJlIHBsYWNlZCBpbiB0aGUgcXVldWUgd2hpY2ggZG9lc24ndCBrbm93IGl0IHNob3VsZCBubyBsb25nZXJcblx0XHRcdC8vIGludm9rZSB0aGlzIGRlcml2ZWQgc3RvcmUuXG5cdFx0XHRzdGFydGVkID0gZmFsc2U7XG5cdFx0fTtcblx0fSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBzdG9yZSBhbmQgcmV0dXJucyBhIG5ldyBvbmUgZGVyaXZlZCBmcm9tIHRoZSBvbGQgb25lIHRoYXQgaXMgcmVhZGFibGUuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7UmVhZGFibGU8VD59IHN0b3JlICAtIHN0b3JlIHRvIG1ha2UgcmVhZG9ubHlcbiAqIEByZXR1cm5zIHtSZWFkYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG5cdHJldHVybiB7XG5cdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIGkgc3VzcGVjdCB0aGUgYmluZCBpcyB1bm5lY2Vzc2FyeVxuXHRcdHN1YnNjcmliZTogc3RvcmUuc3Vic2NyaWJlLmJpbmQoc3RvcmUpXG5cdH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZyb20gYSBzdG9yZSBieSBzdWJzY3JpYmluZyBhbmQgaW1tZWRpYXRlbHkgdW5zdWJzY3JpYmluZy5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtSZWFkYWJsZTxUPn0gc3RvcmVcbiAqIEByZXR1cm5zIHtUfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHN0b3JlKSB7XG5cdGxldCB2YWx1ZTtcblx0c3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAoXykgPT4gKHZhbHVlID0gXykpKCk7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0cmV0dXJuIHZhbHVlO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgU3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyIH0gZnJvbSAnI2NsaWVudCcgKi9cbi8qKiBAaW1wb3J0IHsgU3RvcmUgfSBmcm9tICcjc2hhcmVkJyAqL1xuaW1wb3J0IHsgc3Vic2NyaWJlX3RvX3N0b3JlIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmUvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0IGFzIGdldF9zdG9yZSB9IGZyb20gJy4uLy4uLy4uL3N0b3JlL3NoYXJlZC9pbmRleC5qcyc7XG5pbXBvcnQgeyBkZWZpbmVfcHJvcGVydHksIG5vb3AgfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSAnLi4vcnVudGltZS5qcyc7XG5pbXBvcnQgeyB0ZWFyZG93biB9IGZyb20gJy4vZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBtdXRhYmxlX3NvdXJjZSwgc2V0IH0gZnJvbSAnLi9zb3VyY2VzLmpzJztcbmltcG9ydCB7IERFViB9IGZyb20gJ2VzbS1lbnYnO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wIGN1cnJlbnRseSBiZWluZyByZWFkIGlzIGEgc3RvcmUgYmluZGluZywgYXMgaW5cbiAqIGA8Q2hpbGQgYmluZDp4PXskeX0gLz5gLiBJZiBpdCBpcywgd2UgdHJlYXQgdGhlIHByb3AgYXMgbXV0YWJsZSBldmVuIGluXG4gKiBydW5lcyBtb2RlLCBhbmQgc2tpcCBgYmluZGluZ19wcm9wZXJ0eV9ub25fcmVhY3RpdmVgIHZhbGlkYXRpb25cbiAqL1xubGV0IGlzX3N0b3JlX2JpbmRpbmcgPSBmYWxzZTtcblxubGV0IElTX1VOTU9VTlRFRCA9IFN5bWJvbCgpO1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBzdG9yZS4gSWYgdGhlIHN0b3JlIGlzbid0IHN1YnNjcmliZWQgdG8geWV0LCBpdCB3aWxsIGNyZWF0ZSBhIHByb3h5XG4gKiBzaWduYWwgdGhhdCB3aWxsIGJlIHVwZGF0ZWQgd2hlbiB0aGUgc3RvcmUgaXMuIFRoZSBzdG9yZSByZWZlcmVuY2VzIGNvbnRhaW5lciBpcyBuZWVkZWQgdG9cbiAqIHRyYWNrIHJlYXNzaWdubWVudHMgdG8gc3RvcmVzIGFuZCB0byB0cmFjayB0aGUgY29ycmVjdCBjb21wb25lbnQgY29udGV4dC5cbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge1N0b3JlPFY+IHwgbnVsbCB8IHVuZGVmaW5lZH0gc3RvcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKiBAcGFyYW0ge1N0b3JlUmVmZXJlbmNlc0NvbnRhaW5lcn0gc3RvcmVzXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX2dldChzdG9yZSwgc3RvcmVfbmFtZSwgc3RvcmVzKSB7XG5cdGNvbnN0IGVudHJ5ID0gKHN0b3Jlc1tzdG9yZV9uYW1lXSA/Pz0ge1xuXHRcdHN0b3JlOiBudWxsLFxuXHRcdHNvdXJjZTogbXV0YWJsZV9zb3VyY2UodW5kZWZpbmVkKSxcblx0XHR1bnN1YnNjcmliZTogbm9vcFxuXHR9KTtcblxuXHRpZiAoREVWKSB7XG5cdFx0ZW50cnkuc291cmNlLmxhYmVsID0gc3RvcmVfbmFtZTtcblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgdGhhdCBzZXR1cCB0aGlzIGlzIGFscmVhZHkgdW5tb3VudGVkIHdlIGRvbid0IHdhbnQgdG8gcmVnaXN0ZXIgYSBzdWJzY3JpcHRpb25cblx0aWYgKGVudHJ5LnN0b3JlICE9PSBzdG9yZSAmJiAhKElTX1VOTU9VTlRFRCBpbiBzdG9yZXMpKSB7XG5cdFx0ZW50cnkudW5zdWJzY3JpYmUoKTtcblx0XHRlbnRyeS5zdG9yZSA9IHN0b3JlID8/IG51bGw7XG5cblx0XHRpZiAoc3RvcmUgPT0gbnVsbCkge1xuXHRcdFx0ZW50cnkuc291cmNlLnYgPSB1bmRlZmluZWQ7IC8vIHNlZSBzeW5jaHJvbm91cyBjYWxsYmFjayBjb21tZW50IGJlbG93XG5cdFx0XHRlbnRyeS51bnN1YnNjcmliZSA9IG5vb3A7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBpc19zeW5jaHJvbm91c19jYWxsYmFjayA9IHRydWU7XG5cblx0XHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gc3Vic2NyaWJlX3RvX3N0b3JlKHN0b3JlLCAodikgPT4ge1xuXHRcdFx0XHRpZiAoaXNfc3luY2hyb25vdXNfY2FsbGJhY2spIHtcblx0XHRcdFx0XHQvLyBJZiB0aGUgZmlyc3QgdXBkYXRlcyB0byB0aGUgc3RvcmUgdmFsdWUgKHBvc3NpYmx5IG11bHRpcGxlIG9mIHRoZW0pIGFyZSBzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0Ly8gaW5zaWRlIGEgZGVyaXZlZCwgd2Ugd2lsbCBoaXQgdGhlIGBzdGF0ZV91bnNhZmVfbXV0YXRpb25gIGVycm9yIGlmIHdlIGBzZXRgIHRoZSB2YWx1ZVxuXHRcdFx0XHRcdGVudHJ5LnNvdXJjZS52ID0gdjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZXQoZW50cnkuc291cmNlLCB2KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdGlzX3N5bmNocm9ub3VzX2NhbGxiYWNrID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCB0aGF0IHNldHVwIHRoaXMgc3RvcmVzIGlzIGFscmVhZHkgdW5tb3VudGVkIHRoZSBzb3VyY2Ugd2lsbCBiZSBvdXQgb2Ygc3luY1xuXHQvLyBzbyB3ZSBqdXN0IHVzZSB0aGUgYGdldGAgZm9yIHRoZSBzdG9yZXMsIGxlc3MgcGVyZm9ybWFudCBidXQgaXQgYXZvaWRzIHRvIGNyZWF0ZSBhIG1lbW9yeSBsZWFrXG5cdC8vIGFuZCBpdCB3aWxsIGtlZXAgdGhlIHZhbHVlIGNvbnNpc3RlbnRcblx0aWYgKHN0b3JlICYmIElTX1VOTU9VTlRFRCBpbiBzdG9yZXMpIHtcblx0XHRyZXR1cm4gZ2V0X3N0b3JlKHN0b3JlKTtcblx0fVxuXG5cdHJldHVybiBnZXQoZW50cnkuc291cmNlKTtcbn1cblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgaWYgaXQncyBub3QgdGhlIHNhbWUgYXMgdGhlIG9uZSBpbiB0aGUgc3RvcmUgcmVmZXJlbmNlcyBjb250YWluZXIuXG4gKiBXZSBuZWVkIHRoaXMgaW4gYWRkaXRpb24gdG8gYHN0b3JlX2dldGAgYmVjYXVzZSBzb21lb25lIGNvdWxkIHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBidXRcbiAqIHRoZW4gbmV2ZXIgc3Vic2NyaWJlIHRvIHRoZSBuZXcgb25lIChpZiBhbnkpLCBjYXVzaW5nIHRoZSBzdWJzY3JpcHRpb24gdG8gc3RheSBvcGVuIHdyb25nZnVsbHkuXG4gKiBAcGFyYW0ge1N0b3JlPGFueT4gfCBudWxsIHwgdW5kZWZpbmVkfSBzdG9yZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0b3JlX25hbWVcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX3Vuc3ViKHN0b3JlLCBzdG9yZV9uYW1lLCBzdG9yZXMpIHtcblx0LyoqIEB0eXBlIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJbJyddIHwgdW5kZWZpbmVkfSAqL1xuXHRsZXQgZW50cnkgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cblx0aWYgKGVudHJ5ICYmIGVudHJ5LnN0b3JlICE9PSBzdG9yZSkge1xuXHRcdC8vIERvbid0IHJlc2V0IHN0b3JlIHlldCwgc28gdGhhdCBzdG9yZV9nZXQgYWJvdmUgY2FuIHJlc3Vic2NyaWJlIHRvIG5ldyBzdG9yZSBpZiBuZWNlc3Nhcnlcblx0XHRlbnRyeS51bnN1YnNjcmliZSgpO1xuXHRcdGVudHJ5LnVuc3Vic2NyaWJlID0gbm9vcDtcblx0fVxuXG5cdHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBuZXcgdmFsdWUgb2YgYSBzdG9yZSBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLlxuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7U3RvcmU8Vj59IHN0b3JlXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcmV0dXJucyB7Vn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX3NldChzdG9yZSwgdmFsdWUpIHtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmVSZWZlcmVuY2VzQ29udGFpbmVyfSBzdG9yZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdG9yZV9uYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlX3N0b3JlKHN0b3Jlcywgc3RvcmVfbmFtZSkge1xuXHR2YXIgZW50cnkgPSBzdG9yZXNbc3RvcmVfbmFtZV07XG5cdGlmIChlbnRyeS5zdG9yZSAhPT0gbnVsbCkge1xuXHRcdHN0b3JlX3NldChlbnRyeS5zdG9yZSwgZW50cnkuc291cmNlLnYpO1xuXHR9XG59XG5cbi8qKlxuICogVW5zdWJzY3JpYmVzIGZyb20gYWxsIGF1dG8tc3Vic2NyaWJlZCBzdG9yZXMgb24gZGVzdHJveVxuICogQHJldHVybnMge1tTdG9yZVJlZmVyZW5jZXNDb250YWluZXIsICgpPT52b2lkXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwX3N0b3JlcygpIHtcblx0LyoqIEB0eXBlIHtTdG9yZVJlZmVyZW5jZXNDb250YWluZXJ9ICovXG5cdGNvbnN0IHN0b3JlcyA9IHt9O1xuXG5cdGZ1bmN0aW9uIGNsZWFudXAoKSB7XG5cdFx0dGVhcmRvd24oKCkgPT4ge1xuXHRcdFx0Zm9yICh2YXIgc3RvcmVfbmFtZSBpbiBzdG9yZXMpIHtcblx0XHRcdFx0Y29uc3QgcmVmID0gc3RvcmVzW3N0b3JlX25hbWVdO1xuXHRcdFx0XHRyZWYudW5zdWJzY3JpYmUoKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZV9wcm9wZXJ0eShzdG9yZXMsIElTX1VOTU9VTlRFRCwge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdFx0dmFsdWU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIFtzdG9yZXMsIGNsZWFudXBdO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgYSBzdG9yZSB3aXRoIGEgbmV3IHZhbHVlLlxuICogQHBhcmFtIHtTdG9yZTxWPn0gc3RvcmUgIHRoZSBzdG9yZSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBleHByZXNzaW9uICB0aGUgZXhwcmVzc2lvbiB0aGF0IG11dGF0ZXMgdGhlIHN0b3JlXG4gKiBAcGFyYW0ge1Z9IG5ld192YWx1ZSAgdGhlIG5ldyBzdG9yZSB2YWx1ZVxuICogQHRlbXBsYXRlIFZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0b3JlX211dGF0ZShzdG9yZSwgZXhwcmVzc2lvbiwgbmV3X3ZhbHVlKSB7XG5cdHN0b3JlLnNldChuZXdfdmFsdWUpO1xuXHRyZXR1cm4gZXhwcmVzc2lvbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0b3JlPG51bWJlcj59IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RvcmVfdmFsdWVcbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfc3RvcmUoc3RvcmUsIHN0b3JlX3ZhbHVlLCBkID0gMSkge1xuXHRzdG9yZS5zZXQoc3RvcmVfdmFsdWUgKyBkKTtcblx0cmV0dXJuIHN0b3JlX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3RvcmU8bnVtYmVyPn0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdG9yZV92YWx1ZVxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmVfc3RvcmUoc3RvcmUsIHN0b3JlX3ZhbHVlLCBkID0gMSkge1xuXHRjb25zdCB2YWx1ZSA9IHN0b3JlX3ZhbHVlICsgZDtcblx0c3RvcmUuc2V0KHZhbHVlKTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxlZCBpbnNpZGUgcHJvcCBnZXR0ZXJzIHRvIGNvbW11bmljYXRlIHRoYXQgdGhlIHByb3AgaXMgYSBzdG9yZSBiaW5kaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrX3N0b3JlX2JpbmRpbmcoKSB7XG5cdGlzX3N0b3JlX2JpbmRpbmcgPSB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB0dXBsZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIGBmbigpYCByZWFkcyBhIHByb3AgdGhhdCBpcyBhIHN0b3JlIGJpbmRpbmcuXG4gKiBVc2VkIHRvIHByZXZlbnQgYGJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlYCB2YWxpZGF0aW9uIGZhbHNlIHBvc2l0aXZlcyBhbmRcbiAqIGVuc3VyZSB0aGF0IHRoZXNlIHByb3BzIGFyZSB0cmVhdGVkIGFzIG11dGFibGUgZXZlbiBpbiBydW5lcyBtb2RlXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHsoKSA9PiBUfSBmblxuICogQHJldHVybnMge1tULCBib29sZWFuXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVfc3RvcmVfYmluZGluZyhmbikge1xuXHR2YXIgcHJldmlvdXNfaXNfc3RvcmVfYmluZGluZyA9IGlzX3N0b3JlX2JpbmRpbmc7XG5cblx0dHJ5IHtcblx0XHRpc19zdG9yZV9iaW5kaW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIFtmbigpLCBpc19zdG9yZV9iaW5kaW5nXTtcblx0fSBmaW5hbGx5IHtcblx0XHRpc19zdG9yZV9iaW5kaW5nID0gcHJldmlvdXNfaXNfc3RvcmVfYmluZGluZztcblx0fVxufVxuIiwgIi8qKiBAaW1wb3J0IHsgRWZmZWN0LCBTb3VyY2UgfSBmcm9tICcuL3R5cGVzLmpzJyAqL1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQge1xuXHRQUk9QU19JU19CSU5EQUJMRSxcblx0UFJPUFNfSVNfSU1NVVRBQkxFLFxuXHRQUk9QU19JU19MQVpZX0lOSVRJQUwsXG5cdFBST1BTX0lTX1JVTkVTLFxuXHRQUk9QU19JU19VUERBVEVEXG59IGZyb20gJy4uLy4uLy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBnZXRfZGVzY3JpcHRvciwgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuaW1wb3J0IHsgc2V0LCBzb3VyY2UsIHVwZGF0ZSB9IGZyb20gJy4vc291cmNlcy5qcyc7XG5pbXBvcnQgeyBkZXJpdmVkLCBkZXJpdmVkX3NhZmVfZXF1YWwgfSBmcm9tICcuL2Rlcml2ZWRzLmpzJztcbmltcG9ydCB7XG5cdGFjdGl2ZV9lZmZlY3QsXG5cdGdldCxcblx0aXNfZGVzdHJveWluZ19lZmZlY3QsXG5cdHNldF9hY3RpdmVfZWZmZWN0LFxuXHR1bnRyYWNrXG59IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuaW1wb3J0ICogYXMgZSBmcm9tICcuLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgREVTVFJPWUVELCBMRUdBQ1lfUFJPUFMsIFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHByb3h5IH0gZnJvbSAnLi4vcHJveHkuanMnO1xuaW1wb3J0IHsgY2FwdHVyZV9zdG9yZV9iaW5kaW5nIH0gZnJvbSAnLi9zdG9yZS5qcyc7XG5pbXBvcnQgeyBsZWdhY3lfbW9kZV9mbGFnIH0gZnJvbSAnLi4vLi4vZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7KCh2YWx1ZT86IG51bWJlcikgPT4gbnVtYmVyKX0gZm5cbiAqIEBwYXJhbSB7MSB8IC0xfSBbZF1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfcHJvcChmbiwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBmbigpO1xuXHRmbih2YWx1ZSArIGQpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKHZhbHVlPzogbnVtYmVyKSA9PiBudW1iZXIpfSBmblxuICogQHBhcmFtIHsxIHwgLTF9IFtkXVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZV9wcmVfcHJvcChmbiwgZCA9IDEpIHtcblx0Y29uc3QgdmFsdWUgPSBmbigpICsgZDtcblx0Zm4odmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIHJlc3QgcHJvcHMgKGkuZS4gYGNvbnN0IHsgeCwgLi4ucmVzdCB9ID0gJHByb3BzKClgKS5cbiAqIElzIHBhc3NlZCB0aGUgZnVsbCBgJCRwcm9wc2Agb2JqZWN0IGFuZCBleGNsdWRlcyB0aGUgbmFtZWQgcHJvcHMuXG4gKiBAdHlwZSB7UHJveHlIYW5kbGVyPHsgcHJvcHM6IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIHVua25vd24+LCBleGNsdWRlOiBBcnJheTxzdHJpbmcgfCBzeW1ib2w+LCBuYW1lPzogc3RyaW5nIH0+fX1cbiAqL1xuY29uc3QgcmVzdF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdHJldHVybiB0YXJnZXQucHJvcHNba2V5XTtcblx0fSxcblx0c2V0KHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKERFVikge1xuXHRcdFx0Ly8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJvZCB0b28/XG5cdFx0XHRlLnByb3BzX3Jlc3RfcmVhZG9ubHkoYCR7dGFyZ2V0Lm5hbWV9LiR7U3RyaW5nKGtleSl9YCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGlmIChrZXkgaW4gdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB0YXJnZXQucHJvcHNba2V5XVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdGhhcyh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIGtleSBpbiB0YXJnZXQucHJvcHM7XG5cdH0sXG5cdG93bktleXModGFyZ2V0KSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQucHJvcHMpLmZpbHRlcigoa2V5KSA9PiAhdGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSk7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGV4Y2x1ZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn1cbiAqL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5leHBvcnQgZnVuY3Rpb24gcmVzdF9wcm9wcyhwcm9wcywgZXhjbHVkZSwgbmFtZSkge1xuXHRyZXR1cm4gbmV3IFByb3h5KFxuXHRcdERFViA/IHsgcHJvcHMsIGV4Y2x1ZGUsIG5hbWUsIG90aGVyOiB7fSwgdG9fcHJveHk6IFtdIH0gOiB7IHByb3BzLCBleGNsdWRlIH0sXG5cdFx0cmVzdF9wcm9wc19oYW5kbGVyXG5cdCk7XG59XG5cbi8qKlxuICogVGhlIHByb3h5IGhhbmRsZXIgZm9yIGxlZ2FjeSAkJHJlc3RQcm9wcyBhbmQgJCRwcm9wc1xuICogQHR5cGUge1Byb3h5SGFuZGxlcjx7IHByb3BzOiBSZWNvcmQ8c3RyaW5nIHwgc3ltYm9sLCB1bmtub3duPiwgZXhjbHVkZTogQXJyYXk8c3RyaW5nIHwgc3ltYm9sPiwgc3BlY2lhbDogUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgKHY/OiB1bmtub3duKSA9PiB1bmtub3duPiwgdmVyc2lvbjogU291cmNlPG51bWJlcj4sIHBhcmVudF9lZmZlY3Q6IEVmZmVjdCB9Pn19XG4gKi9cbmNvbnN0IGxlZ2FjeV9yZXN0X3Byb3BzX2hhbmRsZXIgPSB7XG5cdGdldCh0YXJnZXQsIGtleSkge1xuXHRcdGlmICh0YXJnZXQuZXhjbHVkZS5pbmNsdWRlcyhrZXkpKSByZXR1cm47XG5cdFx0Z2V0KHRhcmdldC52ZXJzaW9uKTtcblx0XHRyZXR1cm4ga2V5IGluIHRhcmdldC5zcGVjaWFsID8gdGFyZ2V0LnNwZWNpYWxba2V5XSgpIDogdGFyZ2V0LnByb3BzW2tleV07XG5cdH0sXG5cdHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcblx0XHRpZiAoIShrZXkgaW4gdGFyZ2V0LnNwZWNpYWwpKSB7XG5cdFx0XHR2YXIgcHJldmlvdXNfZWZmZWN0ID0gYWN0aXZlX2VmZmVjdDtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QodGFyZ2V0LnBhcmVudF9lZmZlY3QpO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBwcm9wcyB0aGF0IGNhbiB0ZW1wb3JhcmlseSBnZXQgb3V0IG9mIHN5bmMgd2l0aCB0aGUgcGFyZW50XG5cdFx0XHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgKHY/OiB1bmtub3duKSA9PiB1bmtub3duPn0gKi9cblx0XHRcdFx0dGFyZ2V0LnNwZWNpYWxba2V5XSA9IHByb3AoXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Z2V0IFtrZXldKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BzW2tleV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHQvKiogQHR5cGUge3N0cmluZ30gKi8gKGtleSksXG5cdFx0XHRcdFx0UFJPUFNfSVNfVVBEQVRFRFxuXHRcdFx0XHQpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0c2V0X2FjdGl2ZV9lZmZlY3QocHJldmlvdXNfZWZmZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0YXJnZXQuc3BlY2lhbFtrZXldKHZhbHVlKTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pOyAvLyAkJHByb3BzIGlzIGNvYXJzZS1ncmFpbmVkOiB3aGVuICQkcHJvcHMueCBpcyB1cGRhdGVkLCB1c2FnZXMgb2YgJCRwcm9wcy55IGV0YyBhcmUgYWxzbyByZXJ1blxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuXHRcdGlmIChrZXkgaW4gdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB0YXJnZXQucHJvcHNba2V5XVxuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cdGRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KSB7XG5cdFx0Ly8gU3ZlbHRlIDQgYWxsb3dlZCBmb3IgZGVsZXRpb25zIG9uICQkcmVzdFByb3BzXG5cdFx0aWYgKHRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpIHJldHVybiB0cnVlO1xuXHRcdHRhcmdldC5leGNsdWRlLnB1c2goa2V5KTtcblx0XHR1cGRhdGUodGFyZ2V0LnZlcnNpb24pO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHRoYXModGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAodGFyZ2V0LmV4Y2x1ZGUuaW5jbHVkZXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiBrZXkgaW4gdGFyZ2V0LnByb3BzO1xuXHR9LFxuXHRvd25LZXlzKHRhcmdldCkge1xuXHRcdHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0LnByb3BzKS5maWx0ZXIoKGtleSkgPT4gIXRhcmdldC5leGNsdWRlLmluY2x1ZGVzKGtleSkpO1xuXHR9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleGNsdWRlXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZWdhY3lfcmVzdF9wcm9wcyhwcm9wcywgZXhjbHVkZSkge1xuXHRyZXR1cm4gbmV3IFByb3h5KFxuXHRcdHtcblx0XHRcdHByb3BzLFxuXHRcdFx0ZXhjbHVkZSxcblx0XHRcdHNwZWNpYWw6IHt9LFxuXHRcdFx0dmVyc2lvbjogc291cmNlKDApLFxuXHRcdFx0Ly8gVE9ETyB0aGlzIGlzIG9ubHkgbmVjZXNzYXJ5IGJlY2F1c2Ugd2UgbmVlZCB0byB0cmFjayBjb21wb25lbnRcblx0XHRcdC8vIGRlc3RydWN0aW9uIGluc2lkZSBgcHJvcGAsIGJlY2F1c2Ugb2YgYGJpbmQ6dGhpc2AsIGJ1dCBpdFxuXHRcdFx0Ly8gc2VlbXMgbGlrZWx5IHRoYXQgd2UgY2FuIHNpbXBsaWZ5IGBiaW5kOnRoaXNgIGluc3RlYWRcblx0XHRcdHBhcmVudF9lZmZlY3Q6IC8qKiBAdHlwZSB7RWZmZWN0fSAqLyAoYWN0aXZlX2VmZmVjdClcblx0XHR9LFxuXHRcdGxlZ2FjeV9yZXN0X3Byb3BzX2hhbmRsZXJcblx0KTtcbn1cblxuLyoqXG4gKiBUaGUgcHJveHkgaGFuZGxlciBmb3Igc3ByZWFkIHByb3BzLiBIYW5kbGVzIHRoZSBpbmNvbWluZyBhcnJheSBvZiBwcm9wc1xuICogdGhhdCBsb29rcyBsaWtlIGAoKSA9PiB7IGR5bmFtaWM6IHByb3BzIH0sIHsgc3RhdGljOiBwcm9wIH0sIC4uYCBhbmQgd3JhcHNcbiAqIHRoZW0gc28gdGhhdCB0aGUgd2hvbGUgdGhpbmcgaXMgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQgYXMgdGhlIGAkJHByb3BzYCBhcmd1bWVudC5cbiAqIEB0eXBlIHtQcm94eUhhbmRsZXI8eyBwcm9wczogQXJyYXk8UmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4gfCAoKCkgPT4gUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgdW5rbm93bj4pPiB9Pn19XG4gKi9cbmNvbnN0IHNwcmVhZF9wcm9wc19oYW5kbGVyID0ge1xuXHRnZXQodGFyZ2V0LCBrZXkpIHtcblx0XHRsZXQgaSA9IHRhcmdldC5wcm9wcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0bGV0IHAgPSB0YXJnZXQucHJvcHNbaV07XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAodHlwZW9mIHAgPT09ICdvYmplY3QnICYmIHAgIT09IG51bGwgJiYga2V5IGluIHApIHJldHVybiBwW2tleV07XG5cdFx0fVxuXHR9LFxuXHRzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG5cdFx0bGV0IGkgPSB0YXJnZXQucHJvcHMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGxldCBwID0gdGFyZ2V0LnByb3BzW2ldO1xuXHRcdFx0aWYgKGlzX2Z1bmN0aW9uKHApKSBwID0gcCgpO1xuXHRcdFx0Y29uc3QgZGVzYyA9IGdldF9kZXNjcmlwdG9yKHAsIGtleSk7XG5cdFx0XHRpZiAoZGVzYyAmJiBkZXNjLnNldCkge1xuXHRcdFx0XHRkZXNjLnNldCh2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuXHRcdGxldCBpID0gdGFyZ2V0LnByb3BzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRsZXQgcCA9IHRhcmdldC5wcm9wc1tpXTtcblx0XHRcdGlmIChpc19mdW5jdGlvbihwKSkgcCA9IHAoKTtcblx0XHRcdGlmICh0eXBlb2YgcCA9PT0gJ29iamVjdCcgJiYgcCAhPT0gbnVsbCAmJiBrZXkgaW4gcCkge1xuXHRcdFx0XHRjb25zdCBkZXNjcmlwdG9yID0gZ2V0X2Rlc2NyaXB0b3IocCwga2V5KTtcblx0XHRcdFx0aWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0Ly8gUHJldmVudCBhIFwiTm9uLWNvbmZpZ3VyYWJpbGl0eSBSZXBvcnQgRXJyb3JcIjogVGhlIHRhcmdldCBpcyBhbiBhcnJheSwgaXQgZG9lc1xuXHRcdFx0XHRcdC8vIG5vdCBhY3R1YWxseSBjb250YWluIHRoaXMgcHJvcGVydHkuIElmIGl0IGlzIG5vdyBkZXNjcmliZWQgYXMgbm9uLWNvbmZpZ3VyYWJsZSxcblx0XHRcdFx0XHQvLyB0aGUgcHJveHkgdGhyb3dzIGEgdmFsaWRhdGlvbiBlcnJvci4gU2V0dGluZyBpdCB0byB0cnVlIGF2b2lkcyB0aGF0LlxuXHRcdFx0XHRcdGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGVzY3JpcHRvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhcyh0YXJnZXQsIGtleSkge1xuXHRcdC8vIFRvIHByZXZlbnQgYSBmYWxzZSBwb3NpdGl2ZSBgaXNfZW50cnlfcHJvcHNgIGluIHRoZSBgcHJvcGAgZnVuY3Rpb25cblx0XHRpZiAoa2V5ID09PSBTVEFURV9TWU1CT0wgfHwga2V5ID09PSBMRUdBQ1lfUFJPUFMpIHJldHVybiBmYWxzZTtcblxuXHRcdGZvciAobGV0IHAgb2YgdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAocCAhPSBudWxsICYmIGtleSBpbiBwKSByZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdG93bktleXModGFyZ2V0KSB7XG5cdFx0LyoqIEB0eXBlIHtBcnJheTxzdHJpbmcgfCBzeW1ib2w+fSAqL1xuXHRcdGNvbnN0IGtleXMgPSBbXTtcblxuXHRcdGZvciAobGV0IHAgb2YgdGFyZ2V0LnByb3BzKSB7XG5cdFx0XHRpZiAoaXNfZnVuY3Rpb24ocCkpIHAgPSBwKCk7XG5cdFx0XHRpZiAoIXApIGNvbnRpbnVlO1xuXG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBwKSB7XG5cdFx0XHRcdGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSBrZXlzLnB1c2goa2V5KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwKSkge1xuXHRcdFx0XHRpZiAoIWtleXMuaW5jbHVkZXMoa2V5KSkga2V5cy5wdXNoKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGtleXM7XG5cdH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8ICgoKSA9PiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik+fSBwcm9wc1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwcmVhZF9wcm9wcyguLi5wcm9wcykge1xuXHRyZXR1cm4gbmV3IFByb3h5KHsgcHJvcHMgfSwgc3ByZWFkX3Byb3BzX2hhbmRsZXIpO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHN5bmNocm9uaXppbmcgYSBwb3NzaWJseSBib3VuZCBwcm9wIHdpdGggdGhlIGlubmVyIGNvbXBvbmVudCBzdGF0ZS5cbiAqIEl0IGlzIHVzZWQgd2hlbmV2ZXIgdGhlIGNvbXBpbGVyIHNlZXMgdGhhdCB0aGUgY29tcG9uZW50IHdyaXRlcyB0byB0aGUgcHJvcCwgb3Igd2hlbiBpdCBoYXMgYSBkZWZhdWx0IHByb3BfdmFsdWUuXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCB1bmtub3duPn0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnc1xuICogQHBhcmFtIHtWIHwgKCgpID0+IFYpfSBbZmFsbGJhY2tdXG4gKiBAcmV0dXJucyB7KCgpID0+IFYgfCAoKGFyZzogVikgPT4gVikgfCAoKGFyZzogViwgbXV0YXRpb246IGJvb2xlYW4pID0+IFYpKX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3AocHJvcHMsIGtleSwgZmxhZ3MsIGZhbGxiYWNrKSB7XG5cdHZhciBydW5lcyA9ICFsZWdhY3lfbW9kZV9mbGFnIHx8IChmbGFncyAmIFBST1BTX0lTX1JVTkVTKSAhPT0gMDtcblx0dmFyIGJpbmRhYmxlID0gKGZsYWdzICYgUFJPUFNfSVNfQklOREFCTEUpICE9PSAwO1xuXHR2YXIgbGF6eSA9IChmbGFncyAmIFBST1BTX0lTX0xBWllfSU5JVElBTCkgIT09IDA7XG5cblx0dmFyIGZhbGxiYWNrX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAoZmFsbGJhY2spO1xuXHR2YXIgZmFsbGJhY2tfZGlydHkgPSB0cnVlO1xuXG5cdHZhciBnZXRfZmFsbGJhY2sgPSAoKSA9PiB7XG5cdFx0aWYgKGZhbGxiYWNrX2RpcnR5KSB7XG5cdFx0XHRmYWxsYmFja19kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRmYWxsYmFja192YWx1ZSA9IGxhenlcblx0XHRcdFx0PyB1bnRyYWNrKC8qKiBAdHlwZSB7KCkgPT4gVn0gKi8gKGZhbGxiYWNrKSlcblx0XHRcdFx0OiAvKiogQHR5cGUge1Z9ICovIChmYWxsYmFjayk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbGxiYWNrX3ZhbHVlO1xuXHR9O1xuXG5cdC8qKiBAdHlwZSB7KCh2OiBWKSA9PiB2b2lkKSB8IHVuZGVmaW5lZH0gKi9cblx0dmFyIHNldHRlcjtcblxuXHRpZiAoYmluZGFibGUpIHtcblx0XHQvLyBDYW4gYmUgdGhlIGNhc2Ugd2hlbiBzb21lb25lIGRvZXMgYG1vdW50KENvbXBvbmVudCwgcHJvcHMpYCB3aXRoIGBsZXQgcHJvcHMgPSAkc3RhdGUoey4uLn0pYFxuXHRcdC8vIG9yIGBjcmVhdGVDbGFzc0NvbXBvbmVudChDb21wb25lbnQsIHByb3BzKWBcblx0XHR2YXIgaXNfZW50cnlfcHJvcHMgPSBTVEFURV9TWU1CT0wgaW4gcHJvcHMgfHwgTEVHQUNZX1BST1BTIGluIHByb3BzO1xuXG5cdFx0c2V0dGVyID1cblx0XHRcdGdldF9kZXNjcmlwdG9yKHByb3BzLCBrZXkpPy5zZXQgPz9cblx0XHRcdChpc19lbnRyeV9wcm9wcyAmJiBrZXkgaW4gcHJvcHMgPyAodikgPT4gKHByb3BzW2tleV0gPSB2KSA6IHVuZGVmaW5lZCk7XG5cdH1cblxuXHR2YXIgaW5pdGlhbF92YWx1ZTtcblx0dmFyIGlzX3N0b3JlX3N1YiA9IGZhbHNlO1xuXG5cdGlmIChiaW5kYWJsZSkge1xuXHRcdFtpbml0aWFsX3ZhbHVlLCBpc19zdG9yZV9zdWJdID0gY2FwdHVyZV9zdG9yZV9iaW5kaW5nKCgpID0+IC8qKiBAdHlwZSB7Vn0gKi8gKHByb3BzW2tleV0pKTtcblx0fSBlbHNlIHtcblx0XHRpbml0aWFsX3ZhbHVlID0gLyoqIEB0eXBlIHtWfSAqLyAocHJvcHNba2V5XSk7XG5cdH1cblxuXHRpZiAoaW5pdGlhbF92YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcblx0XHRpbml0aWFsX3ZhbHVlID0gZ2V0X2ZhbGxiYWNrKCk7XG5cblx0XHRpZiAoc2V0dGVyKSB7XG5cdFx0XHRpZiAocnVuZXMpIGUucHJvcHNfaW52YWxpZF92YWx1ZShrZXkpO1xuXHRcdFx0c2V0dGVyKGluaXRpYWxfdmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBAdHlwZSB7KCkgPT4gVn0gKi9cblx0dmFyIGdldHRlcjtcblxuXHRpZiAocnVuZXMpIHtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0X2ZhbGxiYWNrKCk7XG5cdFx0XHRmYWxsYmFja19kaXJ0eSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRnZXR0ZXIgPSAoKSA9PiB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvKiogQHR5cGUge1Z9ICovIChwcm9wc1trZXldKTtcblxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gaW4gbGVnYWN5IG1vZGUsIHdlIGRvbid0IHJldmVydCB0byB0aGUgZmFsbGJhY2sgdmFsdWVcblx0XHRcdFx0Ly8gaWYgdGhlIHByb3AgZ29lcyBmcm9tIGRlZmluZWQgdG8gdW5kZWZpbmVkLiBUaGUgZWFzaWVzdFxuXHRcdFx0XHQvLyB3YXkgdG8gbW9kZWwgdGhpcyBpcyB0byBtYWtlIHRoZSBmYWxsYmFjayB1bmRlZmluZWRcblx0XHRcdFx0Ly8gYXMgc29vbiBhcyB0aGUgcHJvcCBoYXMgYSB2YWx1ZVxuXHRcdFx0XHRmYWxsYmFja192YWx1ZSA9IC8qKiBAdHlwZSB7Vn0gKi8gKHVuZGVmaW5lZCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZmFsbGJhY2tfdmFsdWUgOiB2YWx1ZTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gcHJvcCBpcyBuZXZlciB3cml0dGVuIHRvIFx1MjAxNCB3ZSBvbmx5IG5lZWQgYSBnZXR0ZXJcblx0aWYgKHJ1bmVzICYmIChmbGFncyAmIFBST1BTX0lTX1VQREFURUQpID09PSAwKSB7XG5cdFx0cmV0dXJuIGdldHRlcjtcblx0fVxuXG5cdC8vIHByb3AgaXMgd3JpdHRlbiB0bywgYnV0IHRoZSBwYXJlbnQgY29tcG9uZW50IGhhZCBgYmluZDpmb29gIHdoaWNoXG5cdC8vIG1lYW5zIHdlIGNhbiBqdXN0IGNhbGwgYCQkcHJvcHMuZm9vID0gdmFsdWVgIGRpcmVjdGx5XG5cdGlmIChzZXR0ZXIpIHtcblx0XHR2YXIgbGVnYWN5X3BhcmVudCA9IHByb3BzLiQkbGVnYWN5O1xuXHRcdHJldHVybiAvKiogQHR5cGUgeygpID0+IFZ9ICovIChcblx0XHRcdGZ1bmN0aW9uICgvKiogQHR5cGUge1Z9ICovIHZhbHVlLCAvKiogQHR5cGUge2Jvb2xlYW59ICovIG11dGF0aW9uKSB7XG5cdFx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gbm90aWZ5IGlmIHRoZSB2YWx1ZSB3YXMgbXV0YXRlZCBhbmQgdGhlIHBhcmVudCBpcyBpbiBydW5lcyBtb2RlLlxuXHRcdFx0XHRcdC8vIEluIHRoYXQgY2FzZSB0aGUgc3RhdGUgcHJveHkgKGlmIGl0IGV4aXN0cykgc2hvdWxkIHRha2UgY2FyZSBvZiB0aGUgbm90aWZpY2F0aW9uLlxuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgaXMgbm90IGluIHJ1bmVzIG1vZGUsIHdlIG5lZWQgdG8gbm90aWZ5IG9uIG11dGF0aW9uLCB0b28sIHRoYXQgdGhlIHByb3Bcblx0XHRcdFx0XHQvLyBoYXMgY2hhbmdlZCBiZWNhdXNlIHRoZSBwYXJlbnQgd2lsbCBub3QgYmUgYWJsZSB0byBkZXRlY3QgdGhlIGNoYW5nZSBvdGhlcndpc2UuXG5cdFx0XHRcdFx0aWYgKCFydW5lcyB8fCAhbXV0YXRpb24gfHwgbGVnYWN5X3BhcmVudCB8fCBpc19zdG9yZV9zdWIpIHtcblx0XHRcdFx0XHRcdC8qKiBAdHlwZSB7RnVuY3Rpb259ICovIChzZXR0ZXIpKG11dGF0aW9uID8gZ2V0dGVyKCkgOiB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGdldHRlcigpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHQvLyBFaXRoZXIgcHJvcCBpcyB3cml0dGVuIHRvLCBidXQgdGhlcmUncyBubyBiaW5kaW5nLCB3aGljaCBtZWFucyB3ZVxuXHQvLyBjcmVhdGUgYSBkZXJpdmVkIHRoYXQgd2UgY2FuIHdyaXRlIHRvIGxvY2FsbHkuXG5cdC8vIE9yIHdlIGFyZSBpbiBsZWdhY3kgbW9kZSB3aGVyZSB3ZSBhbHdheXMgY3JlYXRlIGEgZGVyaXZlZCB0byByZXBsaWNhdGUgdGhhdFxuXHQvLyBTdmVsdGUgNCBkaWQgbm90IHRyaWdnZXIgdXBkYXRlcyB3aGVuIGEgcHJpbWl0aXZlIHZhbHVlIHdhcyB1cGRhdGVkIHRvIHRoZSBzYW1lIHZhbHVlLlxuXHR2YXIgb3ZlcnJpZGRlbiA9IGZhbHNlO1xuXG5cdHZhciBkID0gKChmbGFncyAmIFBST1BTX0lTX0lNTVVUQUJMRSkgIT09IDAgPyBkZXJpdmVkIDogZGVyaXZlZF9zYWZlX2VxdWFsKSgoKSA9PiB7XG5cdFx0b3ZlcnJpZGRlbiA9IGZhbHNlO1xuXHRcdHJldHVybiBnZXR0ZXIoKTtcblx0fSk7XG5cblx0aWYgKERFVikge1xuXHRcdGQubGFiZWwgPSBrZXk7XG5cdH1cblxuXHQvLyBDYXB0dXJlIHRoZSBpbml0aWFsIHZhbHVlIGlmIGl0J3MgYmluZGFibGVcblx0aWYgKGJpbmRhYmxlKSBnZXQoZCk7XG5cblx0dmFyIHBhcmVudF9lZmZlY3QgPSAvKiogQHR5cGUge0VmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXG5cdHJldHVybiAvKiogQHR5cGUgeygpID0+IFZ9ICovIChcblx0XHRmdW5jdGlvbiAoLyoqIEB0eXBlIHthbnl9ICovIHZhbHVlLCAvKiogQHR5cGUge2Jvb2xlYW59ICovIG11dGF0aW9uKSB7XG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgbmV3X3ZhbHVlID0gbXV0YXRpb24gPyBnZXQoZCkgOiBydW5lcyAmJiBiaW5kYWJsZSA/IHByb3h5KHZhbHVlKSA6IHZhbHVlO1xuXG5cdFx0XHRcdHNldChkLCBuZXdfdmFsdWUpO1xuXHRcdFx0XHRvdmVycmlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHRpZiAoZmFsbGJhY2tfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGZhbGxiYWNrX3ZhbHVlID0gbmV3X3ZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzcGVjaWFsIGNhc2UgXHUyMDE0IGF2b2lkIHJlY2FsY3VsYXRpbmcgdGhlIGRlcml2ZWQgaWYgd2UncmUgaW4gYVxuXHRcdFx0Ly8gdGVhcmRvd24gZnVuY3Rpb24gYW5kIHRoZSBwcm9wIHdhcyBvdmVycmlkZGVuIGxvY2FsbHksIG9yIHRoZVxuXHRcdFx0Ly8gY29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCAodGhpcyBsYXR0ZXIgcGFydCBpcyBuZWNlc3Nhcnlcblx0XHRcdC8vIGJlY2F1c2UgYGJpbmQ6dGhpc2AgY2FuIHJlYWQgcHJvcHMgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXNcblx0XHRcdC8vIGJlZW4gZGVzdHJveWVkLiBUT0RPIHNpbXBsaWZ5IGBiaW5kOnRoaXNgXG5cdFx0XHRpZiAoKGlzX2Rlc3Ryb3lpbmdfZWZmZWN0ICYmIG92ZXJyaWRkZW4pIHx8IChwYXJlbnRfZWZmZWN0LmYgJiBERVNUUk9ZRUQpICE9PSAwKSB7XG5cdFx0XHRcdHJldHVybiBkLnY7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBnZXQoZCk7XG5cdFx0fVxuXHQpO1xufVxuIiwgImltcG9ydCB7IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbiB9IGZyb20gJy4vY29udGV4dC5qcyc7XG5pbXBvcnQgeyBpc19hcnJheSB9IGZyb20gJy4uL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IEZJTEVOQU1FIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzLmpzJztcbmltcG9ydCB7IHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuL3JlYWN0aXZpdHkvZWZmZWN0cy5qcyc7XG5pbXBvcnQgKiBhcyB3IGZyb20gJy4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgY2FwdHVyZV9zdG9yZV9iaW5kaW5nIH0gZnJvbSAnLi9yZWFjdGl2aXR5L3N0b3JlLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geygpID0+IGFueX0gY29sbGVjdGlvblxuICogQHBhcmFtIHsoaXRlbTogYW55LCBpbmRleDogbnVtYmVyKSA9PiBzdHJpbmd9IGtleV9mblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY29sbGVjdGlvbiwga2V5X2ZuKSB7XG5cdHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG5cdFx0Y29uc3QgbWF5YmVfYXJyYXkgPSBjb2xsZWN0aW9uKCk7XG5cdFx0Y29uc3QgYXJyYXkgPSBpc19hcnJheShtYXliZV9hcnJheSlcblx0XHRcdD8gbWF5YmVfYXJyYXlcblx0XHRcdDogbWF5YmVfYXJyYXkgPT0gbnVsbFxuXHRcdFx0XHQ/IFtdXG5cdFx0XHRcdDogQXJyYXkuZnJvbShtYXliZV9hcnJheSk7XG5cdFx0Y29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGtleSA9IGtleV9mbihhcnJheVtpXSwgaSk7XG5cdFx0XHRpZiAoa2V5cy5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBhID0gU3RyaW5nKGtleXMuZ2V0KGtleSkpO1xuXHRcdFx0XHRjb25zdCBiID0gU3RyaW5nKGkpO1xuXG5cdFx0XHRcdC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cblx0XHRcdFx0bGV0IGsgPSBTdHJpbmcoa2V5KTtcblx0XHRcdFx0aWYgKGsuc3RhcnRzV2l0aCgnW29iamVjdCAnKSkgayA9IG51bGw7XG5cblx0XHRcdFx0ZS5lYWNoX2tleV9kdXBsaWNhdGUoYSwgYiwgayk7XG5cdFx0XHR9XG5cdFx0XHRrZXlzLnNldChrZXksIGkpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmRpbmdcbiAqIEBwYXJhbSB7KCkgPT4gUmVjb3JkPHN0cmluZywgYW55Pn0gZ2V0X29iamVjdFxuICogQHBhcmFtIHsoKSA9PiBzdHJpbmd9IGdldF9wcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlX2JpbmRpbmcoYmluZGluZywgZ2V0X29iamVjdCwgZ2V0X3Byb3BlcnR5LCBsaW5lLCBjb2x1bW4pIHtcblx0dmFyIHdhcm5lZCA9IGZhbHNlO1xuXG5cdHZhciBmaWxlbmFtZSA9IGRldl9jdXJyZW50X2NvbXBvbmVudF9mdW5jdGlvbj8uW0ZJTEVOQU1FXTtcblxuXHRyZW5kZXJfZWZmZWN0KCgpID0+IHtcblx0XHRpZiAod2FybmVkKSByZXR1cm47XG5cblx0XHR2YXIgW29iamVjdCwgaXNfc3RvcmVfc3ViXSA9IGNhcHR1cmVfc3RvcmVfYmluZGluZyhnZXRfb2JqZWN0KTtcblxuXHRcdGlmIChpc19zdG9yZV9zdWIpIHJldHVybjtcblxuXHRcdHZhciBwcm9wZXJ0eSA9IGdldF9wcm9wZXJ0eSgpO1xuXG5cdFx0dmFyIHJhbiA9IGZhbHNlO1xuXG5cdFx0Ly8gYnkgbWFraW5nIHRoZSAocG9zc2libHkgZmFsc2UsIGJ1dCBpdCB3b3VsZCBiZSBhbiBleHRyZW1lIGVkZ2UgY2FzZSkgYXNzdW1wdGlvblxuXHRcdC8vIHRoYXQgYSBnZXR0ZXIgaGFzIGEgY29ycmVzcG9uZGluZyBzZXR0ZXIsIHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBwcm9wZXJ0eSBpc1xuXHRcdC8vIHJlYWN0aXZlIGJ5IHNlZWluZyBpZiB0aGlzIGVmZmVjdCBoYXMgZGVwZW5kZW5jaWVzXG5cdFx0dmFyIGVmZmVjdCA9IHJlbmRlcl9lZmZlY3QoKCkgPT4ge1xuXHRcdFx0aWYgKHJhbikgcmV0dXJuO1xuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0b2JqZWN0W3Byb3BlcnR5XTtcblx0XHR9KTtcblxuXHRcdHJhbiA9IHRydWU7XG5cblx0XHRpZiAoZWZmZWN0LmRlcHMgPT09IG51bGwpIHtcblx0XHRcdHZhciBsb2NhdGlvbiA9IGAke2ZpbGVuYW1lfToke2xpbmV9OiR7Y29sdW1ufWA7XG5cdFx0XHR3LmJpbmRpbmdfcHJvcGVydHlfbm9uX3JlYWN0aXZlKGJpbmRpbmcsIGxvY2F0aW9uKTtcblxuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xufVxuIiwgIi8qKiBAaW1wb3J0IHsgQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zLCBDb21wb25lbnRUeXBlLCBTdmVsdGVDb21wb25lbnQsIENvbXBvbmVudCB9IGZyb20gJ3N2ZWx0ZScgKi9cbmltcG9ydCB7IERJUlRZLCBMRUdBQ1lfUFJPUFMsIE1BWUJFX0RJUlRZIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyB1c2VyX3ByZV9lZmZlY3QgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9lZmZlY3RzLmpzJztcbmltcG9ydCB7IG11dGFibGVfc291cmNlLCBzZXQgfSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvcmVhY3Rpdml0eS9zb3VyY2VzLmpzJztcbmltcG9ydCB7IGh5ZHJhdGUsIG1vdW50LCB1bm1vdW50IH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlbmRlci5qcyc7XG5pbXBvcnQgeyBhY3RpdmVfZWZmZWN0LCBnZXQsIHNldF9zaWduYWxfc3RhdHVzIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3J1bnRpbWUuanMnO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L3JlYWN0aXZpdHkvYmF0Y2guanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBpc19hcnJheSB9IGZyb20gJy4uL2ludGVybmFsL3NoYXJlZC91dGlscy5qcyc7XG5pbXBvcnQgKiBhcyBlIGZyb20gJy4uL2ludGVybmFsL2NsaWVudC9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgdyBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgREVWIH0gZnJvbSAnZXNtLWVudic7XG5pbXBvcnQgeyBGSUxFTkFNRSB9IGZyb20gJy4uL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBjb21wb25lbnRfY29udGV4dCwgZGV2X2N1cnJlbnRfY29tcG9uZW50X2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwvY2xpZW50L2NvbnRleHQuanMnO1xuaW1wb3J0IHsgYXN5bmNfbW9kZV9mbGFnIH0gZnJvbSAnLi4vaW50ZXJuYWwvZmxhZ3MvaW5kZXguanMnO1xuXG4vKipcbiAqIFRha2VzIHRoZSBzYW1lIG9wdGlvbnMgYXMgYSBTdmVsdGUgNCBjb21wb25lbnQgYW5kIHRoZSBjb21wb25lbnQgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBTdmVsdGUgNCBjb21wYXRpYmxlIGNvbXBvbmVudC5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhpcyBvbmx5IGFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uIHRvIG1pZ3JhdGUgeW91ciBpbXBlcmF0aXZlIGNvbXBvbmVudCBjb2RlIHRvIFN2ZWx0ZSA1LlxuICpcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gUHJvcHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXhwb3J0c1xuICogQHRlbXBsYXRlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBFdmVudHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gU2xvdHNcbiAqXG4gKiBAcGFyYW0ge0NvbXBvbmVudENvbnN0cnVjdG9yT3B0aW9uczxQcm9wcz4gJiB7XG4gKiBcdGNvbXBvbmVudDogQ29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cywgU2xvdHM+PiB8IENvbXBvbmVudDxQcm9wcz47XG4gKiB9fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7U3ZlbHRlQ29tcG9uZW50PFByb3BzLCBFdmVudHMsIFNsb3RzPiAmIEV4cG9ydHN9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDbGFzc0NvbXBvbmVudChvcHRpb25zKSB7XG5cdC8vIEB0cy1leHBlY3QtZXJyb3IgJCRwcm9wX2RlZiBldGMgYXJlIG5vdCBhY3R1YWxseSBkZWZpbmVkXG5cdHJldHVybiBuZXcgU3ZlbHRlNENvbXBvbmVudChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgY29tcG9uZW50IGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgU3ZlbHRlIDQgY29tcGF0aWJsZSBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoaXMgb25seSBhcyBhIHRlbXBvcmFyeSBzb2x1dGlvbiB0byBtaWdyYXRlIHlvdXIgaW1wZXJhdGl2ZSBjb21wb25lbnQgY29kZSB0byBTdmVsdGUgNS5cbiAqXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFByb3BzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IEV4cG9ydHNcbiAqIEB0ZW1wbGF0ZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gRXZlbnRzXG4gKiBAdGVtcGxhdGUge1JlY29yZDxzdHJpbmcsIGFueT59IFNsb3RzXG4gKlxuICogQHBhcmFtIHtTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cywgU2xvdHM+IHwgQ29tcG9uZW50PFByb3BzPn0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7Q29tcG9uZW50VHlwZTxTdmVsdGVDb21wb25lbnQ8UHJvcHMsIEV2ZW50cywgU2xvdHM+ICYgRXhwb3J0cz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkge1xuXHQvLyBAdHMtZXhwZWN0LWVycm9yICQkcHJvcF9kZWYgZXRjIGFyZSBub3QgYWN0dWFsbHkgZGVmaW5lZFxuXHRyZXR1cm4gY2xhc3MgZXh0ZW5kcyBTdmVsdGU0Q29tcG9uZW50IHtcblx0XHQvKiogQHBhcmFtIHthbnl9IG9wdGlvbnMgKi9cblx0XHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0XHRzdXBlcih7XG5cdFx0XHRcdGNvbXBvbmVudCxcblx0XHRcdFx0Li4ub3B0aW9uc1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdXNpbmcgdGhlIGNvbXBvbmVudCBhcyBib3RoIGEgY2xhc3MgYW5kIGZ1bmN0aW9uIGR1cmluZyB0aGUgdHJhbnNpdGlvbiBwZXJpb2RcbiAqIEB0eXBlZGVmICB7e25ldyAobzogQ29tcG9uZW50Q29uc3RydWN0b3JPcHRpb25zKTogU3ZlbHRlQ29tcG9uZW50OyguLi5hcmdzOiBQYXJhbWV0ZXJzPENvbXBvbmVudDxSZWNvcmQ8c3RyaW5nLCBhbnk+Pj4pOiBSZXR1cm5UeXBlPENvbXBvbmVudDxSZWNvcmQ8c3RyaW5nLCBhbnk+LCBSZWNvcmQ8c3RyaW5nLCBhbnk+Pj47fX0gTGVnYWN5Q29tcG9uZW50VHlwZVxuICovXG5cbmNsYXNzIFN2ZWx0ZTRDb21wb25lbnQge1xuXHQvKiogQHR5cGUge2FueX0gKi9cblx0I2V2ZW50cztcblxuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG5cdCNpbnN0YW5jZTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtDb21wb25lbnRDb25zdHJ1Y3Rvck9wdGlvbnMgJiB7XG5cdCAqICBjb21wb25lbnQ6IGFueTtcblx0ICogfX0gb3B0aW9uc1xuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHZhciBzb3VyY2VzID0gbmV3IE1hcCgpO1xuXG5cdFx0LyoqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmcgfCBzeW1ib2x9IGtleVxuXHRcdCAqIEBwYXJhbSB7dW5rbm93bn0gdmFsdWVcblx0XHQgKi9cblx0XHR2YXIgYWRkX3NvdXJjZSA9IChrZXksIHZhbHVlKSA9PiB7XG5cdFx0XHR2YXIgcyA9IG11dGFibGVfc291cmNlKHZhbHVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0c291cmNlcy5zZXQoa2V5LCBzKTtcblx0XHRcdHJldHVybiBzO1xuXHRcdH07XG5cblx0XHQvLyBSZXBsaWNhdGUgY29hcnNlLWdyYWluZWQgcHJvcHMgdGhyb3VnaCBhIHByb3h5IHRoYXQgaGFzIGEgdmVyc2lvbiBzb3VyY2UgZm9yXG5cdFx0Ly8gZWFjaCBwcm9wZXJ0eSwgd2hpY2ggaXMgaW5jcmVtZW50ZWQgb24gdXBkYXRlcyB0byB0aGUgcHJvcGVydHkgaXRzZWxmLiBEbyBub3Rcblx0XHQvLyB1c2Ugb3VyICRzdGF0ZSBwcm94eSBiZWNhdXNlIHRoYXQgb25lIGhhcyBmaW5lLWdyYWluZWQgcmVhY3Rpdml0eS5cblx0XHRjb25zdCBwcm9wcyA9IG5ldyBQcm94eShcblx0XHRcdHsgLi4uKG9wdGlvbnMucHJvcHMgfHwge30pLCAkJGV2ZW50czoge30gfSxcblx0XHRcdHtcblx0XHRcdFx0Z2V0KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0XHRcdHJldHVybiBnZXQoc291cmNlcy5nZXQocHJvcCkgPz8gYWRkX3NvdXJjZShwcm9wLCBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApKSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGhhcyh0YXJnZXQsIHByb3ApIHtcblx0XHRcdFx0XHQvLyBOZWNlc3NhcnkgdG8gbm90IHRocm93IFwiaW52YWxpZCBiaW5kaW5nXCIgdmFsaWRhdGlvbiBlcnJvcnMgb24gdGhlIGNvbXBvbmVudCBzaWRlXG5cdFx0XHRcdFx0aWYgKHByb3AgPT09IExFR0FDWV9QUk9QUykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRnZXQoc291cmNlcy5nZXQocHJvcCkgPz8gYWRkX3NvdXJjZShwcm9wLCBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3ApKSk7XG5cdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG5cdFx0XHRcdFx0c2V0KHNvdXJjZXMuZ2V0KHByb3ApID8/IGFkZF9zb3VyY2UocHJvcCwgdmFsdWUpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdHRoaXMuI2luc3RhbmNlID0gKG9wdGlvbnMuaHlkcmF0ZSA/IGh5ZHJhdGUgOiBtb3VudCkob3B0aW9ucy5jb21wb25lbnQsIHtcblx0XHRcdHRhcmdldDogb3B0aW9ucy50YXJnZXQsXG5cdFx0XHRhbmNob3I6IG9wdGlvbnMuYW5jaG9yLFxuXHRcdFx0cHJvcHMsXG5cdFx0XHRjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG5cdFx0XHRpbnRybzogb3B0aW9ucy5pbnRybyA/PyBmYWxzZSxcblx0XHRcdHJlY292ZXI6IG9wdGlvbnMucmVjb3ZlclxuXHRcdH0pO1xuXG5cdFx0Ly8gV2UgZG9uJ3QgZmx1c2hTeW5jIGZvciBjdXN0b20gZWxlbWVudCB3cmFwcGVycyBvciBpZiB0aGUgdXNlciBkb2Vzbid0IHdhbnQgaXQsXG5cdFx0Ly8gb3IgaWYgd2UncmUgaW4gYXN5bmMgbW9kZSBzaW5jZSBgZmx1c2hTeW5jKClgIHdpbGwgZmFpbFxuXHRcdGlmICghYXN5bmNfbW9kZV9mbGFnICYmICghb3B0aW9ucz8ucHJvcHM/LiQkaG9zdCB8fCBvcHRpb25zLnN5bmMgPT09IGZhbHNlKSkge1xuXHRcdFx0Zmx1c2hTeW5jKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4jZXZlbnRzID0gcHJvcHMuJCRldmVudHM7XG5cblx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLiNpbnN0YW5jZSkpIHtcblx0XHRcdGlmIChrZXkgPT09ICckc2V0JyB8fCBrZXkgPT09ICckZGVzdHJveScgfHwga2V5ID09PSAnJG9uJykgY29udGludWU7XG5cdFx0XHRkZWZpbmVfcHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGdldCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy4jaW5zdGFuY2Vba2V5XTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqIEBwYXJhbSB7YW55fSB2YWx1ZSAqL1xuXHRcdFx0XHRzZXQodmFsdWUpIHtcblx0XHRcdFx0XHR0aGlzLiNpbnN0YW5jZVtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuI2luc3RhbmNlLiRzZXQgPSAvKiogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBuZXh0ICovIChuZXh0KSA9PiB7XG5cdFx0XHRPYmplY3QuYXNzaWduKHByb3BzLCBuZXh0KTtcblx0XHR9O1xuXG5cdFx0dGhpcy4jaW5zdGFuY2UuJGRlc3Ryb3kgPSAoKSA9PiB7XG5cdFx0XHR1bm1vdW50KHRoaXMuI2luc3RhbmNlKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gcHJvcHMgKi9cblx0JHNldChwcm9wcykge1xuXHRcdHRoaXMuI2luc3RhbmNlLiRzZXQocHJvcHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gYW55fSBjYWxsYmFja1xuXHQgKiBAcmV0dXJucyB7YW55fVxuXHQgKi9cblx0JG9uKGV2ZW50LCBjYWxsYmFjaykge1xuXHRcdHRoaXMuI2V2ZW50c1tldmVudF0gPSB0aGlzLiNldmVudHNbZXZlbnRdIHx8IFtdO1xuXG5cdFx0LyoqIEBwYXJhbSB7YW55W119IGFyZ3MgKi9cblx0XHRjb25zdCBjYiA9ICguLi5hcmdzKSA9PiBjYWxsYmFjay5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuXHRcdHRoaXMuI2V2ZW50c1tldmVudF0ucHVzaChjYik7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHRoaXMuI2V2ZW50c1tldmVudF0gPSB0aGlzLiNldmVudHNbZXZlbnRdLmZpbHRlcigvKiogQHBhcmFtIHthbnl9IGZuICovIChmbikgPT4gZm4gIT09IGNiKTtcblx0XHR9O1xuXHR9XG5cblx0JGRlc3Ryb3koKSB7XG5cdFx0dGhpcy4jaW5zdGFuY2UuJGRlc3Ryb3koKTtcblx0fVxufVxuXG4vKipcbiAqIFJ1bnMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uY2UgaW1tZWRpYXRlbHkgb24gdGhlIHNlcnZlciwgYW5kIHdvcmtzIGxpa2UgYCRlZmZlY3QucHJlYCBvbiB0aGUgY2xpZW50LlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGlzIG9ubHkgYXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24gdG8gbWlncmF0ZSB5b3VyIGNvbXBvbmVudCBjb2RlIHRvIFN2ZWx0ZSA1LlxuICogQHBhcmFtIHsoKSA9PiB2b2lkIHwgKCgpID0+IHZvaWQpfSBmblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW4oZm4pIHtcblx0dXNlcl9wcmVfZWZmZWN0KCgpID0+IHtcblx0XHRmbigpO1xuXHRcdHZhciBlZmZlY3QgPSAvKiogQHR5cGUge2ltcG9ydCgnI2NsaWVudCcpLkVmZmVjdH0gKi8gKGFjdGl2ZV9lZmZlY3QpO1xuXHRcdC8vIElmIHRoZSBlZmZlY3QgaXMgaW1tZWRpYXRlbHkgbWFkZSBkaXJ0eSBhZ2FpbiwgbWFyayBpdCBhcyBtYXliZSBkaXJ0eSB0byBlbXVsYXRlIGxlZ2FjeSBiZWhhdmlvdXJcblx0XHRpZiAoKGVmZmVjdC5mICYgRElSVFkpICE9PSAwKSB7XG5cdFx0XHRsZXQgZmlsZW5hbWUgPSBcImEgZmlsZSAod2UgY2FuJ3Qga25vdyB3aGljaCBvbmUpXCI7XG5cdFx0XHRpZiAoREVWKSB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0ZmlsZW5hbWUgPSBkZXZfY3VycmVudF9jb21wb25lbnRfZnVuY3Rpb24/LltGSUxFTkFNRV0gPz8gZmlsZW5hbWU7XG5cdFx0XHR9XG5cdFx0XHR3LmxlZ2FjeV9yZWN1cnNpdmVfcmVhY3RpdmVfYmxvY2soZmlsZW5hbWUpO1xuXHRcdFx0c2V0X3NpZ25hbF9zdGF0dXMoZWZmZWN0LCBNQVlCRV9ESVJUWSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBtaW1pYyB0aGUgbXVsdGlwbGUgbGlzdGVuZXJzIGF2YWlsYWJsZSBpbiBzdmVsdGUgNFxuICogQGRlcHJlY2F0ZWRcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcltdfSBoYW5kbGVyc1xuICogQHJldHVybnMge0V2ZW50TGlzdGVuZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVycyguLi5oYW5kbGVycykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0Y29uc3QgeyBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gfSA9IGV2ZW50O1xuXHRcdGxldCBzdG9wcGVkID0gZmFsc2U7XG5cblx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSAoKSA9PiB7XG5cdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbi5jYWxsKGV2ZW50KTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgZXJyb3JzID0gW107XG5cblx0XHRmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3IgYHRoaXNgIGlzIG5vdCB0eXBlZFxuXHRcdFx0XHRoYW5kbGVyPy5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3JzLnB1c2goZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdG9wcGVkKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAobGV0IGVycm9yIG9mIGVycm9ycykge1xuXHRcdFx0cXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuXHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB0byBjcmVhdGUgYSBgYnViYmxlYCBmdW5jdGlvbiB0aGF0IG1pbWljIHRoZSBiZWhhdmlvciBvZiBgb246Y2xpY2tgIHdpdGhvdXQgaGFuZGxlciBhdmFpbGFibGUgaW4gc3ZlbHRlIDQuXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhpcyBvbmx5IGFzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uIHRvIG1pZ3JhdGUgeW91ciBhdXRvbWF0aWNhbGx5IGRlbGVnYXRlZCBldmVudHMgaW4gU3ZlbHRlIDUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCdWJibGVyKCkge1xuXHRjb25zdCBhY3RpdmVfY29tcG9uZW50X2NvbnRleHQgPSBjb21wb25lbnRfY29udGV4dDtcblx0aWYgKGFjdGl2ZV9jb21wb25lbnRfY29udGV4dCA9PT0gbnVsbCkge1xuXHRcdGUubGlmZWN5Y2xlX291dHNpZGVfY29tcG9uZW50KCdjcmVhdGVCdWJibGVyJyk7XG5cdH1cblxuXHRyZXR1cm4gKC8qKkB0eXBlIHtzdHJpbmd9Ki8gdHlwZSkgPT4gKC8qKkB0eXBlIHtFdmVudH0qLyBldmVudCkgPT4ge1xuXHRcdGNvbnN0IGV2ZW50cyA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRnVuY3Rpb24gfCBGdW5jdGlvbltdPn0gKi8gKFxuXHRcdFx0YWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LnMuJCRldmVudHNcblx0XHQpPy5bLyoqIEB0eXBlIHthbnl9ICovICh0eXBlKV07XG5cblx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRjb25zdCBjYWxsYmFja3MgPSBpc19hcnJheShldmVudHMpID8gZXZlbnRzLnNsaWNlKCkgOiBbZXZlbnRzXTtcblx0XHRcdGZvciAoY29uc3QgZm4gb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGZuLmNhbGwoYWN0aXZlX2NvbXBvbmVudF9jb250ZXh0LngsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG59XG5cbmV4cG9ydCB7XG5cdG9uY2UsXG5cdHByZXZlbnREZWZhdWx0LFxuXHRzZWxmLFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sXG5cdHN0b3BQcm9wYWdhdGlvbixcblx0dHJ1c3RlZCxcblx0cGFzc2l2ZSxcblx0bm9ucGFzc2l2ZVxufSBmcm9tICcuLi9pbnRlcm5hbC9jbGllbnQvZG9tL2xlZ2FjeS9ldmVudC1tb2RpZmllcnMuanMnO1xuIiwgImltcG9ydCB7IGNyZWF0ZUNsYXNzQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vbGVnYWN5L2xlZ2FjeS1jbGllbnQuanMnO1xuaW1wb3J0IHsgZWZmZWN0X3Jvb3QsIHJlbmRlcl9lZmZlY3QgfSBmcm9tICcuLi8uLi9yZWFjdGl2aXR5L2VmZmVjdHMuanMnO1xuaW1wb3J0IHsgYXBwZW5kIH0gZnJvbSAnLi4vdGVtcGxhdGUuanMnO1xuaW1wb3J0IHsgZGVmaW5lX3Byb3BlcnR5LCBnZXRfZGVzY3JpcHRvciwgb2JqZWN0X2tleXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvdXRpbHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEN1c3RvbUVsZW1lbnRQcm9wRGVmaW5pdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdHRyaWJ1dGVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZWZsZWN0XVxuICogQHByb3BlcnR5IHsnU3RyaW5nJ3wnQm9vbGVhbid8J051bWJlcid8J0FycmF5J3wnT2JqZWN0J30gW3R5cGVdXG4gKi9cblxuLyoqIEB0eXBlIHthbnl9ICovXG5sZXQgU3ZlbHRlRWxlbWVudDtcblxuaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cdFx0LyoqIFRoZSBTdmVsdGUgY29tcG9uZW50IGNvbnN0cnVjdG9yICovXG5cdFx0JCRjdG9yO1xuXHRcdC8qKiBTbG90cyAqL1xuXHRcdCQkcztcblx0XHQvKiogQHR5cGUge2FueX0gVGhlIFN2ZWx0ZSBjb21wb25lbnQgaW5zdGFuY2UgKi9cblx0XHQkJGM7XG5cdFx0LyoqIFdoZXRoZXIgb3Igbm90IHRoZSBjdXN0b20gZWxlbWVudCBpcyBjb25uZWN0ZWQgKi9cblx0XHQkJGNuID0gZmFsc2U7XG5cdFx0LyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBDb21wb25lbnQgcHJvcHMgZGF0YSAqL1xuXHRcdCQkZCA9IHt9O1xuXHRcdC8qKiBgdHJ1ZWAgaWYgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIHJlZmxlY3RpbmcgY29tcG9uZW50IHByb3BzIGJhY2sgdG8gYXR0cmlidXRlcyAqL1xuXHRcdCQkciA9IGZhbHNlO1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gUHJvcHMgZGVmaW5pdGlvbiAobmFtZSwgcmVmbGVjdGVkLCB0eXBlIGV0YykgKi9cblx0XHQkJHBfZCA9IHt9O1xuXHRcdC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdFtdPn0gRXZlbnQgbGlzdGVuZXJzICovXG5cdFx0JCRsID0ge307XG5cdFx0LyoqIEB0eXBlIHtNYXA8RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCwgRnVuY3Rpb24+fSBFdmVudCBsaXN0ZW5lciB1bnN1YnNjcmliZSBmdW5jdGlvbnMgKi9cblx0XHQkJGxfdSA9IG5ldyBNYXAoKTtcblx0XHQvKiogQHR5cGUge2FueX0gVGhlIG1hbmFnZWQgcmVuZGVyIGVmZmVjdCBmb3IgcmVmbGVjdGluZyBhdHRyaWJ1dGVzICovXG5cdFx0JCRtZTtcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7Kn0gJCRjb21wb25lbnRDdG9yXG5cdFx0ICogQHBhcmFtIHsqfSAkJHNsb3RzXG5cdFx0ICogQHBhcmFtIHsqfSB1c2Vfc2hhZG93X2RvbVxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yKCQkY29tcG9uZW50Q3RvciwgJCRzbG90cywgdXNlX3NoYWRvd19kb20pIHtcblx0XHRcdHN1cGVyKCk7XG5cdFx0XHR0aGlzLiQkY3RvciA9ICQkY29tcG9uZW50Q3Rvcjtcblx0XHRcdHRoaXMuJCRzID0gJCRzbG90cztcblx0XHRcdGlmICh1c2Vfc2hhZG93X2RvbSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHRcdCAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gbGlzdGVuZXJcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG5cdFx0ICovXG5cdFx0YWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0Ly8gV2UgY2FuJ3QgZGV0ZXJtaW5lIHVwZnJvbnQgaWYgdGhlIGV2ZW50IGlzIGEgY3VzdG9tIGV2ZW50IG9yIG5vdCwgc28gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gbGlzdGVuIHRvIGJvdGguIElmIHNvbWVvbmUgdXNlcyBhIGN1c3RvbSBldmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgYSByZWd1bGFyXG5cdFx0XHQvLyBicm93c2VyIGV2ZW50LCB0aGlzIGZpcmVzIHR3aWNlIC0gd2UgY2FuJ3QgYXZvaWQgdGhhdC5cblx0XHRcdHRoaXMuJCRsW3R5cGVdID0gdGhpcy4kJGxbdHlwZV0gfHwgW107XG5cdFx0XHR0aGlzLiQkbFt0eXBlXS5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdGlmICh0aGlzLiQkYykge1xuXHRcdFx0XHRjb25zdCB1bnN1YiA9IHRoaXMuJCRjLiRvbih0eXBlLCBsaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHR9XG5cdFx0XHRzdXBlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHRcdCAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdH0gbGlzdGVuZXJcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW4gfCBBZGRFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdXG5cdFx0ICovXG5cdFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuXHRcdFx0c3VwZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG5cdFx0XHRpZiAodGhpcy4kJGMpIHtcblx0XHRcdFx0Y29uc3QgdW5zdWIgPSB0aGlzLiQkbF91LmdldChsaXN0ZW5lcik7XG5cdFx0XHRcdGlmICh1bnN1Yikge1xuXHRcdFx0XHRcdHVuc3ViKCk7XG5cdFx0XHRcdFx0dGhpcy4kJGxfdS5kZWxldGUobGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0YXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG5cdFx0XHR0aGlzLiQkY24gPSB0cnVlO1xuXHRcdFx0aWYgKCF0aGlzLiQkYykge1xuXHRcdFx0XHQvLyBXZSB3YWl0IG9uZSB0aWNrIHRvIGxldCBwb3NzaWJsZSBjaGlsZCBzbG90IGVsZW1lbnRzIGJlIGNyZWF0ZWQvbW91bnRlZFxuXHRcdFx0XHRhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcblx0XHRcdFx0aWYgKCF0aGlzLiQkY24gfHwgdGhpcy4kJGMpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0LyoqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICovXG5cdFx0XHRcdGZ1bmN0aW9uIGNyZWF0ZV9zbG90KG5hbWUpIHtcblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGFuY2hvclxuXHRcdFx0XHRcdCAqL1xuXHRcdFx0XHRcdHJldHVybiAoYW5jaG9yKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzbG90ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2xvdCcpO1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgIT09ICdkZWZhdWx0Jykgc2xvdC5uYW1lID0gbmFtZTtcblxuXHRcdFx0XHRcdFx0YXBwZW5kKGFuY2hvciwgc2xvdCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG5cdFx0XHRcdGNvbnN0ICQkc2xvdHMgPSB7fTtcblx0XHRcdFx0Y29uc3QgZXhpc3Rpbmdfc2xvdHMgPSBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKHRoaXMpO1xuXHRcdFx0XHRmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy4kJHMpIHtcblx0XHRcdFx0XHRpZiAobmFtZSBpbiBleGlzdGluZ19zbG90cykge1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdkZWZhdWx0JyAmJiAhdGhpcy4kJGQuY2hpbGRyZW4pIHtcblx0XHRcdFx0XHRcdFx0dGhpcy4kJGQuY2hpbGRyZW4gPSBjcmVhdGVfc2xvdChuYW1lKTtcblx0XHRcdFx0XHRcdFx0JCRzbG90cy5kZWZhdWx0ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdCQkc2xvdHNbbmFtZV0gPSBjcmVhdGVfc2xvdChuYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgdGhpcy5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcy4kJGRhdGEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMuYXR0cmlidXRlc1xuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSB0aGlzLiQkZ19wKGF0dHJpYnV0ZS5uYW1lKTtcblx0XHRcdFx0XHRpZiAoIShuYW1lIGluIHRoaXMuJCRkKSkge1xuXHRcdFx0XHRcdFx0dGhpcy4kJGRbbmFtZV0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUobmFtZSwgYXR0cmlidXRlLnZhbHVlLCB0aGlzLiQkcF9kLCAndG9Qcm9wJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFBvcnQgb3ZlciBwcm9wcyB0aGF0IHdlcmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgYmVmb3JlIGNlIHdhcyBpbml0aWFsaXplZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiQkcF9kKSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvclxuXHRcdFx0XHRcdGlmICghKGtleSBpbiB0aGlzLiQkZCkgJiYgdGhpc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdC8vIEB0cy1leHBlY3QtZXJyb3Jcblx0XHRcdFx0XHRcdHRoaXMuJCRkW2tleV0gPSB0aGlzW2tleV07IC8vIGRvbid0IHRyYW5zZm9ybSwgdGhlc2Ugd2VyZSBzZXQgdGhyb3VnaCBKYXZhU2NyaXB0XG5cdFx0XHRcdFx0XHQvLyBAdHMtZXhwZWN0LWVycm9yXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpc1trZXldOyAvLyByZW1vdmUgdGhlIHByb3BlcnR5IHRoYXQgc2hhZG93cyB0aGUgZ2V0dGVyL3NldHRlclxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLiQkYyA9IGNyZWF0ZUNsYXNzQ29tcG9uZW50KHtcblx0XHRcdFx0XHRjb21wb25lbnQ6IHRoaXMuJCRjdG9yLFxuXHRcdFx0XHRcdHRhcmdldDogdGhpcy5zaGFkb3dSb290IHx8IHRoaXMsXG5cdFx0XHRcdFx0cHJvcHM6IHtcblx0XHRcdFx0XHRcdC4uLnRoaXMuJCRkLFxuXHRcdFx0XHRcdFx0JCRzbG90cyxcblx0XHRcdFx0XHRcdCQkaG9zdDogdGhpc1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gUmVmbGVjdCBjb21wb25lbnQgcHJvcHMgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHR0aGlzLiQkbWUgPSBlZmZlY3Rfcm9vdCgoKSA9PiB7XG5cdFx0XHRcdFx0cmVuZGVyX2VmZmVjdCgoKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLiQkciA9IHRydWU7XG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IGtleSBvZiBvYmplY3Rfa2V5cyh0aGlzLiQkYykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLiQkcF9kW2tleV0/LnJlZmxlY3QpIGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldID0gdGhpcy4kJGNba2V5XTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlX3ZhbHVlID0gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKFxuXHRcdFx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLiQkZFtrZXldLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuJCRwX2QsXG5cdFx0XHRcdFx0XHRcdFx0J3RvQXR0cmlidXRlJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAoYXR0cmlidXRlX3ZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlIHx8IGtleSk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUodGhpcy4kJHBfZFtrZXldLmF0dHJpYnV0ZSB8fCBrZXksIGF0dHJpYnV0ZV92YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHRoaXMuJCRyID0gZmFsc2U7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLiQkbCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4kJGxbdHlwZV0pIHtcblx0XHRcdFx0XHRcdGNvbnN0IHVuc3ViID0gdGhpcy4kJGMuJG9uKHR5cGUsIGxpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHRoaXMuJCRsX3Uuc2V0KGxpc3RlbmVyLCB1bnN1Yik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuJCRsID0ge307XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gV2UgZG9uJ3QgbmVlZCB0aGlzIHdoZW4gd29ya2luZyB3aXRoaW4gU3ZlbHRlIGNvZGUsIGJ1dCBmb3IgY29tcGF0aWJpbGl0eSBvZiBwZW9wbGUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIFN2ZWx0ZVxuXHRcdC8vIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgdGhyb3VnaCBzZXRBdHRyaWJ1dGUgZXRjLCB0aGlzIGlzIGhlbHBmdWxcblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IF9vbGRWYWx1ZVxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZVxuXHRcdCAqL1xuXHRcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBfb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy4kJHIpIHJldHVybjtcblx0XHRcdGF0dHIgPSB0aGlzLiQkZ19wKGF0dHIpO1xuXHRcdFx0dGhpcy4kJGRbYXR0cl0gPSBnZXRfY3VzdG9tX2VsZW1lbnRfdmFsdWUoYXR0ciwgbmV3VmFsdWUsIHRoaXMuJCRwX2QsICd0b1Byb3AnKTtcblx0XHRcdHRoaXMuJCRjPy4kc2V0KHsgW2F0dHJdOiB0aGlzLiQkZFthdHRyXSB9KTtcblx0XHR9XG5cblx0XHRkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcblx0XHRcdHRoaXMuJCRjbiA9IGZhbHNlO1xuXHRcdFx0Ly8gSW4gYSBtaWNyb3Rhc2ssIGJlY2F1c2UgdGhpcyBjb3VsZCBiZSBhIG1vdmUgd2l0aGluIHRoZSBET01cblx0XHRcdFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuJCRjbiAmJiB0aGlzLiQkYykge1xuXHRcdFx0XHRcdHRoaXMuJCRjLiRkZXN0cm95KCk7XG5cdFx0XHRcdFx0dGhpcy4kJG1lKCk7XG5cdFx0XHRcdFx0dGhpcy4kJGMgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVfbmFtZVxuXHRcdCAqL1xuXHRcdCQkZ19wKGF0dHJpYnV0ZV9uYW1lKSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRvYmplY3Rfa2V5cyh0aGlzLiQkcF9kKS5maW5kKFxuXHRcdFx0XHRcdChrZXkpID0+XG5cdFx0XHRcdFx0XHR0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlID09PSBhdHRyaWJ1dGVfbmFtZSB8fFxuXHRcdFx0XHRcdFx0KCF0aGlzLiQkcF9kW2tleV0uYXR0cmlidXRlICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSBhdHRyaWJ1dGVfbmFtZSlcblx0XHRcdFx0KSB8fCBhdHRyaWJ1dGVfbmFtZVxuXHRcdFx0KTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBDdXN0b21FbGVtZW50UHJvcERlZmluaXRpb24+fSBwcm9wc19kZWZpbml0aW9uXG4gKiBAcGFyYW0geyd0b0F0dHJpYnV0ZScgfCAndG9Qcm9wJ30gW3RyYW5zZm9ybV1cbiAqL1xuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50X3ZhbHVlKHByb3AsIHZhbHVlLCBwcm9wc19kZWZpbml0aW9uLCB0cmFuc2Zvcm0pIHtcblx0Y29uc3QgdHlwZSA9IHByb3BzX2RlZmluaXRpb25bcHJvcF0/LnR5cGU7XG5cdHZhbHVlID0gdHlwZSA9PT0gJ0Jvb2xlYW4nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nID8gdmFsdWUgIT0gbnVsbCA6IHZhbHVlO1xuXHRpZiAoIXRyYW5zZm9ybSB8fCAhcHJvcHNfZGVmaW5pdGlvbltwcm9wXSkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0cmFuc2Zvcm0gPT09ICd0b0F0dHJpYnV0ZScpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRjYXNlICdBcnJheSc6XG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblx0XHRcdGNhc2UgJ0Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPyAnJyA6IG51bGw7XG5cdFx0XHRjYXNlICdOdW1iZXInOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG51bGwgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgJiYgSlNPTi5wYXJzZSh2YWx1ZSk7XG5cdFx0XHRjYXNlICdCb29sZWFuJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlOyAvLyBjb252ZXJzaW9uIGFscmVhZHkgaGFuZGxlZCBhYm92ZVxuXHRcdFx0Y2FzZSAnTnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIHZhbHVlICE9IG51bGwgPyArdmFsdWUgOiB2YWx1ZTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuXHQvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHRydWU+fSAqL1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0ZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcblx0XHRyZXN1bHRbLyoqIEB0eXBlIHtFbGVtZW50fSBub2RlICovIChub2RlKS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBUdXJuIGEgU3ZlbHRlIGNvbXBvbmVudCBpbnRvIGEgY3VzdG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2FueX0gQ29tcG9uZW50ICBBIFN2ZWx0ZSBjb21wb25lbnQgZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgQ3VzdG9tRWxlbWVudFByb3BEZWZpbml0aW9uPn0gcHJvcHNfZGVmaW5pdGlvbiAgVGhlIHByb3BzIHRvIG9ic2VydmVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHNsb3RzICBUaGUgc2xvdHMgdG8gY3JlYXRlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBleHBvcnRzICBFeHBsaWNpdGx5IGV4cG9ydGVkIHZhbHVlcywgb3RoZXIgdGhhbiBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSB1c2Vfc2hhZG93X2RvbSAgV2hldGhlciB0byB1c2Ugc2hhZG93IERPTVxuICogQHBhcmFtIHsoY2U6IG5ldyAoKSA9PiBIVE1MRWxlbWVudCkgPT4gbmV3ICgpID0+IEhUTUxFbGVtZW50fSBbZXh0ZW5kXVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlX2N1c3RvbV9lbGVtZW50KFxuXHRDb21wb25lbnQsXG5cdHByb3BzX2RlZmluaXRpb24sXG5cdHNsb3RzLFxuXHRleHBvcnRzLFxuXHR1c2Vfc2hhZG93X2RvbSxcblx0ZXh0ZW5kXG4pIHtcblx0bGV0IENsYXNzID0gY2xhc3MgZXh0ZW5kcyBTdmVsdGVFbGVtZW50IHtcblx0XHRjb25zdHJ1Y3RvcigpIHtcblx0XHRcdHN1cGVyKENvbXBvbmVudCwgc2xvdHMsIHVzZV9zaGFkb3dfZG9tKTtcblx0XHRcdHRoaXMuJCRwX2QgPSBwcm9wc19kZWZpbml0aW9uO1xuXHRcdH1cblx0XHRzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcblx0XHRcdHJldHVybiBvYmplY3Rfa2V5cyhwcm9wc19kZWZpbml0aW9uKS5tYXAoKGtleSkgPT5cblx0XHRcdFx0KHByb3BzX2RlZmluaXRpb25ba2V5XS5hdHRyaWJ1dGUgfHwga2V5KS50b0xvd2VyQ2FzZSgpXG5cdFx0XHQpO1xuXHRcdH1cblx0fTtcblx0b2JqZWN0X2tleXMocHJvcHNfZGVmaW5pdGlvbikuZm9yRWFjaCgocHJvcCkgPT4ge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIHByb3AsIHtcblx0XHRcdGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuJCRjICYmIHByb3AgaW4gdGhpcy4kJGMgPyB0aGlzLiQkY1twcm9wXSA6IHRoaXMuJCRkW3Byb3BdO1xuXHRcdFx0fSxcblx0XHRcdHNldCh2YWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGdldF9jdXN0b21fZWxlbWVudF92YWx1ZShwcm9wLCB2YWx1ZSwgcHJvcHNfZGVmaW5pdGlvbik7XG5cdFx0XHRcdHRoaXMuJCRkW3Byb3BdID0gdmFsdWU7XG5cdFx0XHRcdHZhciBjb21wb25lbnQgPSB0aGlzLiQkYztcblxuXHRcdFx0XHRpZiAoY29tcG9uZW50KSB7XG5cdFx0XHRcdFx0Ly8gLy8gSWYgdGhlIGluc3RhbmNlIGhhcyBhbiBhY2Nlc3NvciwgdXNlIHRoYXQgaW5zdGVhZFxuXHRcdFx0XHRcdHZhciBzZXR0ZXIgPSBnZXRfZGVzY3JpcHRvcihjb21wb25lbnQsIHByb3ApPy5nZXQ7XG5cblx0XHRcdFx0XHRpZiAoc2V0dGVyKSB7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRbcHJvcF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50LiRzZXQoeyBbcHJvcF06IHZhbHVlIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0ZXhwb3J0cy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuXHRcdGRlZmluZV9wcm9wZXJ0eShDbGFzcy5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG5cdFx0XHRnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLiQkYz8uW3Byb3BlcnR5XTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdGlmIChleHRlbmQpIHtcblx0XHQvLyBAdHMtZXhwZWN0LWVycm9yIC0gYXNzaWduaW5nIGhlcmUgaXMgZmluZVxuXHRcdENsYXNzID0gZXh0ZW5kKENsYXNzKTtcblx0fVxuXHRDb21wb25lbnQuZWxlbWVudCA9IC8qKiBAdHlwZSB7YW55fSAqLyBDbGFzcztcblx0cmV0dXJuIENsYXNzO1xufVxuIiwgImltcG9ydCB7IFNUQVRFX1NZTUJPTCB9IGZyb20gJyNjbGllbnQvY29uc3RhbnRzJztcbmltcG9ydCB7IHNuYXBzaG90IH0gZnJvbSAnLi4vLi4vc2hhcmVkL2Nsb25lLmpzJztcbmltcG9ydCAqIGFzIHcgZnJvbSAnLi4vd2FybmluZ3MuanMnO1xuaW1wb3J0IHsgdW50cmFjayB9IGZyb20gJy4uL3J1bnRpbWUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSAgey4uLmFueX0gb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gbG9nX2lmX2NvbnRhaW5zX3N0YXRlKG1ldGhvZCwgLi4ub2JqZWN0cykge1xuXHR1bnRyYWNrKCgpID0+IHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IGhhc19zdGF0ZSA9IGZhbHNlO1xuXHRcdFx0Y29uc3QgdHJhbnNmb3JtZWQgPSBbXTtcblxuXHRcdFx0Zm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuXHRcdFx0XHRpZiAob2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIFNUQVRFX1NZTUJPTCBpbiBvYmopIHtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZC5wdXNoKHNuYXBzaG90KG9iaiwgdHJ1ZSkpO1xuXHRcdFx0XHRcdGhhc19zdGF0ZSA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQucHVzaChvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYXNfc3RhdGUpIHtcblx0XHRcdFx0dy5jb25zb2xlX2xvZ19zdGF0ZShtZXRob2QpO1xuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdGNvbnNvbGUubG9nKCclY1tzbmFwc2hvdF0nLCAnY29sb3I6IGdyZXknLCAuLi50cmFuc2Zvcm1lZCk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCB7fVxuXHR9KTtcblxuXHRyZXR1cm4gb2JqZWN0cztcbn1cbiIsICJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwb3J0IGV2ZXJ5dGhpbmcgZnJvbSBTdmVsdGUncyBpbnRlcm5hbCBjbGllbnQgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICBleHBvcnQgKiBmcm9tICdzdmVsdGUvaW50ZXJuYWwvY2xpZW50JztcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28gZXhwb3J0IG1vdW50IGFuZCBoeWRyYXRlIGZyb20gbWFpbiBzdmVsdGUgcGFja2FnZVxuICAgICAgICAgICAgICAgICAgICBleHBvcnQgeyBtb3VudCwgaHlkcmF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnXHUyNzA1IFN2ZWx0ZSA1IHJ1bnRpbWUgbG9hZGVkJyk7XG4gICAgICAgICAgICAgICAgIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7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LENBQUM7QUFBQSxFQUNGLENBQUM7QUFDRCxVQUFRLFFBQVEsQ0FBQyxhQUFhO0FBQzdCLG9CQUFnQixNQUFNLFdBQVcsVUFBVTtBQUFBLE1BQzFDLE1BQU07QUFDTCxlQUFPLEtBQUssTUFBTSxRQUFRO0FBQUEsTUFDM0I7QUFBQSxJQUNELENBQUM7QUFBQSxFQUNGLENBQUM7QUFDRCxNQUFJLFFBQVE7QUFFWCxZQUFRLE9BQU8sS0FBSztBQUFBLEVBQ3JCO0FBQ0EsWUFBVTtBQUFBLEVBQTZCO0FBQ3ZDLFNBQU87QUFDUjs7O0FDeFVPLFNBQVMsc0JBQXNCLFdBQVcsU0FBUztBQUN6RCxVQUFRLE1BQU07QUFDYixRQUFJO0FBQ0gsVUFBSSxZQUFZO0FBQ2hCLFlBQU0sY0FBYyxDQUFDO0FBRXJCLGlCQUFXLE9BQU8sU0FBUztBQUMxQixZQUFJLE9BQU8sT0FBTyxRQUFRLFlBQVksZ0JBQWdCLEtBQUs7QUFDMUQsc0JBQVksS0FBSyxTQUFTLEtBQUssSUFBSSxDQUFDO0FBQ3BDLHNCQUFZO0FBQUEsUUFDYixPQUFPO0FBQ04sc0JBQVksS0FBSyxHQUFHO0FBQUEsUUFDckI7QUFBQSxNQUNEO0FBRUEsVUFBSSxXQUFXO0FBQ2QsUUFBRSxrQkFBa0IsTUFBTTtBQUcxQixnQkFBUSxJQUFJLGdCQUFnQixlQUFlLEdBQUcsV0FBVztBQUFBLE1BQzFEO0FBQUEsSUFDRCxRQUFRO0FBQUEsSUFBQztBQUFBLEVBQ1YsQ0FBQztBQUVELFNBQU87QUFDUjs7O0FDM0JvQixRQUFRLElBQUksZ0NBQTJCOyIsCiAgIm5hbWVzIjogWyJmYWxsYmFjayIsICJlbGVtZW50IiwgImNvbXBvbmVudCIsICJrZXkiLCAiaHRtbCIsICJwcm9wIiwgImNoaWxkIiwgIm5leHQiLCAiYm9sZCIsICJub3JtYWwiLCAidGFnIiwgImVsZW1lbnQiLCAia2V5IiwgInRyYWNlIiwgInN0YWNrIiwgInNvdXJjZSIsICJzdGFjayIsICJjb21wb25lbnQiLCAiY29tcG9uZW50IiwgImVmZmVjdCIsICJ0YXNrcyIsICJwZW5kaW5nIiwgInJlc2V0IiwgImVycm9yIiwgImVmZmVjdCIsICJuZXh0IiwgImJvdW5kYXJ5IiwgImZsYWdzIiwgImJvdW5kYXJ5IiwgInIiLCAicGVuZGluZyIsICJuZXh0IiwgImRlcml2ZWQiLCAiYXN5bmMiLCAiYm91bmRhcnkiLCAicHJldmlvdXNfYmF0Y2giLCAic291cmNlIiwgImVmZmVjdCIsICJ1cGRhdGUiLCAiZmxhZ3MiLCAiY2hpbGQiLCAic3RhY2siLCAiYm91bmRhcnkiLCAicGVuZGluZyIsICJzdGFjayIsICJzb3VyY2UiLCAiZWZmZWN0IiwgImZsYWdzIiwgInN0YWNrIiwgInZlcnNpb24iLCAicHJvcCIsICJzb3VyY2UiLCAicyIsICJ2YWx1ZSIsICJrZXkiLCAiYXJyYXlfcHJvdG90eXBlIiwgImluZGV4IiwgImVxdWFscyIsICJjaGlsZCIsICJ0ZXh0IiwgImZsYWdzIiwgInRhZyIsICJpcyIsICJlbGVtZW50IiwgImtleSIsICJuYW1lIiwgImVsZW1lbnQiLCAiZXZlbnQiLCAiZWZmZWN0IiwgInB1c2giLCAiZSIsICJkZXJpdmVkIiwgImZsYWdzIiwgImFzeW5jIiwgInRlYXJkb3duIiwgIm5leHQiLCAidHJhbnNpdGlvbiIsICJjaGlsZCIsICJzaWJsaW5nIiwgImVmZmVjdCIsICJmbGFncyIsICJkZXJpdmVkIiwgImluZGV4IiwgInRlYXJkb3duIiwgImZsYWdzIiwgImRlcml2ZWQiLCAidHJhY2UiLCAia2V5IiwgInByb3AiLCAiZ2V0IiwgImV2ZW50IiwgImNhcHR1cmUiLCAicGFzc2l2ZSIsICJldmVudCIsICJlbGVtZW50IiwgImNvbXBvbmVudCIsICJodG1sIiwgImVmZmVjdCIsICJmbGFncyIsICJjbG9uZSIsICJlbGVtZW50IiwgImtleSIsICJoYXNoIiwgInRleHQiLCAiY29tcG9uZW50IiwgImV2ZW50cyIsICJwYXNzaXZlIiwgInVubW91bnQiLCAidGFnIiwgInNuaXBwZXQiLCAiY29tcG9uZW50IiwgImhhc2giLCAiZWxlbWVudCIsICJjb21tZW50IiwgImVmZmVjdCIsICJzb3VyY2UiLCAiY29tcG9uZW50IiwgImNvbXBvbmVudCIsICJwcm9wIiwgImtleSIsICJjb21wb25lbnQiLCAiYm91bmRhcnkiLCAidXBkYXRlIiwgInN0YXRlIiwgImVmZmVjdCIsICJmbGFncyIsICJmbiIsICJrZXkiLCAiZWZmZWN0IiwgImVsZW1lbnQiLCAia2V5IiwgInN0YXRlIiwgImkiLCAiZmxhZ3MiLCAiZmFsbGJhY2siLCAia2V5IiwgIml0ZW0iLCAicGVuZGluZyIsICJuZXh0IiwgImluZGV4IiwgImRlZmVycmVkIiwgImVsZW1lbnQiLCAiZWZmZWN0IiwgImhhc2giLCAibmV4dCIsICJodG1sIiwgIm5vZGUiLCAia2V5IiwgImNvbXBvbmVudCIsICJlZmZlY3QiLCAidGFnIiwgImVsZW1lbnQiLCAiZWZmZWN0IiwgImFjdGlvbiIsICJjbHN4IiwgImhhc2giLCAia2V5IiwgImFwcGVuZF9zdHlsZXMiLCAiaGFzaCIsICJrZXkiLCAibmV4dCIsICJrZXkiLCAiZ2V0IiwgInNldCIsICJzZXRfYXR0cmlidXRlIiwgImVsZW1lbnQiLCAicHJvcCIsICJuZXh0IiwgImtleSIsICJjbHN4IiwgImFzeW5jIiwgIm5vdyIsICJlbGVtZW50IiwgImFuaW1hdGlvbiIsICJ0byIsICJmbGFncyIsICJ0cmFuc2l0aW9uIiwgInJ1biIsICJibG9jayIsICJhYm9ydGVkIiwgInRpY2siLCAia2V5ZnJhbWVzIiwgInN0eWxlcyIsICJ0IiwgInVwZGF0ZSIsICJldmVudCIsICJnZXQiLCAic2V0IiwgImJhdGNoZXMiLCAicGVuZGluZyIsICJoeWRyYXRpb25fbWlzbWF0Y2giLCAiaW5kZXgiLCAiaW5wdXQiLCAiZ2V0IiwgInNldCIsICJ1cGRhdGUiLCAidXBkYXRlIiwgInByb3AiLCAiZWxlbWVudCIsICJsaXN0ZW5lcnMiLCAic2V0IiwgInVwZGF0ZSIsICJlbGVtZW50IiwgImdldCIsICJzZXQiLCAiZ2V0IiwgInNldCIsICJldmVudCIsICJwcm9wcyIsICJrZXkiLCAiZXZlbnQiLCAia2V5IiwgInJ1biIsICJnZXQiLCAiZ2V0IiwgImtleSIsICJmbGFncyIsICJmYWxsYmFjayIsICJrZXkiLCAiZWZmZWN0IiwgImtleSIsICJwcm9wIiwgIm5leHQiLCAiZXZlbnQiLCAic2xvdCIsICJrZXkiLCAiYXR0ciIsICJwcm9wIiwgImVsZW1lbnQiLCAiY29tcG9uZW50Il0KfQo=
